#!/bin/bash

# utilities for commands/journal
function nu0 { if [ ${1:-0} -eq $1 ] 2>$s3;then echo $1;else echo 0;fi; }                                                                                     # get numeric output (must use [ ] test)
function nu1 { echo "scale=$2;$1"        |bc; }                                                                                                               # get arbitrary precision calculations
function nu2 { echo 0$(printf '+%i' $@)  |bc; }                                                                                                               # get sum                list of numbers
function nu3 { echo 0$(printf '+%i^2' $@)|bc; }                                                                                                               # get sum squares        list of numbers
function nu4 { nu7 "sqrt(($(nu3 $@)-$(nu2 $@)^2/$#)/$#)" 4 1000; }                                                                                            # get standard deviation list of numbers
function nu5 { if [[ $# -ne 0  ]];then nu7 $(nu2 $@)/$# 5 1                                        ;else echo 0;fi; }                                         # get average            list of numbers
function nu6 { if [[ $5 -ne 0  ]];then nu1 "($1*$pmis+$2*$pmat+$3*$pmah+$4*$pdly)/$5*$rate/$decp" 2;else echo 0;fi; }                                         # get penalty
function nu7 { printf ${4:-%.0f} $(nu1 $1*${3:-100} ${2:-0}); }                                                                                               # format arbitrary precision calculations
function fs0 { echo $H|sudo -S grep    "${3:-lighthouse}.*$1" $s1 2>$s3|if [[ ${2:-0} -le 0 ]];then cat;else tail -n${2:-0};fi; }                             # get tail     syslog lines
function fs1 { echo $H|sudo -S grep    "$1"                   $s1 2>$s3; }                                                                                    # get specific syslog lines
function fs2 { echo $H|sudo -S grep -i 'geth\[\|lighthouse'   $s1 2>$s3; }                                                                                    # get eth      syslog lines
function fs3 { echo $H|sudo -S grep -v 'geth\[\|lighthouse'   $s1 2>$s3; }                                                                                    # get sys      syslog lines
function fs4 { if [[ $1 ]];then grep "$1" $2 2>$s3;else cat $2 2>$s3;fi|if [[ ${3:-0} -le 0 ]];then cat;else tail -n${3:-0};fi; }                             # get filtered lines  from log
function fs5 { sed "s%$1 *\([0-9]*\).*%\1%" $2 2>$s3; }                                                                                                       # get list of numbers from log
function fs6 { fs0 $1 $2   |fs5 .*$1; }                                                                                                                       # get peers    syslog lines
function fs7 { fs4 $1 $2 $3|fs5   $1; }                                                                                                                       # get number          from log
function pt0 { until [[ $# -le 1 || $1 =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]];do shift;done;echo $1; }                                                            # yyyy-mm-dd test
function pt1 { until [[ $# -le 1 || $1 =~ ^[0-9]{2}:[0-9]{2}$          ]];do shift;done;echo $1; }                                                            # hh:mm      test
function pt2 { until [[ $# -le 1 || $1 =~ ^[0-9]+$                     ]];do shift;done;echo $1; }                                                            # integer    test
function rd0 { $w1 $1 2>$s3|grep "${2:-inactive\|failed}"                                   ; }                                                               # service status word test
function rd1 { $w1 $1 2>$s3|grep "${2:-Active:}"|sed "s%.*${2:-Active:} *\(${3:-.}*\).*%\1%"; }                                                               # service status word with data extraction
function rd2 { nn=$2;cp $p8/$1.service $p0/$1.sav;sed "s%peers *[0-9]*%peers $2%" $p0/$1.sav > $p8/$1.service; }                                              # change service configuration file
function rd3 { resolvectl query smtp.gmail.com &>$s3;sex "$w2 $1";dmr                                        ; }                                              # DNS force smpt stop/load service
function rd4 { local n=$(($2+$nn));[[ $2 -ne 0 && $n -ge $3 && $n -le $4 ]] && rd2 $1 $n;rd3 $1              ; }                                              # change/stop/load service process
function rd5 { cex "$w2 $dnsd";sex "$w2 systemd-resolved";cex "$w3 $dnsd";sex "$w3 systemd-resolved"; }                                                       # DNS stop/start
function cex { echo -e "${i}${1^^}${f}";echo $H|sudo -S $1 2>$s3; }                                                                                           # superuser-command (visible)
function sex {                          echo $H|sudo -S $1 &>$s3; }                                                                                           # superuser-command (silent)
function dmr { sex "$w0 daemon-reload"                       ; }                                                                                              # daemon-reload
function jsh { cex "journalctl --no-hostname --no-full -f $1"; }                                                                                              # my journal   format
function dts { read d0 d1 <<< ${1:-$(date '+%Y-%m-%d %H:%M')};dt="$d0 $d1"          ; }                                                                       # my logs date format
function sst { dts;echo "$1 $(printf '%6s' $(rd1 $2 Memory:)) $dt status: $(rd1 $2)"; }                                                                       # GETH/BEAC/VALI status
function dnn { echo "$dt $(printf 'node%02i:' $nn) $(printf '%2i' $nr)"             ; }                                                                       # date/nodes info

i="\n\e[5m"
f="\e[25m\n"

s0='/usr/local/bin'
s1='/var/log/syslog'
s3='/dev/null'
p0='/home/eth'
p1='/etc/prometheus'
p8='/etc/systemd/system'
p5="$p0/geth.log"
p2="$p0/beacon.log"
p3="$p0/bmedias.log"
p7="$p0/barqivo.log"
p4="$p0/beacon.restart"

w0='systemctl'
w1="$w0 status"
w2="$w0 stop"
w3="$w0 start"
w4="$w0 enable"
w5="$w0 disable"

meeu="$(whoami)"
cunm="$(uname -n)"
cust="$(uname -n|cut -c1-3)"
ethg='eth-geth'
ethb='eth-beacon'
ethv='eth-validator'
ethp='prometheus'
ethn='prometheus-node-exporter'
ethf='grafana-server'
plex='plexmediaserver'
trrt='transmission-daemon'
dnsd='named'
zip1='192.168.8.25'
zip2='192.168.8.28'
zip3='192.168.8.31'
znm1='hrv-zotac1'
znm2='hrv-zotac2'
znm3='hrv-zotac3'
vip1='207.180.214.8'
vip2='173.249.42.190'
vip3='164.68.107.45'
vnm1='vmi471826.contaboserver.net'
vnm2='vmi506976.contaboserver.net'
vnm3='vmi469069.contaboserver.net'
dtdi="/var/lib/lighthouse"
becn="$dtdi/beacon"
vldt="$dtdi/validators"
bpid=$(rd1 $ethb PID: [0-9])

rblk=22238623
ratt=00019000
pmis=00010000
pmat=00018800
pmah=00004500
pdly=00000500
decp=1000000000

hors=24
rate=4000
if [[ $cust = hrv ]];then cgth=$zip1;else cgth=$vip1;fi
[[ $rate -eq 0 ]] && rate=$(curl -sX GET 'https://pro-api.coinmarketcap.com/v1/cryptocurrency/quotes/latest?symbol=ETH&convert=EUR&CMC_PRO_API_KEY=3ae5f3df-bd71-489d-a9dd-b626995fba31'|sed 's%.*price.:\([0-9]*\.[0-9]*\).*%\1%')
