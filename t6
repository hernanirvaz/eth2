#!/bin/bash

source /home/eth/eth2/t1

function nu0 { if [ ${1:-0} -eq $1 ] 2>${p[3]};then echo $1;else echo 0;fi; }                                                                                 # get numeric output (must use [ ] test)
function nu1 { echo "scale=$2;$1"|bc 2>${p[3]}; }                                                                                                             # get arbitrary precision calculations
function nu2 { if [[ $# -gt 0 ]];then nu5 "sqrt(((0$(printf '+%i^2' $@))-(0$(printf '+%i' $@))^2/$#)/$#)" 1000 5;else echo 0;fi; }                            # get standard deviation list of numbers
function nu3 { if [[ $# -gt 0 ]];then nu5 "(0$(printf '+%s' $@))/$#"                                            ;else echo 0;fi; }                            # get average            list of numbers
function nu4 { if [[ $5 -gt 0 ]];then nu5 "($1*$pmis+$2*$pmat+$3*$pmah+$4*$pdly)/$5*$rate/$decp"          1000 5;else echo 0;fi; }                            # get penalty
function nu5 { printf ${4:-%.0f} $(nu1 $1*${2:-1} ${3:-1}); }                                                                                                 # format arbitrary precision calculations
function nu6 { if [[ $# -gt 0 ]];then nu5 "(0$(printf '+%s' $@))/$#" 1 3 %.2f                                   ;else echo 0;fi; }                            # get average (scale 2)  list of numbers
function fs0 { pex "grep ${3:-lighthouse}.*$1 ${p[1]}"|if [[ ${2:-0} -le 0 ]];then cat;else tail -n${2:-0};fi; }                                              # get specific syslog lines
function fs1 { pex "grep    ${p[104]} ${p[1]}"; }                                                                                                             # get eth      syslog lines
function fs2 { pex "grep -v ${p[104]} ${p[1]}"; }                                                                                                             # get sys      syslog lines
function fs3 { fs2|tail -n300|grep Core.*temperature; }                                                                                                       # get tail cpu syslog lines
function fs4 { fs0 $1|lg1 .*$1; }                                                                                                                             # get peers    syslog lines
function fs5 { if [[ $1 ]];then grep -i "[a-z][a-z][a-z]  *[0-9]* $1";else grep -iv '[ =]INFO ';fi; }                                                         # filter el/cl/mev log lines
function fs6 { if [[ $1 ]];then grep -i "[a-z][a-z][a-z]  *[0-9]* $1";else grep -i  'error'    ;fi; }                                                         # filter system    log lines
function lg0 { grep $1 $2 2>${p[3]}|tail -n1|lg1 $1; }                                                                                                        # get last  number   from log
function lg1 { sed "s%$1 *\([0-9]*\).*%\1%" $2 2>${p[3]}; }                                                                                                   # get list  numbers  from log
function lg2 { local e='Delayed.head.block';if [[ ${1:-0} -gt 0 ]];then l4=$(rl2 $e|grep -v None|tail -n${1:-0});else l4=$(rl2 $e|grep -v None);fi; }         # set cc specific log lines
function lg3 { local e='Imported'          ;if [[ ${1:-0} -gt 0 ]];then l4=$(rl3 $e|tail -n${1:-0});else l4=$(rl3 $e);fi; }                                   # set ec specific log lines
function lg4 { if [[ $l4 ]];then echo "$l4"|sed -n "$1${p[105]}";echo "$l4"|sed -n "$1${p[106]}";echo "$l4"|sed -n "$1${p[107]}";else echo 1;fi; }            # get s/ms delays from log lines
function lg5 { if [[ $l4 ]];then echo "$l4"|sed -n "$1${p[108]}";echo "$l4"|sed -n "$1${p[109]}";echo "$l4"|sed -n "$1${p[110]}";else echo 1;fi; }            # get s/ms delays from log lines
function lg6 { lg2 $1;b1=$(nu3 $(lg4 's%.*imported_delay: '));b5=$(nu3 $(lg4 's%.*observed_delay: ')); }                                                      # set Imported/observed delays
function rl0 { local n=${1:-0};((n<0)) && rl0    $((n+1));local e=${p[16]}/logs/beacon.log   ;((n>0)) && e="$e.$n";echo $H|sudo -S cat $e     2>${p[3]}; }    # get cc intern lines
function rl1 { local n=${2:-0};((n<7)) && rl1 $1 $((n+1));local e=${p[1]}                    ;((n>0)) && e="$e.$n";echo $H|sudo -S grep $1 $e 2>${p[3]}; }    # get all eth  syslog lines
function rl2 { local n=${2:-0};((n<1)) && rl2 $1 $((n+1));local e=${p[16]}/logs/beacon.log   ;((n>0)) && e="$e.$n";echo $H|sudo -S grep $1 $e 2>${p[3]}; }    # get specific cc intern log lines
function rl3 { local n=${2:-0};((n<0)) && rl3 $1 $((n+1));local e=${p[1]}                    ;((n>0)) && e="$e.$n";echo $H|sudo -S grep $1 $e 2>${p[3]}; }    # get ec specific log lines
function rl4 { local n=${1:-0};((n<0)) && rl4    $((n+1));local e=${p[17]}/logs/validator.log;((n>0)) && e="$e.$n";echo $H|sudo -S cat $e     2>${p[3]}; }    # get cc intern lines
function pt0 { until [[ $# -le 1 || $1 =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]];do shift;done;echo $1; }                                                            # yyyy-mm-dd test
function pt1 { until [[ $# -le 1 || $1 =~ ^[0-9]{2}:[0-9]{2}$          ]];do shift;done;echo $1; }                                                            # hh:mm      test
function pt2 { until [[ $# -le 1 || $1 =~ ^[0-9]+$                     ]];do shift;done;echo $1; }                                                            # integer    test
function pt3 { until [[ $# -le 1 || $1 =~ ^[a-z]+$                     ]];do shift;done;echo $1; }                                                            # string     test
function jsh { cex "journalctl --no-hostname --no-full -f $1"; }                                                                                              # my journal   format
function spc { nn=$2;cp ${p[4]}/$1.service ${p[9]}/$1.sav;sed "s%peers\([ =]*\)[0-9]*%peers\1$2%" ${p[9]}/$1.sav > ${p[4]}/$1.service; }                      # service configuration change
function snp { local n=$(($2+nn));(($2!=0&&n>=$3&&n<=$4)) && spc $1 $n;sex "${p[62]} $1";sex "${p[60]} daemon-reload"; }                                      # service peers change/stop/reload
function srt { [[ -f ${p[5]} ]]; }                                                                                                                            # system needs reboot test
function sra { if srt;then echo $(($(date +%s)-$(date -r ${p[5]} +%s)));else echo 0;fi }                                                                      # system reboot age (secounds)
function sot { [[ $(sra) -ge $((60*60*${1:-24})) ]]; }                                                                                                        # 24 hours old system reboot test
function stt { [[ $d1 =~ 23:5[89] ]]; }                                                                                                                       # time test
function sci { ip a|sed -n 's% *inet  *192.168.8.\([0-9]*\).*%\1%p'; }                                                                                        # get ip/24
function sni { case $1 in 25) echo $znm1;;28) echo $znm2;;31) echo $znm3;;34) echo $znm4;;esac; }                                                             # get name from ip/24
function sst { ${p[61]} $1 2>${p[3]}|grep "${2:-inactive\|failed}"; }                                                                                         # systemctl status word test
function ss1 { ${p[61]} $1 2>${p[3]}|sed -n "s%.*$2[ =]\(${3:-.}*\).*%\1%p"; }                                                                                # systemctl status 1 extraction
function ss2 { ${p[61]} $1 2>${p[3]}|sed -n "s%.*Active: *\(.*\)%\1%p"|sed "s% *since.*;%%"|cut -c1-40; }                                                     # systemctl status 2 extraction
function dmr { sex "${p[60]} daemon-reload"; }                                                                                                                # daemon-reload
function dts { read d0 d1 <<< ${1:-$(date '+%F %H:%M')};dt="$d0 $d1"          ; }                                                                             # set date/time vars
function dtl { read dt dt dt d0 d1 dt <<< $(bff|tail -n1);dt="$d0 $d1"        ; }                                                                             # set date/time vars with last beacon log
function bnn { nr=${@:$#};nm=$(printf '%i\n' $@|sort -n|head -n1);nd=$(nu2 $@); }                                                                             # set cur/min/std peers vars
function dnn { echo "$dt $(printf 'node%02i:' $nn) $(printf '%2i' $nr)"       ; }                                                                             # get date/nodes info
function tsy { if [[ $(echo $@|grep false) ]];then echo SYC;else echo NSY;fi  ; }                                                                             # get el SYN/NSY text
function era { tail -n$ehrs $1 2>${p[3]}|cut -d' ' -f1|sort -u|wc -l; }                                                                                       # get el restart activity
function eh0 { [[ -f $1 ]] || return;tail -n${2:-$ehrs} $1; }                                                                                                 # el historic report
function eb0 { e0=$(fs0 $2 0 $3|wc -l);ok=OK;[[ $(echo $@|grep false) && ($e0 -eq $(lg0 .*sgs: $1) || $nr -lt $(eb1)) && $(era $1) -eq 1 ]] && ok=BK; }       # Imported new chain segment & OK/BK
function eb1 { echo $(((nn*100-nn*30)/100)); }                                                                                                                # get current peers-30%
function ero { dts;[[ -f $2 ]] && swn "$(printf 'R%03i' $1) ${3:-RS} SRV $(dnn)" >> $2; }                                                                     # log restart info
function sng { ${p[9]}/eth2/t7 2>${p[3]}; }                                                                                                                   # get next gap without validator tasks
function stg { echo $(date -d@${1:-0} +%M:%S|tr -d :)t$(date -d@$(($(date +%s)+${1:-0})) +%H:%M:%S|tr -d :); }                                                # get end file sleep tag
function sf1 { echo ${1:-$(date +%H:%M:%S)}; }                                                                                                                # get filterd t7 parm 1
function sf2 { echo ${2:-24}; }                                                                                                                               # get filterd t7 parm 2
function smn { local g=${1:-24};echo $((g>360?360:g<24?24:g)); }                                                                                              # get max/min seconds to future (12x30/24)
function sfn { local g=$(($(bss $1)-$(date +%s)));echo $((g>3?g:3)); }                                                                                        # get min seconds to future
function spt { [[ $(date +%s) -ge $(bss $1 6) ]]; }                                                                                                           # ideal position test (based on time)
function ssf { [[ $1 -gt 0 ]] || return;local f=$2.s$(stg $1);touch $f;sleep $1s;rm -f $f; }                                                                  # sleep with file info
# slots = secounds 12,24,36,48,60,72,84,96,108,120,132,144,156,168
function ssw { while :;do local t=$(sng);if [[ $(sf2 $t) -le ${1:-36} || 24 -ge $(sfn $t) ]];then ssf $(smn $(sfn $t)) $2;else break;fi;done; }               # sleep while small (gap or remaining) time
function sso {
  [[ $(sst $2 disabled) || ! $(sst $2 $2) ]] && return;dts;local e="$1 $(printf '%6s' $(ss1 $2 Memory:)) $dt status: $(printf '%-40s' "$(ss2 $2)")"           # memory & status
  [[ $1 = GETH ]] && bnn $(fs0 peercount= 0 ${p[47]} |lg1 .*peercount=) $(nu0 $(gcl net.peerCount))                                                           # set min peers
  [[ $1 = GETH ]] && e="$e $(printf 'el:p%02i:m%02i p2p:%5i' $nr $nm $(ss1 $2 port     [0-9]))$(gb1 synced $(gcl eth.syncing)) i2:$(gdi)"                     # el peers/port tag
  [[ $1 = BESU ]] && bnn $(fs0 Peers:     0 ${p[102]}|lg1 .*Peers:)     $(up0 $(ucl net_peerCount))                                                           # set min peers
  [[ $1 = BESU ]] && e="$e $(printf 'el:p%02i:m%02i p2p:%5i' $nr $nm $(ss1 $2 p2p-port [0-9]))$(ub1 synced $(ucl eth_syncing)) i2:$(udi)"                     # el peers/port tag
  [[ $1 = BEAC ]] && bnn $(fs4 peers:) $(bpc $(bcl peer_count))                                                                                               # set min peers
  [[ $1 = BEAC ]] && e="$e $(printf 'cl:p%02i:m%02i p2p:%5i' $nr $nm $(ss1 $2 port [0-9]))$(bb1 $(bcl syncing))"                                              # cl peers/port tag
  [[ $1 = BEAC ]] && e="$e el:http $(ss1 $2 execution-endpoint '[^ ]'|sed -n ${p[91]})"                                                                       # el http & delays rate
  [[ $1 = VALI ]] && { dtl;bo5;e="$e vl:c$(printf '%02i' $b2):m$(printf '%02i' $b3) cc:http $(ss1 $2 nodes '[^ ]'|sed -n ${p[91]})"; };swn "$e"               # set homologous/avg & cl http
}
# el control commands
function grs {                                                                                                                                                # el gap restart
  [[ $(ls ${p[97]}.* 2>${p[3]}) ]] && return;local n=${3:-36};[[ $2 = RB ]] && n=84;ssw $n ${p[97]}
  local t=$(sng);local f=${p[97]}.i$(stg);touch $f;local n=0;paf;while [[ -f $f ]];do ((n+=$(sfn $t)));ssf $(sfn $t) ${p[97]}
  if spt $t;then rm $f;gv0;[[ $2 = RB ]] && gq0;snp ${p[70]} $1 10 50                                                                                         # change peers/stop el
    if [[ $2 = RB ]];then ero $n ${p[13]} $2;sex reboot;else sex "$(pjw 63 70)";ssf 20 ${p[97]};gq0;ero $n ${p[13]} $2;fi                                     # reboot/start el
  fi;done;rm -f $f
}
function gdi { lg3 $1;printf '%i' $(nu3 $(lg5 's%.*elapsed=')); }                                                                                             # get delay imported
function gcl { ${p[8]}/geth attach --exec $1 "http://$ciec:8545"      2>${p[3]}; }                                                                            # exec RPC HTTP
function gi0 { echo $@|sed -n 's%.*highestBlock: *\([0-9]*\).*%\1%ip' 2>${p[3]}; }                                                                            # get el highest block
function gc0 { echo $@|sed -n 's%.*currentBlock: *\([0-9]*\).*%\1%ip' 2>${p[3]}; }                                                                            # get el current block
function gv0 { nn=$(nu0 $(ss1 ${p[70]} maxpeers [0-9])); }                                                                                                    # set configured peers
function gq0 { nr=$(nu0 $(gcl net.peerCount))          ; }                                                                                                    # set el current peers
function gb1 { if [[ $(echo $@|grep false) ]];then [[ $1 ]] && printf " $1";else printf " syncing: %6i" $(($(gi0 $@)-$(gc0 $@)));fi; }                        # get el syncing blocks remaining
function gl0 {                                                                                                                                                # el report
  dts;ok=OK
  if [[ $(sst ${p[70]} running) ]];then local e=$(gcl eth.syncing);gv0;gq0;eb0 ${p[13]} Imported ${p[47]} $e
    m="GETH $ok $(tsy $e) $(dnn) sgs: $(printf '%4i' $e0)$(gb1 '' $e) i2: $(gdi 99)"                                                                          # OK SYC/NSY (dnn) sgs: 5 blocks: 8
  else
    m="GSRV NOT ON $dt"
  fi
}
function urs {                                                                                                                                                # el gap restart
  [[ $(ls ${p[98]}.* 2>${p[3]}) ]] && return;local n=${3:-36};[[ $2 = RB ]] && n=84;ssw $n ${p[98]}
  local t=$(sng);local f=${p[98]}.i$(stg);touch $f;local n=0;paf;while [[ -f $f ]];do ((n+=$(sfn $t)));ssf $(sfn $t) ${p[98]}
  if spt $t;then rm $f;uv0;[[ $2 = RB ]] && uq0;snp ${p[87]} $1 10 50                                                                                         # change peers/stop el
    if [[ $2 = RB ]];then ero $n ${p[89]} $2;sex reboot;else sex "$(pjw 63 87)";ssf 20 ${p[98]};uq0;ero $n ${p[89]} $2;fi                                     # reboot/start el
  fi;done;rm -f $f
}
function udi { lg3 $1;printf '%i' $(nu3 $(lg5 's%.* in ')); }                                                                                                 # get delay imported
function ucl { curl -sX POST --data "{\"jsonrpc\":\"2.0\",\"method\":\"$1\",\"params\":[],\"id\":51}" "http://$ciec:8545" 2>${p[3]}; }                        # exec RPC HTTP
function ui0 { echo $((16#$(echo $@|sed -n 's%.*highestBlock" *: *"0x\([^"]*\)".*%\1%ip'))) 2>${p[3]}; }                                                      # get el highest block
function uc0 { echo $((16#$(echo $@|sed -n 's%.*currentBlock" *: *"0x\([^"]*\)".*%\1%ip'))) 2>${p[3]}; }                                                      # get el current block
function up0 { nu0  $((16#$(echo $@|sed -n 's%.*result" *: *"0x\([^"]*\)".*%\1%ip'      ))) 2>${p[3]}; }                                                      # get el result
function uv0 { nn=$(nu0 $(ss1 ${p[87]} max-peers [0-9])); }                                                                                                   # set configured peers
function uq0 { nr=$(nu0 $(up0 $(ucl net_peerCount)))                         ; }                                                                              # set el current peers
function ub1 { if [[ $(echo $@|grep false) ]];then [[ $1 ]] && printf " $1";else printf " syncing: %6i" $(($(ui0 $@)-$(uc0 $@)));fi; }                        # get el syncing blocks remaining
function ul0 {                                                                                                                                                # el report
  dts;ok=OK
  if [[ $(sst ${p[87]} running) ]];then local e=$(ucl eth_syncing);uv0;uq0;eb0 ${p[89]} Imported ${p[102]} $e
    m="BESU $ok $(tsy $e) $(dnn) sgs: $(printf '%4i' $e0)$(ub1 '' $e) i2: $(udi 99)"                                                                          # OK SYC/NSY (dnn) sgs: 5 blocks: 8
  else
    m="BSRV NOT ON $dt"
  fi
}
# cc control commands
function bcl { curl -sX GET "http://$cicc:5052/eth/v1/node/$1" -H "accept: application/json" 2>${p[3]}; }                                                     # exec RPC HTTP
function bsd { nu0 $(echo $@|sed -n 's%.*"sync_distance" *: *"\([^"]*\)".*%\1%ip'); }                                                                         # get cl syncing distance
function bpc { nu0 $(echo $@|sed -n 's%.*"connected" *: *"\([^"]*\)".*%\1%ip'    ); }                                                                         # get cl peers connected
function bb1 { if [[ $(echo $@|grep is_syncing\":false) ]];then printf " synced";else printf " syncing: %6i" $(bsd $@);fi; }                                  # get cl syncing distance remaining
function bz0 { echo $((10*(5*zk+2*zz+zx+zw)))                                          ; }                                                                    # get numerator paid errors
function bw0 { echo $((10*z1))                                                         ; }                                                                    # get numerator processed blocks
function bf0 { echo $((90*z3))                                                         ; }                                                                    # get numerator general errors
function bi0 { echo $((nd+zk*300+zz*20+zx))                                            ; }                                                                    # get delete day idx
function bu0 { echo $(((z5>400?$(bz0)/z5:0)+(z2>300?$(bw0)/z2:0)+(z4>999?$(bf0)/z4:0))); }                                                                    # get restart idx
function bv0 { nn=$(nu0 $(ss1 ${p[71]} target-peers [0-9])); }                                                                                                # get configured peers
function bb0 { l0=$(fs0 $bpid] 3600);bl1;bl2;[[ (1 -eq $(bl6 $chrs) && $(bu0) -ge 1) || (1 -eq $(bl6 5) && $(bu0) -ge 5) ]] && ok=BK; }                       # set ok (OK/BK)
function bbl { cat ${p[11]} 2>${p[3]}|wc -l; }                                                                                                                # get cc       line count
function bml { cat ${p[12]} 2>${p[3]}|wc -l; }                                                                                                                # get cc-daily line count
function bfl { grep "BEAC.*$1"    ; }                                                                                                                         # filter cc lines
function bff { [[ -f ${p[11]} ]] || return;grep "BEAC.*$1" ${p[11]}; }                                                                                        # filter cc log
function bl0 { dts;ok=OK;if [[ $(sst ${p[71]} running) ]];then bl3;bv0;bnn $(fs4 peers:);bb0;blo;else m="BSRV NOT ON $dt";fi; }                               # cc report
function bl1 {                                                                                                                                                # set restart idx vars
  z1=${1:-$(echo "$l0"|grep 'rocessed block'|wc -l)};z2=${2:-$(echo "$l0"|grep 'block received'|wc -l)};z3=${3:-$(echo "$l0"|grep -v ' INFO ' |wc -l)}        # set processed/received blocks,error lines
  z4=${4:-$(echo "$l0"|grep    ' INFO '     |wc -l)};z5=${5:-$(bl7 success)};ok=${6:-OK}                                                                      # set info lines,success/had activities
}
function bl2 { zk=${1:-$(bl7 missing)};zz=${2:-$(bl7 target)};zx=${3:-$(bl7 head)};zw=${4:-$(bl7 had)}; }                                                     # set missing/target/head activities
function bl3 { b0=${1:-$(fs0 Valid.block|wc -l)};if [[ $2$3 ]];then b1=$2;b5=$3;else lg6 2;fi; }                                                              # set pub-blocks & imported/observed delays
function bl5 { sed 's%.*validators: *\[\(.*\)\].*%\1%'|wc -w; }                                                                                               # get number of validators
function bl6 { tail -n$1 ${p[11]} 2>${p[3]}|cut -d' ' -f1|sort -u|wc -l; }                                                                                    # get cc restart activity
function bl7 { fs0 attestation.s.*$1|bl5; }                                                                                                                   # get number of paid activities
function bii { printf '%4i %4i %4i' $b1 $b5 $(((4*b1+b5)/5)); }                                                                                               # shw imported/observed data
#    0  1   2          3     4       5  6   7    8    9  10   11  12 13  14 15 16  17 18 19   20  21 22   23   24  25   26   27   28
# BEAC OK   0 2022-11-21 23:46 node50: 55 rp: 3728 2630 ab: 4906 1350 0 er:  0 10 103 12  0  547   0  3 3597  270 io:  370 4336 1163
function blo {
  m="BEAC $ok $(printf '%3i' $(bu0)) $(dnn) rp: $(nu5 "($z5*$ratt+$b0*$rblk)*$rate/$decp" 10 2 %4.0f)"
  m="$m $(printf '%4i' $(nu4 $zk $zz $zx $zw 1)) ab: $(printf '%4i' $z5) $(printf '%4i' $(bz0)) $(printf '%1i' $b0)"
  m="$m er: $(printf '%2i' $zk) $(printf '%2i' $zz) $(printf '%3i' $zx) $(printf '%2i' $zw) $(printf '%2i' $z1) $(printf '%4i' $z2)"
  m="$m $(printf '%3i' $(bw0)) $(printf '%2i' $z3) $(printf '%4i' $z4) $(printf '%4i' $(bf0)) io: $(bii)"
}
function bio { lg6 $1;dts;m="BEIO $(printf '%6i' $1) $dt io: $(bii)"; }                                                                                       # shw imported/observed delays
function bcc { if bct       ;then echo c;else echo _;fi; }                                                                                                    # get change configured peers char
function bdc { if bht && bst;then echo d;else echo _;fi; }                                                                                                    # get delete cc log day       char
function bmi { zk=0;zz=0;zx=0;unset v;v[1]=0;unset k;k[0]=0;unset z;z[0]=0;unset x;x[0]=0;unset w;w[0]=0;unset c;c[0]=0;unset a;a[0]=0;bm6; }                 # ini err/cnt/avg penalty arrays
function bm0 {                                                                                                                                                # cc-daily report
  [[ -f ${p[11]} ]] || return;bmi;b4=0;dts;bv0;bnn $(fs4 peers:);bl2;[[ -f ${p[14]} ]] && bm4;lg6                                                             # set vars/arrays
  l3=$(tail -n$(($(bbl)-v[1])) ${p[11]} 2>${p[3]}|bfl);[[ $l3 ]] && bm1;bm2;bo4;bm5 ${a[$nn]};b7="peers$(bdc)$(bcc)io:"                                       # add cc lines & homologous/avg position
}
function bm1 {
  local g=${1:-$bpri};l1=$(echo "$l3"|sed -nEe "s%.+node$g:.+er: +([0-9]+) +([0-9]+) +([0-9]+) +([0-9]+).+%\1\t\2\t\3\t\4%p")                                 # set paid errors for current array
  [[ $l1 ]] && { bkm $g;bzm $g;bxm $g;bwm $g;bcm $g; };((g<bprf)) && bm1 $((g+bprs))                                                                          # recursively sum paid err arrays
}
function bm2 { k[0]=$(($(bnk)));z[0]=$(($(bnz)));x[0]=$(($(bnx)));w[0]=$(($(bnw)));c[0]=$(($(bnc)));a[0]=$(bm3 0);bm7; }                                      # tot err/cnt/penalty arrays
function bm3 { nu4 ${k[$1]} ${z[$1]} ${x[$1]} ${w[$1]} ${c[$1]} ; }                                                                                           # get penalty from paid err arrays
function bm4 { read -a v <<< $(tail -n1 ${p[14]});bmk;bmz;bmx;bmw;bmc; }                                                                                      # set err/cnt penalty arrays from barqivo
function bm5 { local g=${2:-$bpri};local n=$1;if ((a[g]<n));then b4=$((g-nn));n=${a[$g]};fi;((g<bprf)) && bm5 $n $((g+bprs)); }                               # set recursively peer change <- min penalties
function bm6 { local g=${1:-$bpri};k[$g]=0;z[$g]=0;x[$g]=0;w[$g]=0;c[$g]=0;a[$g]=0         ;((g<bprf)) && bm6    $((g+bprs)); }                               # ini recursively penalty arrays
function bm7 { local g=${1:-$bpri};a[$g]=$(bm3 $g)                                         ;((g<bprf)) && bm7    $((g+bprs)); }                               # avg recursively penalty arrays
function bcm { local g=${1:-$bpri};((c[g]+=$(echo "$l1"|wc  -l)                       )); }                                                                   # sum               cnt array
function bkm { local g=${1:-$bpri};((k[g]+=$((0$(printf '+%i' $(echo "$l1"|cut -f1)))))); }                                                                   # sum missing       err array
function bzm { local g=${1:-$bpri};((z[g]+=$((0$(printf '+%i' $(echo "$l1"|cut -f2)))))); }                                                                   # sum failed target err array
function bxm { local g=${1:-$bpri};((x[g]+=$((0$(printf '+%i' $(echo "$l1"|cut -f3)))))); }                                                                   # sum failed head   err array
function bwm { local g=${1:-$bpri};((w[g]+=$((0$(printf '+%i' $(echo "$l1"|cut -f4)))))); }                                                                   # sum delay         err array
function bmc { local g=${1:-$bpri};local n=${2:-5 };c[$g]=${v[$n]};((g<bprf)) && bmc $((g+bprs)) $((n+1)); }                                                  # set recursively               cnt array
function bmk { local g=${1:-$bpri};local n=${2:-13};k[$g]=${v[$n]};((g<bprf)) && bmk $((g+bprs)) $((n+1)); }                                                  # set recursively missing       err array
function bmz { local g=${1:-$bpri};local n=${2:-21};z[$g]=${v[$n]};((g<bprf)) && bmz $((g+bprs)) $((n+1)); }                                                  # set recursively failed target err array
function bmx { local g=${1:-$bpri};local n=${2:-29};x[$g]=${v[$n]};((g<bprf)) && bmx $((g+bprs)) $((n+1)); }                                                  # set recursively failed head   err array
function bmw { local g=${1:-$bpri};local n=${2:-37};w[$g]=${v[$n]};((g<bprf)) && bmw $((g+bprs)) $((n+1)); }                                                  # set recursively delay         err array
function bma { local g=${2:-$bpri};if ((g<=bprf));then bma "$1 $(printf '%4i' ${a[$g]})" $((g+bprs));else echo "$1";fi; }                                     # sum recursively penalty       avg array
function bnc { local g=${3:-$bpri};if ((g<=bprf));then bnc "${1:-0}${2:-+}${c[$g]}" "$2" $((g+bprs));else echo "$1";fi; }                                     # sum recursively               cnt array
function bnk { local g=${3:-$bpri};if ((g<=bprf));then bnk "${1:-0}${2:-+}${k[$g]}" "$2" $((g+bprs));else echo "$1";fi; }                                     # sum recursively missing       err array
function bnz { local g=${3:-$bpri};if ((g<=bprf));then bnz "${1:-0}${2:-+}${z[$g]}" "$2" $((g+bprs));else echo "$1";fi; }                                     # sum recursively failed target err array
function bnx { local g=${3:-$bpri};if ((g<=bprf));then bnx "${1:-0}${2:-+}${x[$g]}" "$2" $((g+bprs));else echo "$1";fi; }                                     # sum recursively failed head   err array
function bnw { local g=${3:-$bpri};if ((g<=bprf));then bnw "${1:-0}${2:-+}${w[$g]}" "$2" $((g+bprs));else echo "$1";fi; }                                     # sum recursively delay         err array
function bm8 { m="$m $b7 $(printf '%4i %3i' $(bi0) $b4) $(bii)"; }
#  0    1   2          3     4       5  6   7    8    9   10   11   12   13   14          15   16         17   18  19   20   21   22
# BM    2   2 2022-11-21 23:46 node50: 55 mp:    0    0    0 1101    0    0    0 all_median: 1101 peers__io:  706 -30  470 5015 1379
function bmo { m="BM $(printf '%4i' $b2) $(printf '%3i' $b3) $(dnn) $(bma 'mp:') all_median: $(printf '%4i' ${a[0]})";bm8; }
#  0    1   2          3     4       5  6        7    8    9   10         11   12  13   14   15   16
# BM    2   2 2022-11-21 23:49 node50: 55 penalty: 1101 avg: 1101 peers__io:  707 -30  470 5015 1379
function bms { m="BM $(printf '%4i' $b2) $(printf '%3i' $b3) $(dnn) penalty: $(printf '%4i' ${a[$nn]}) avg: $(printf '%4i' ${a[0]})";bm8; }
#    0   1          2     3    4 5 6 7 8 9 10 11   12 13 14 15 16 17 18 19   20 21 22 23 24 25 26 27   28 29 30 31 32 33 34 35   36 37 38 39 40 41 42 43
# BEAC 682 2022-03-16 11:03 cnt: 4 7 0 0 0 10 10 mis: 20 20 20 20 20 20 20 mat: 14 45 30 30 30 30 30 mah: 94 68 40 40 40 40 40 dly: 79 09 50 50 50 50 50
function bno { m="BEAC $(printf '%6i' $(bbl)) $dt $(bnc 'cnt:' ' ') $(bnk 'mis:' ' ') $(bnz 'mat:' ' ') $(bnx 'mah:' ' ') $(bnw 'dly:' ' ')"; }
function boi {
  unset v;read -a v <<< $(bff|tail -n1);local n=0;local t=${1:-00:00};[[ $t = 00:00 ]] && t=${v[4]};b6=0;l2=$(bff $t)                                         # set homologous lines
  while [[ ${b2:=0} -eq 0 && $n -lt 500 ]];do bo2 ${v[3]};((n+=1));v[3]=$(date -d "$n days ago $t" +%F);done                                                  # set homologous position
}
function bo0 { [[ -f ${p[11]} ]] || return;boi $(pt1 $@ 00:00);if [[ $(pt3 $@ s) = n ]];then b6=$b2;else b6=$(pt2 $@ 0);fi;bo6; }                             # homologous report
function bo1 { echo "$l2"|sort -k10n -k4r; }                                                                                                                  # get homologous cc lines sorted
function bo2 { b2=$(bo1|grep -n ${1:-$(date '+%F')}|cut -d: -f1); }                                                                                           # set homologous position
function bo3 { b3=$(nu3 ${b2:=0} $(lg1 BM ${p[12]})); }                                                                                                       # set homologous avg
function bo4 { [[ ${b2:=0} -eq 0 && -f ${p[11]} ]] && boi;bo3; }                                                                                              # set homologous position/avg
function bo5 { l2=$(bff $d1);bo2 $d0;bo3; }                                                                                                                   # set homologous position/avg
function bo6 { bo1|head -n$((b6>b2?b6:b2<5?5:b2))|tail -n$((b6>0?b6:b2>chrs?chrs:b2<5?5:b2)); }                                                               # homologous report
function bo7 { bo1|grep $(printf 'node%02i:' $1); }                                                                                                           # get homologous node lines sorted
function bon { [[ -f ${p[11]} ]] || return;bv0;nn=$(pt2 $1 $nn);l2=$(bff 23:58);bo7 $nn; }                                                                    # homologous nodes report
function boa { local g=${1:-$bpri};echo "BO$(printf '%5i' $(bo7 $g|wc -l)) $(printf '%3i' $g)";bo7 $g;((g<bprf)) && boa $((g+bprs)); }                        # recursively show homologous nodes report
function bh0 {
  [[ -f ${p[11]} ]] || return;tail -n${1:-$chrs} ${p[11]};[[ $1 ]] && return                                                                                  # last cc    report
  boi;swn "BO $(printf '%4i' $b2) $(printf '%3i' $(echo "$l2"|wc -l))$(printf '%63s')x5 x2  x1 x1";bo6                                                        # homologous report
  bl0;swn "BL $(printf '%8i' $(bbl))\n$m";bm0                                                                                                                 # current cc report
  bmo;swn "BM $(printf '%8i' $(bml))$(printf '%34s')i20  i30  i40  i50  i60  i70  i80\n$m"                                                                    # cc-daily/services/system report
}
function btr { if srt;then echo RB;else echo $1;fi; }                                                                                                         # get tag reboot
function bro { dts;bb0;bnn $(fs4 peers:);[[ -f ${p[11]} ]] && swn "$(printf 'R%03i' $1) ${2:-$ok} $(printf '%3i' $(bu0)) $(dnn)" >> ${p[11]}; }               # log restart info
function bss { echo $((${2:-0}+$(date -d$(sf1 $1) +%s))); }                                                                                                   # get sum secounds + time
function bsc { pex "grep lighthouse.$bpid].*INFO ${p[1]}"|tail -n99|grep Sync\ committee|wc -l; }                                                             # get # committee messages
# slots = secounds 12,24,36,48,60,72,84,96,108,120,132,144,156,168
function brs {                                                                                                                                                # cc/vc gap restart
  [[ $(ls ${p[15]}.* 2>${p[3]}) || $(bsc) -gt 0 ]] && return;ssf ${3:-0} ${p[15]};local n=${4:-60};[[ $2 = VC ]] && n=72;[[ $2 = RB ]] && n=84
  ssw $n ${p[15]};local t=$(sng);local f=${p[15]}.i$(stg);touch $f;local n=0;paf;while [[ -f $f ]];do ((n+=$(sfn $t)));ssf $(sfn $t) ${p[15]}
  if spt $t;then rm $f;bv0;snp ${p[71]} $1 $bpri $bprf                        ;[[ $2 = VC ]] && sex "$(pjw 62 73)"                                            # stop cc/conf change?/stop vc?
    if [[ $2 = RB ]];then bro $n $2;gps;ups;sex reboot;else sex "$(pjw 63 71)";[[ $2 = VC ]] && sex "$(pjw 63 73)";ssf 20 ${p[15]};bro $n $2;fi               # stop ec/reboot|start cc+vc
  fi;done;rm -f $f
}
function bsb {                                                                                                                                                # cc/vc gap stop
  [[ $(ls ${p[15]}.* 2>${p[3]}) || $(bsc) -gt 0 ]] && return;ssf ${3:-0} ${p[15]};local n=${4:-60};[[ $2 = VC ]] && n=72
  ssw $n ${p[15]};local t=$(sng);local f=${p[15]}.i$(stg);touch $f;local n=0;paf;while [[ -f $f ]];do ((n+=$(sfn $t)));ssf $(sfn $t) ${p[15]}
  if spt $t;then       bv0;snp ${p[71]} $1 $bpri $bprf                        ;[[ $2 = VC ]] && sex "$(pjw 62 73)";local rsp=sim;swn "START BN $rsp?"         # stop cc/vc/conf change
    [[ $rsp =~ na*o* ]] || sex "$(pjw 63 71)";if [[ $2 = VC ]];then swn "START VC $rsp?";[[ $rsp =~ na*o* ]] || sex "$(pjw 63 73)";fi                         # start cc+vc
    rm $f;ssf 20 ${p[15]};bro $n $2
  fi;done;rm -f $f
}
function irb { rm ${p[93]}.$1.hours 2>${p[3]};if sot $1;then gps;ups;bps;sex reboot;fi;if srt;then touch ${p[93]}.$1.hours;fi; }                              # reboot if system needs it
function brh { head -n${1:-0} ${p[11]}r; }                                                                                                                    # new cc head lines
function brl {                                                                                                                                                # recalculate cc logs
  [[ -f ${p[11]} ]] || return;rm -f ${p[11]}r
  unset v;while read -a v;do ok=${v[1]};dts ${v[3]}\ ${v[4]};nn=${v[5]:4:2};nr=${v[6]}                                                                        # uncalculated vars
    if [[ ${v[0]} = BEAC ]];then
      bl1 ${v[19]} ${v[20]} ${v[22]} ${v[23]} ${v[11]} ${v[1]};bl2 ${v[15]} ${v[16]} ${v[17]} ${v[18]};bl3 ${v[13]} ${v[26]} ${v[27]};blo                     # BEAC lines calculated output
    else
      if [[ ${v[0]} = BSRV ]];then
        m="${v[0]} ${v[1]} ${v[2]} $dt"                                                                                                                       # BSRV lines
      else
        m="${v[0]} $ok $(printf '%3i' ${v[2]}) $(dnn)"                                                                                                        # restart lines
      fi
    fi                                                                                           ;swn "$m" >> ${p[11]}r                                       # new cc output
  done <<< $(cat ${p[11]})
}
function brm {                                                                                                                                                # recalculate cc-daily logs
  [[ -f ${p[12]} ]] || return;rm -f ${p[12]}r;bmi;local d=0000-00-00;local l=0;local n=0;local h=0;local g=0;while read -a v;do
    d=${v[3]};h=$g;g=$(grep -n "$d 23:58" ${p[11]}r|cut -d: -f1);[[ ${g:=$h} -le $h ]] && continue;dts $d\ ${v[4]};nn=${v[5]:4:2}                             # get next cc log position
    nr=${v[6]};nd=${v[12]};l2=$(brh $g|bfl 23:58);bo2 $d;((l+=b2));((n+=1));b3=$(nu5 $l/$n)                                                                   # cur/avg homologous position
    l3=$(brh $g|tail -n$((g-h))|bfl);[[ $l3 ]] && bm1;bm2;b7=${v[11]};b1=${v[14]};b5=${v[15]};b4=${v[13]};bms;swn "$m" >> ${p[12]}r                           # sum err arrays & new cc-daily output
  done <<< $(cat ${p[12]})
}
function bsl {                                                                                                                                                # shrink cc      log using barqivo
  [[ -f ${p[11]} && -f ${p[14]} ]] || return;rm -f ${p[11]}s;tail -n$(($(cat ${p[11]}|wc -l)-$(tail -n1 ${p[14]}|cut -d' ' -f2))) ${p[11]} > ${p[11]}s        # new    cc      log output
  rm -f ${p[14]}s;head -n$(($(cat ${p[14]}|wc -l)-1)) ${p[14]} > ${p[14]}s;tail -n1 ${p[14]}|sed 's%BEAC [0-9]*%BEAC 0%' >> ${p[14]}s                         # new    barqivo log output
}
function bnt { [[ $b4 -ne 0 ]]; }                                                                                                                             # peers need change test
function bht { [[ $b2 -gt $b3 ]]; }                                                                                                                           # homologous/avg position test
function bst { [[ $(bi0) -ge 2500 ]]; }                                                                                                                       # peers standard deviation test
function btt { bnt && bht && ! bst; }                                                                                                                         # peers change global test
function bbt { [[ $(grep $d0 ${p[11]} 2>${p[3]}|wc -l) -gt 0 ]]; }                                                                                            # exists cc log day test
function bct { local n=$((nn-5));[[ $nm -ge $n && $(bl6 $chrs) -eq 1 ]] && ( btt || sot ); }                                                                  # change configured peers test
function bdw { cp $1 ${1}o;grep -v $2 ${1}o > $1;grep $2 ${1}o > ${1}d; }                                                                                     # work to delete cc log day
function bdl { local d=$(pt0 $1 sai);[[ -f ${p[11]} && $d != sai ]] || return;bdw ${p[11]} $d; }                                                              #         delete cc log day
function wst { echo $@|sed 's%[^: ]*: *%%g;s%inactive%off%;s%active%on%'; }                                                                                   # get ufw info
function cpf { local f='';until [[ $# -lt 1 ]];do f="$f, $(basename $1)";shift;done;echo $f; }                                                                # get list basenames
function tm0 {
  local d=$(pex "${p[114]} /dev/sda");local e=$(echo $(echo $d|jq -r "${p[112]}" 2>${p[3]}) $(echo $d|jq -r "${p[113]}" 2>${p[3]}))
  if [[ $cunm = $znm4 ]];then local d=$(pex "${p[114]} /dev/nvme0n1");local e=$(echo $e $(echo $d|jq -r "${p[112]}" 2>${p[3]}));fi;nu6 $e
}
function tmp {
  local l=0;local n=0;local g=0;local d=$(fs3|grep throttled|head -n1|sed "${p[95]}");local e=$(fs3|grep normal|tail -n1|sed "${p[95]}");local t=$(tm0)
  [[ $1$d$e || $(printf %.0f $t) -gt 40 ]] || return;for g in $(sensors 2>${p[3]}|sed -n "${p[94]}");do ((n+=1));l=$(nu1 $l$g 1);done                         # average temperature sensors
  [[ $d ]] && d="throttled: $d";[[ $e ]] && e="normal: $e";swn "TEMP $(nu5 $l/$((n==0?1:n)) 1 2 %5.1fC) $dt $(printf 'ssd: %.1fC %s %s' $t $d $e)"            # TEMP cpu/ssd info
}
function cpe {                                                                                                                                                # system status
  local e='NO';[[ $(${p[67]}|sed -n 's%.*synchronized: \([a-z]*\) *%\1%p') = yes ]] && e='OK';dts
  if [[ $(sst ${p[77]} masked) ]];then e="CNTP $e";m=$(ss2 ntp);else e="CSYS $e";m=$(ss2 ${p[77]});fi
  swn "$e $(printf '%3i' $(fs0 clock|wc -l)) $dt status: $m";[[ $1 = c ]] && return;tmp;[[ $1 = p ]] && return                                                # clock & temperature info
  if [[ $(cat ${p[6]} 2>${p[3]}) -eq 0 ]];then e=off;else e=on;fi;if [[ $(cat ${p[7]} 2>${p[3]}) -eq 1 ]];then d=off;else d=on;fi                             # usb/cpu current state
  m="INFO$(printf '%3i' $(fs2|grep usb|grep -i error|wc -l)) $(printf '%3i' $(fs3|wc -l)) $dt"                                                                # usb/cpu erros count
  m="$m usb $e, turbo $d, ufw $(wst $(pex 'ufw status'|grep Status:))"                                                                                        # usb/cpu/ufw info
  m="$m, uptime:$(uptime|sed 's%[0-9]*:[0-9]*:[0-9]*%%;s%[0-9]* users*,%%;s% average\([^,]*\).*%\1%;s%  *% %g')";swn "$m"                                     # uptime/load info
  local l=$(fs2|fs6|wc -l);local n=$(fs1|fs5|wc -l)
  local e=$(fs2|fs6|tail -n1|sed 's%.*hrv-zotac[0-9] *\(.*\)%\1%;s%  *% %g'                         |cut -c1-70)
  local d=$(fs1|fs5|tail -n1|sed 's%.*[0-9]*:[0-9]*:[0-9]*\.[0-9][0-9][0-9]]* *\(.*\)%\1%;s%  *% %g'|cut -c1-70)
  m="ERRO$(printf '%3i' $l) $(printf '%3i' $n) $dt";[[ $l -gt 0 ]] && m="$m system: $e";[[ $n -gt 0 ]] && m="$m ethrum: $d";(( l+n )) && swn "$m"             # sys/eth errors info
  m='';srt && m="$m, reboot $(($(sra)/60/60)) hours ago";[[ $(ls ${p[93]}.* 2>${p[3]}) ]] && m="$m$(cpf $(ls ${p[93]}.* 2>${p[3]}))"                          # reboot info
  [[ $(bsc) -gt 0 ]] && m="$m, committee on";[[ $m ]] && swn "INFO        $dt${m#*,}"                                                                         # committee info
  [[ $(swn $(/usr/lib/update-notifier/apt-check --human-readable)) -gt 0 ]] && { echo;apt list --upgradable; }
}
# Plex Media Server
function xop { pde 80 plex/nginx delete;pai 80 192.168.8.0/24 plex/nginx       ;ide 192.168.8.0/24 1900/udp plex/upnp       ; }
function xco { pde 80 plex/nginx       ;pai 80 192.168.8.0/24 plex/nginx delete;ide 192.168.8.0/24 1900/udp plex/upnp delete; }
function xe  { xop;sex 'ufw reload';cex "$(pjw 64 80)";cex "$(pjw 64 79)"; }                                                                                  # enable  plexmediaserver
function xa  { [[ $(sst ${p[80]}       ) ]] && cex "$(pjw 63 80)";[[ $(sst ${p[79]}       ) ]] && cex "$(pjw 63 79)"; }                                       # start   plexmediaserver
function xp  { [[ $(sst ${p[80]} loaded) ]] && cex "$(pjw 62 80)";[[ $(sst ${p[79]} loaded) ]] && cex "$(pjw 62 79)"; }                                       # stop    plexmediaserver
function xd  { cex "$(pjw 65 79)";cex "$(pjw 65 80)";xco;sex 'ufw reload'; }                                                                                  # disable plexmediaserver
# Transmission BitTorrent Daemon
function rop { pae 51413 torrent;pde 9091 torrent delete;pai 9091 192.168.8.0/24 torrent       ; }
function rco { pde 51413 torrent;pde 9091 torrent       ;pai 9091 192.168.8.0/24 torrent delete; }
function re  { rop;sex 'ufw reload';cex "$(pjw 64 72)"; }                                                                                                     # enable  transmission-daemon
function ra  { [[ $(sst ${p[72]}       ) ]] && cex "$(pjw 63 72)"; }                                                                                          # start   transmission-daemon
function rp  { [[ $(sst ${p[72]} loaded) ]] && cex "$(pjw 62 72)"; }                                                                                          # stop    transmission-daemon
function rd  { cex "$(pjw 65 72)";rco;sex 'ufw reload'; }                                                                                                     # disable transmission-daemon
# Bind9
function sop { pai 53 192.168.8.0/24 dns       ; }
function sco { pai 53 192.168.8.0/24 dns delete; }
function se  { sop;sex 'ufw reload';cex "$(pjw 64 78)"; }                                                                                                     # enable  named
function sa  { [[ $(sst ${p[78]}       ) ]] && cex "$(pjw 63 78)"; }                                                                                          # start   named
function sp  { [[ $(sst ${p[78]} loaded) ]] && cex "$(pjw 62 78)"; }                                                                                          # stop    named
function sd  { cex "$(pjw 65 78)";sco;sex 'ufw reload'; }                                                                                                     # disable named
# el/cc/vc
function efw { if [[ $cust = hrv ]];then pai $1 192.168.8.0/24 $2 $3;else pai $1 $vip1 $2 $3;pai $1 $vip3 $2 $3;fi; }
function eop { local e=30303;[[ $cunm = $znm1 ]] || e=30304;pae $e elp2p;pde 8545 elapi delete;pde 8551 eljwt delete;efw 8545 elapi       ;efw 8551 eljwt       ; }
function eco { local e=30303;[[ $cunm = $znm1 ]] || e=30304;pde $e elp2p;pde 8545 elapi       ;pde 8551 eljwt       ;efw 8545 elapi delete;efw 8551 eljwt delete; }
function bfw { if [[ $cust = hrv ]];then pai $1 192.168.8.0/24 $2 $3;else pai $1 $vip3 $2 $3;fi; }
function bop { local e=9000 ;[[ $cunm = $znm3 ]] || e=9004 ;pae $e clp2p;pde 5052 clapi delete;pde 8551 cljwt delete;bfw 5052 clapi       ;bfw 8551 cljwt       ; }
function bco { local e=9000 ;[[ $cunm = $znm3 ]] || e=9004 ;pde $e clp2p;pde 5052 clapi       ;pde 8551 cljwt       ;bfw 5052 clapi delete;bfw 8551 cljwt delete; }
function vfw { if [[ $cust = hrv ]];then pai $1 192.168.8.0/24 $2 $3;else pai $1 $vip1 $2 $3;fi; }
function vop { vfw 5064 vcapi       ;pde 5064 vcapi delete; }
function vco { vfw 5064 vcapi delete;pde 5064 vcapi       ; }
# enable/start eth-geth eth-beacon eth-validator prometheus prometheus-node-exporter grafana-server mev-boost
function ge  { eop;sex 'ufw reload';cex "$(pjw 64 70)"; }                                                                                                     # enable eth-geth
function ue  { eop;sex 'ufw reload';cex "$(pjw 64 87)"; }                                                                                                     # enable eth-besu
function be  { bop;sex 'ufw reload';cex "$(pjw 64 71)"; }                                                                                                     # enable eth-beacon
function ve  { vop;sex 'ufw reload';cex "$(pjw 64 73)"; }                                                                                                     # enable eth-validator
function pe  { pai 9090/tcp 192.168.8.0/24 ${p[74]} ;sex 'ufw reload';cex "$(pjw 64 74)"; }                                                                   # enable prometheus
function ne  { sex 'ufw reload';cex "$(pjw 64 75)"; }                                                                                                         # enable prometheus-node-exporter
function fe  { pai 3000/tcp 192.168.8.0/24 grafana  ;sex 'ufw reload';cex "$(pjw 64 76)"; }                                                                   # enable grafana-server
function me  { pai 18550    192.168.8.0/24 mev-boost;sex 'ufw reload';cex "$(pjw 64 96)"; }                                                                   # enable mev-boost
function ga  { [[ $(sst ${p[70]}) ]] && cex "$(pjw 63 70)"; }                                                                                                 # start eth-geth
function ua  { [[ $(sst ${p[87]}) ]] && cex "$(pjw 63 87)"; }                                                                                                 # start eth-besu
function ba  { [[ $(sst ${p[71]}) ]] && cex "$(pjw 63 71)"; }                                                                                                 # start eth-beacon
function va  {
  v2t && [[ -f ${p[10]}/vc_keys && $(sst ${p[73]}) ]] || return                                                                                               # cannot start eth-validator
  if [[ -f ${p[10]}/vc_lock ]];then sis ${p[9]}/$(basename ${p[31]});else cex "$(pjw 63 73)";rm -f ${p[10]}/vc_slash;fi                                       # start eth-validator
}
function pa  { [[ $(sst ${p[74]}) ]] && cex "$(pjw 63 74)"; }                                                                                                 # start prometheus
function na  { [[ $(sst ${p[75]}) ]] && cex "$(pjw 63 75)"; }                                                                                                 # start prometheus-node-exporter
function fa  { [[ $(sst ${p[76]}) ]] && cex "$(pjw 63 76)"; }                                                                                                 # start grafana-server
function ma  { [[ $(sst ${p[96]}) ]] && cex "$(pjw 63 96)"; }                                                                                                 # start mev-boost
function wa  { if [[ $(pex 'ufw status'|grep -i inactive) ]];then yex 'ufw enable';else swu 'FIREWALL ALREADY ACTIVE';fi; }                                   # enable ufw : Proceed with operation (y|n)?
# stop/disable eth-geth eth-beacon eth-validator prometheus prometheus-node-exporter grafana-server mev-boost
function gps { [[ $(sst ${p[70]} loaded) ]] && sex "$(pjw 62 70)"; }                                                                                          # silent stop eth-geth
function ups { [[ $(sst ${p[87]} loaded) ]] && sex "$(pjw 62 87)"; }                                                                                          # silent stop eth-besu
function bps { [[ $(sst ${p[71]} loaded) ]] && sex "$(pjw 62 71)"; }                                                                                          # silent stop eth-beacon
function gp  { [[ $(sst ${p[70]} loaded) ]] && cex "$(pjw 62 70)"; }                                                                                          # stop eth-geth
function up  { [[ $(sst ${p[87]} loaded) ]] && cex "$(pjw 62 87)"; }                                                                                          # stop eth-besu
function bp  { [[ $(sst ${p[71]} loaded) ]] && cex "$(pjw 62 71)"; }                                                                                          # stop eth-beacon
function vp  { [[ $(sst ${p[73]} loaded) ]] && cex "$(pjw 62 73)";touch ${p[10]}/vc_slash; }                                                                  # stop eth-validator
function pp  { [[ $(sst ${p[74]} loaded) ]] && cex "$(pjw 62 74)"; }                                                                                          # stop prometheus
function np  { [[ $(sst ${p[75]} loaded) ]] && cex "$(pjw 62 75)"; }                                                                                          # stop prometheus-node-exporter
function fp  { [[ $(sst ${p[76]} loaded) ]] && cex "$(pjw 62 76)"; }                                                                                          # stop grafana-server
function mp  { [[ $(sst ${p[96]} loaded) ]] && cex "$(pjw 62 96)"; }                                                                                          # stop mev-boost
function gd  { cex "$(pjw 65 70)";eco;sex 'ufw reload'; }                                                                                                     # disable eth-geth
function ud  { cex "$(pjw 65 87)";eco;sex 'ufw reload'; }                                                                                                     # disable eth-besu
function bd  { cex "$(pjw 65 71)";bco;sex 'ufw reload'; }                                                                                                     # disable eth-beacon
function vd  { cex "$(pjw 65 73)";vco;sex 'ufw reload';touch ${p[10]}/vc_lock; }                                                                              # disable eth-validator
function pd  { [[ $(sst ${p[74]} loaded) ]] || return;cex "$(pjw 65 74)";pai 9090/tcp 192.168.8.0/24 ${p[74]}  delete;sex 'ufw reload'; }                     # disable prometheus
function nd  { [[ $(sst ${p[75]} loaded) ]] || return;cex "$(pjw 65 75)"; }                                                                                   # disable prometheus-node-exporter
function fd  { [[ $(sst ${p[76]} loaded) ]] || return;cex "$(pjw 65 76)";pai 3000/tcp 192.168.8.0/24 grafana   delete;sex 'ufw reload'; }                     # disable grafana-server
function md  { [[ $(sst ${p[96]} loaded) ]] || return;cex "$(pjw 65 96)";pai 18550    192.168.8.0/24 mev-boost delete;sex 'ufw reload'; }                     # disable mev-boost
function umt { [[ $(cat ${p[6]}) -eq 1 && $(fs2|grep usb|grep -i error|wc -l) -gt 10 ]]; }                                                                    # usb messages test
function t0t { [[ $(cat ${p[7]}) -eq 0 && $(fs3                       |wc -l) -gt 20 ]]; }                                                                    # cpu no turbo recomended test
function t1t { [[ $(cat ${p[7]}) -eq 1 && $(fs3                       |wc -l) -le 10 ]]; }                                                                    # cpu    turbo recomended test
function t2t { [[ $(cat ${p[7]}) -eq 1 ]]; }                                                                                                                  # cpu no turbo            test
function pas { umt && sex "${p[9]}/eth2/t5 usbstop";t1t && sex "${p[9]}/eth2/t5 cputurbo";t0t && sex "${p[9]}/eth2/t5 cpunoturbo"; }                          # set usb/cpu parameters
function paf { t2t && sex "${p[9]}/eth2/t5 cputurbo"; }                                                                                                       # set turbo   parameter
function ghs { sso GETH ${p[70]}; }
function uhs { sso BESU ${p[87]}; }
function bhs { sso BEAC ${p[71]};sso VALI ${p[73]}; }
function uhx { swn "\n\n$znm1";ssh ztc1 "export H=$H;~/eth2/t6 uhs"; }
function cpx { swn "\n\n$znm2";ssh ztc2 "export H=$H;~/eth2/t6 cpe"; }
function bhx { swn "\n\n$znm3";ssh ztc3 "export H=$H;~/eth2/t6 bhs"; }
function ehx { swn "\n\n$znm4";ssh ztc4 "export H=$H;~/eth2/t6 gbs"; }
function ah1 { swn "\n\n$znm1";uhs;cpe            ;cpx                ;bhx                ;ehx; }
function ah2 {                 uhx;swn "\n\n$znm2";cpe                ;bhx                ;ehx; }
function ah3 {                 uhx                ;cpx;swn "\n\n$znm3";bhs;cpe            ;ehx; }
function ah4 {                 uhx                ;cpx                ;bhx;swn "\n\n$znm4";ghs;bhs;cpe; }
function lhs {
  if v2t;then local e=$(nu0 $(ss1 ${p[73]} nodes "[^$1 ]"|sed -n ${p[92]}));else local e=$(ssh $(snc $cuvc) "export H=$H;~/eth2/t6 cci $1");fi                # get master/slave cc ip
  [[ $e -gt 0 ]] || return;local i=$(sci)
  if [[ $i -eq $e ]];then                                                                                                                                     # get connected ec ip
    local n=$(nu0 $(ss1 ${p[71]} execution-endpoint '[^ ]'|sed -n ${p[92]}))
  else
    local n=$(ssh $(snc $(sni $e)) "export H=$H;~/eth2/t6 eci")
  fi;[[ $n -gt 0 ]] || return;    echo -e "\n$(sni $n)";if [[ $i -eq $n ]];then ghs;uhs;    else ssh $(snc $(sni $n)) "export H=$H;~/eth2/t6 ehs";fi          # ec historic report summary
  [[ $i -eq $e && $i -eq $n ]] || echo -e "\n$(sni $e)";if [[ $i -eq $e ]];then bhs    ;cpe;else ssh $(snc $(sni $e)) "export H=$H;~/eth2/t6 bhs";fi          # cc historic report summary
}
function nsh { ${p[68]} list;${p[68]} status;${p[69]} status|sed -n 's%\(Current DNS\).*:%   \1:%ip'; }                                                       # network/dns info
function wlp { local e="$1";shift;until [[ $# -lt 1 ]];do e="$e\|$1";shift;done;fs2|grep '\[UFW'|if [[ $e ]];then grep -v "$e";else cat;fi; }
function vft { [[ -f $(pjp 4 73).service ]]; }                                                                                                                # vc service file test
function cft { [[ -f $(pjp 4 71).service ]]; }                                                                                                                # cc service file test
function blt { [[ $(grep '\-all-' $(pjp 4 71).service 2>${p[3]}) ]]; }                                                                                        # cc long-lived   test
function c0t { [[ $(sed -n 's%.*--execution-endpoint  *[^ ]*/\([0-9\.]*\):8551.*%\1%p' $(pjp 4 71).service 2>${p[3]}) = $zip1 ]]; }                           # cc choose el server test
function c0c { local e="${p[51]}";c0t && e="${p[50]}";sed "$e" ${p[71]}.sav > $(pjp 4 71).service; }                                                          # cc change el server
function ble { cft || return;cp $(pjp 4 71).service $(pjp 9 71).sav;sed "$1" $(pjp 9 71).sav > $(pjp 4 71).service;dmr; }                                     # cc service edit
function cce { cft || return;cp $(pjp 4 71).service $(pjp 9 71).sav;c0c;cmw $(pjp 4 71).service 644 eth; }                                                    # cc change el server (merge)
function vcc { vft || return;cp $(pjp 4 73).service $(pjp 9 73).sav;sed "${p[59]}" ${p[73]}.sav > $(pjp 4 73).service;cmw $(pjp 4 73).service 644 eth; }      # vc switch cc server order
function trs { if [[ $(sst ${p[77]} masked) ]];then nex "${p[66]} ntp";else nex "$(pjw 66 77)";fi; }                                                          # systemd-timesyncd/ntp restart
function dpa { nex "$(pjw 62 78)";nex "${p[62]} systemd-resolved";nex "$(pjw 63 78)";nex "${p[63]} systemd-resolved"; }                                       # DNS stop/start
function nrs { nex 'netplan apply';dpa; }                                                                                                                     # netplan/DNS restart
function lcp { local f=$1;shift;[[ -x $f ]] && until [[ $# -lt 1 ]];do if [[ $1 = $(snc $cunm) ]];then lci $f;else scp $f $1:${p[9]};fi;shift;done; }         # propagate lighthouse
function lci { [[ -x $1 && ! -d $1      ]] || return;sex "mv ${p[0]}/lighthouse ${p[0]}/lighthouse.sav";sex "cp $1 ${p[0]}"; }                                # lighthouse binary install
function lmd { [[ -x ${p[0]}/lighthouse ]] || return;cmw ${p[0]}/lighthouse 755 eth;swb 'LIGHT INSTALADO'; }                                                  # lighthouse set permissions
function lpi { [[ $cunm = $znm2 ]] && lcp $1 ztc2 ztc3;[[ $cunm = $znm4 ]] && lcp $1 ztc4;[[ $cunm = $vnm1 ]] && lcp $1 vpsl;lci ${p[9]}/lighthouse;sex "rm ${p[9]}/lighthouse";lmd; }
function luc {                                                                                                                                                # lighthouse upgrade/compile
  if [[ -f ${p[38]}/lighthouse/README.md ]];then
    cd ${p[38]}/lighthouse;make clean;cargo clean                                                                                                             # clean compile dirs
  else
    cd ${p[38]};sex "rm -rf ${p[38]}/lighthouse";git clone https://github.com/sigp/lighthouse.git;cd ${p[38]}/lighthouse                                      # get new git
  fi
  git fetch;if [[ $(echo $2|egrep 'v[0-9]+\.[0-9]+\.[0-9]+') ]];then m=$2;else m=$(git describe --tags $(git rev-list --tags --max-count=1));fi               # fetch (vX.X.X/last) version
  git checkout $m;swu 'VAI COMPILAR LIGHT';FEATURES=modern PROFILE=maxperf make;[[ $? -eq 0 && -x $1 ]] || swb 'ERRO COMPILAR ERRO'                           # checkout stable version & compile
}
function jw0 { [[ -f jwt ]] && return;openssl rand -hex 32|tr -d '\n'|tee jwt 1>${p[3]}; }                                                                    # create jwt file
function ruv { if [[ $1 ]];then swn "RUST OVERRIDE SET $1";rustup override set $1;else swn 'RUST UPDATE';rustup update stable;fi; }                           # set/update rust version
function v0t { [[ $(sst ${p[73]} running) ]]; }                                                                                                               # vc running  test
function v1t { [[ $cunm = $nxvc ]]; }                                                                                                                         # vc next     test
function v2t { [[ $cunm = $cuvc ]]; }                                                                                                                         # vc current  test
function v3t { [[ $cuvc = $nxvc ]]; }                                                                                                                         # vc transfer test
function vps { local f=${p[9]}/$(basename ${p[31]});sex "cp ${p[31]} ${p[9]}";cmw $f 666 eth;scp $f $(snc $nxvc):~;sex "rm $f"; }                             # prep slash db
function tvc {
  v3t && return;swn "${p[86]}";if v2t && v0t;then swn "TRANSFERIR VC -> $nxvc (SIM/nao)?";else return;fi;local rsp=nao;read rsp
  if [[ $rsp = SIM && ! -f ${p[10]}/vc_slash && ! -f ${p[10]}/vc_lock && -f ${p[10]}/vc_keys ]];then vp;vd;swu "COPY SLASH -> $nxvc";vps;fi                   # vc stop/disable & prep slash db
}
function mrs { local f='';for f in $(ls $1 2>${p[3]});do curl -sX GET "${p[85]}$(sed -n "${p[100]}" $f)"|sed -n "${p[90]}";done; }                            # show mev validator registration

[[ $1 = mr  ]] && { mrs ${2:-${p[9]}/validator_keys/keystore\*.json}; }
[[ $1 = jwt ]] && { [[ $cunm = $znm1 || $cunm = $vnm1 ]] && jw0;if [[ -f jwt ]];then sjw eth1 ${p[18]}/geth;sjw eth1 ${p[37]}/data;sjw eth2 ${p[16]};fi; }
[[ $1 = lpi ]] && { lpi ${p[9]}/.cargo/bin/lighthouse; }
[[ $1 = luc ]] && { luc ${p[9]}/.cargo/bin/lighthouse $2; }
[[ $1 = ruv ]] && { ruv $2; }
[[ $1 = clr ]] && { blt && ble "${p[57]}"; }
[[ $1 = cla ]] && { blt || ble "${p[58]}"; }
[[ $1 = vcc ]] && { vcc; }
[[ $1 = cce ]] && { cce; }
[[ $1 = chk ]] && { cex 'chkrootkit'; }
[[ $1 = eip ]] && { curl -s4 "https://${3:-meo.fruga.pt}:$2@dyn.dns.he.net/nic/update?hostname=${3:-meo.fruga.pt}" &>${p[3]}; }
[[ $1 = dsh ]] && { ${p[69]} query ${2:-smtp.gmail.com}; }
[[ $1 = drs ]] && { dpa; }
[[ $1 = nrs ]] && { nrs; }
[[ $1 = trs ]] && { trs; }
[[ $1 = dmr ]] && { dmr; }
[[ $1 = tsh ]] && { cex "${p[67]}";cex "${p[67]} timesync-status";cex "${p[67]} show-timesync"; }
[[ $1 = nsh ]] && { nsh; }
[[ $1 = tvc ]] && { tvc; }
[[ $1 = tmp ]] && { dts;tmp s; }
[[ $1 = ul  ]] && { ul0;swn "$m"; }
[[ $1 = ulf ]] && { ul0;swn "$m" >> ${p[89]};[[ $ok != OK ]] && urs 0;pas; }                                                                                  # el log/restart
[[ $1 = gl  ]] && { gl0;swn "$m"; }
[[ $1 = glf ]] && { gl0;swn "$m" >> ${p[13]};[[ $ok != OK ]] && grs 0;pas; }                                                                                  # el log/restart
[[ $1 = bl  ]] && { bl0;swn "$m"; }
[[ $1 = bm  ]] && { bm0;bmo;swn "$m"; }
[[ $1 = bn  ]] && { bm0;bno;swn "$m"; }
[[ $1 = blf ]] && { bl0;swn "$m" >> ${p[11]};stt && bo5 && bht && bst && bdl $d0;v2t && [[ $ok != OK ]] && brs 0;pas; }                                       # cl log/delete/restart & parameter set
[[ $1 = bmf ]] && { bm0;bms;bbt && swn "$m" >> ${p[12]};bct && brs $b4 $(btr PE) 120; }
[[ $1 = bnf ]] && { bm0;bno;swn "$m" >> ${p[14]}; }
[[ $1 = gh  ]] && { eh0 ${p[13]} $2;[[ $2 ]] || { gl0;swn "$m\n";ghs;cpe; } }
[[ $1 = uh  ]] && { eh0 ${p[89]} $2;[[ $2 ]] || { ul0;swn "$m\n";uhs;cpe; } }
[[ $1 = bh  ]] && { bh0 $2; }
[[ $1 = bio ]] && { bio ${2:-2};swn "$m"; }
[[ $1 = ahs ]] && { [[ $cunm = $znm1 ]] && ah1;[[ $cunm = $znm2 ]] && ah2;[[ $cunm = $znm3 ]] && ah3;[[ $cunm = $znm4 ]] && ah4; }
[[ $1 = ghs ]] && { ghs    ;cpe; }                                                                                                                            #        ec/system       reports
[[ $1 = uhs ]] && { uhs    ;cpe; }                                                                                                                            #        ec/system       reports
[[ $1 = bhs ]] && { bhs    ;cpe; }                                                                                                                            #        cl/system       reports
[[ $1 = ehs ]] && { ghs;uhs;cpe; }                                                                                                                            #        el/system       reports
[[ $1 = gbs ]] && { ghs;bhs;cpe; }                                                                                                                            #        ec/cc/system    reports
[[ $1 = mhs ]] && { lhs ,; }                                                                                                                                  # master ec/cc/vc/system reports
[[ $1 = shs ]] && { lhs  ; }                                                                                                                                  # slave  ec/cc/vc/system reports
[[ $1 = cci ]] && { nu0 $(ss1 ${p[73]} nodes            "[^$2 ]"|sed -n ${p[92]}); }                                                                          # cc ip vc uses
[[ $1 = eci ]] && { nu0 $(ss1 ${p[71]} execution-endpoint '[^ ]'|sed -n ${p[92]}); }                                                                          # ec ip cc uses
[[ $1 = bo  ]] && { bo0 $2 $3 $4; }
[[ $1 = bon ]] && { bon $2; }
[[ $1 = boc && -f ${p[11]} ]] && { unset v;read -a v <<< $(bff|tail -n1);l2=$(bff $(pt1 $2 ${v[4]}));boa; }
[[ $1 = bol && -f ${p[11]} ]] && { l2=$(bff 23:58);boa; }
[[ $1 = bdl ]] && { bdl $2; }
[[ $1 = brl ]] && { brl; }
[[ $1 = brm ]] && { brm; }
[[ $1 = bsl ]] && { bsl; }
[[ $1 = cpe ]] && { cpe $2; }
[[ $1 = gpn ]] && { if [[ $(sst ${p[70]} running) ]];then gp;cex "du -h ${p[18]}";sudo -u eth1 ${p[8]}/geth --datadir ${p[18]} snapshot prune-state;cex "du -h ${p[18]}";dmr;ga;fi; }
[[ $1 = grs ]] && { grs ${2:-0}   ; }
[[ $1 = urs ]] && { urs ${2:-0}   ; }
[[ $1 = bsb ]] && { bsb ${2:-0} BN; }
[[ $1 = bsv ]] && { bsb ${2:-0} VC; }
[[ $1 = brs ]] && { brs ${2:-0} BN; }
[[ $1 = crs ]] && { brs ${2:-0} VC; }
[[ $1 = brb ]] && { brs ${2:-0} RB; }
[[ $1 = grb ]] && { grs ${2:-0} RB; }
[[ $1 = urb ]] && { urs ${2:-0} RB; }
[[ $1 = irb ]] && { irb ${2:-3};pas; }
[[ $1 = lp  ]] && { netstat -tulpn; }
# outros journal system/lighthouse
[[ $1 = sl  ]] && { fs2|fs6 $2; }
[[ $1 = el  ]] && { if [[ $(sst ${p[70]} running) ]];then fs0 . 0 ${p[47]};else fs0 . 0 ${p[102]};fi|fs5 $2; }
[[ $1 = cl  ]] && { fs0 . 0 ${p[103]}|fs5 $2; }
[[ $1 = ml  ]] && { fs0 . 0 ${p[101]}|fs5 $2; }
[[ $1 = ll  ]] && { rl1 ${p[104]}|fs5 $2; }
[[ $1 = ci  ]] && { rl0          |fs5 $2; }
[[ $1 = vi  ]] && { rl4          |fs5 $2; }
[[ $1 = ni  ]] && { (rl0;rl4)    |fs5 $2|sort -M; }
[[ $1 = ws  ]] && { cex 'ufw status numbered'; }
[[ $1 = wa  ]] && { wa; }
[[ $1 = we  ]] && { yex 'ufw enable'; }
[[ $1 = wpr ]] && { cex 'ufw disable'; }
[[ $1 = wds ]] && { cex 'ufw disable'; }
[[ $1 = wl  ]] && { wlp ${@:2:$#}; }
# journal
[[ $1 = yj  ]] && { jsh; }
[[ $1 = ej  ]] && { jsh "-u ${p[70]} -u ${p[71]} -u ${p[73]}"; }
[[ $1 = gj  ]] && { jsh "-u ${p[70]}"; }
[[ $1 = uj  ]] && { jsh "-u ${p[87]}"; }
[[ $1 = bj  ]] && { jsh "-u ${p[71]}"; }
[[ $1 = vj  ]] && { jsh "-u ${p[73]}"; }
[[ $1 = sj  ]] && { jsh "-u ${p[78]}"; }
[[ $1 = mj  ]] && { jsh "-u ${p[96]}"; }
# arranca
[[ $1 = ga  ]] && { dmr;ga; }
[[ $1 = ua  ]] && { dmr;ua; }
[[ $1 = ba  ]] && { dmr;ba; }
[[ $1 = va  ]] && { dmr;va; }
[[ $1 = pa  ]] && { dmr;pa; }
[[ $1 = na  ]] && { dmr;na; }
[[ $1 = fa  ]] && { dmr;fa; }
[[ $1 = xa  ]] && { dmr;xa; }
[[ $1 = ra  ]] && { dmr;ra; }
[[ $1 = sa  ]] && { dmr;sa; }
[[ $1 = ma  ]] && { dmr;ma; }
# para & arranca & journal
[[ $1 = gaj ]] && { dmr;ga;jsh "-u ${p[70]}"; }
[[ $1 = uaj ]] && { dmr;ua;jsh "-u ${p[87]}"; }
[[ $1 = baj ]] && { dmr;ba;jsh "-u ${p[71]}"; }
[[ $1 = vaj ]] && { dmr;va;jsh "-u ${p[73]}"; }
[[ $1 = saj ]] && { dmr;sa;jsh "-u ${p[78]}"; }
[[ $1 = maj ]] && { dmr;ma;jsh "-u ${p[96]}"; }
[[ $1 = gpa ]] && { gp;dmr;ga;jsh "-u ${p[70]}"; }
[[ $1 = upa ]] && { up;dmr;ua;jsh "-u ${p[87]}"; }
[[ $1 = bpa ]] && { bp;dmr;ba;jsh "-u ${p[71]}"; }
[[ $1 = vpa ]] && { vp;dmr;va;jsh "-u ${p[73]}"; }
[[ $1 = spa ]] && { sp;sa; }
[[ $1 = mpa ]] && { mp;dmr;ma;jsh "-u ${p[96]}"; }
[[ $1 = gpd ]] && { gp;gd; }
[[ $1 = upd ]] && { up;ud; }
[[ $1 = bpd ]] && { bp;bd; }
[[ $1 = vpd ]] && { vp;vd; }
[[ $1 = xpd ]] && { xp;xd; }
[[ $1 = rpd ]] && { rp;rd; }
[[ $1 = spd ]] && { sp;sd; }
[[ $1 = mpd ]] && { mp;md; }
[[ $1 = gea ]] && { ge;dmr;ga;jsh "-u ${p[70]}"; }
[[ $1 = uea ]] && { ue;dmr;ua;jsh "-u ${p[87]}"; }
[[ $1 = bea ]] && { be;dmr;ba;jsh "-u ${p[71]}"; }
[[ $1 = vea ]] && { ve;dmr;va;jsh "-u ${p[73]}"; }
[[ $1 = rea ]] && { re;dmr;ra; }
[[ $1 = sea ]] && { se;dmr;sa; }
[[ $1 = xea ]] && { xe;dmr;xa; }
[[ $1 = mea ]] && { me;dmr;ma;jsh "-u ${p[96]}"; }
# enable
[[ $1 = ge  ]] && { ge; }
[[ $1 = ue  ]] && { ue; }
[[ $1 = be  ]] && { be; }
[[ $1 = ve  ]] && { ve; }
[[ $1 = pe  ]] && { pe; }
[[ $1 = ne  ]] && { ne; }
[[ $1 = fe  ]] && { fe; }
[[ $1 = xe  ]] && { xe; }
[[ $1 = re  ]] && { re; }
[[ $1 = se  ]] && { se; }
[[ $1 = me  ]] && { me; }
# para
[[ $1 = fpr ]] && { fp; }
[[ $1 = npr ]] && { np; }
[[ $1 = ppr ]] && { pp; }
[[ $1 = vpr ]] && { vp; }
[[ $1 = bpr ]] && { bp; }
[[ $1 = gpr ]] && { gp; }
[[ $1 = upr ]] && { up; }
[[ $1 = xpr ]] && { xp; }
[[ $1 = rpr ]] && { rp; }
[[ $1 = spr ]] && { sp; }
[[ $1 = mpr ]] && { mp; }
# disable
[[ $1 = fds ]] && { fd; }
[[ $1 = nds ]] && { nd; }
[[ $1 = pds ]] && { pd; }
[[ $1 = vds ]] && { vd; }
[[ $1 = bds ]] && { bd; }
[[ $1 = gds ]] && { gd; }
[[ $1 = uds ]] && { ud; }
[[ $1 = xds ]] && { xd; }
[[ $1 = rds ]] && { rd; }
[[ $1 = sds ]] && { sd; }
[[ $1 = mds ]] && { md; }
[[ $1 = lup ]] && { apt list --upgradable; }

if [[ ! $1 ]];then
  m="primeira letra"
  m="$m\ne\t\t${p[70]} ${p[71]} ${p[73]}"
  m="$m\ng\t\t${p[70]}"
  m="$m\nu\t\t${p[87]}"
  m="$m\nb\t\t${p[71]}"
  m="$m\nv\t\t${p[73]}"
  m="$m\np\t\t${p[74]}"
  m="$m\nn\t\t${p[75]}"
  m="$m\nf\t\t${p[76]}"
  m="$m\nx\t\t${p[79]}"
  m="$m\nr\t\t${p[72]}"
  m="$m\ns\t\t${p[78]}"
  m="$m\nm\t\t${p[96]}"
  m="$m\nsegunda letra"
  m="$m\na[j]\t\tarranca\t[& journal]"
  m="$m\ne\t\tenable"
  m="$m\nj\t\tjournal"
  m="$m\npr\t\tpara"
  m="$m\nds\t\tdisable"
  m="$m\npd\t\tpara\t& disable"
  m="$m\npa\t\tpara\t& arranca\t& journal"
  m="$m\nea\t\tenable\t& arranca\t& journal"
  m="$m\noutros"
  m="$m\ngl[f]\t\tec log report"
  m="$m\ngpn\t\t${p[70]} prune DB - TAKES HOURS"
  m="$m\nbsb [n]\t\t${p[71]}\t\t\tstop\twith n peers"
  m="$m\nbsv [n]\t\t${p[71]}/${p[73]}\tstop\twith n peers"
  m="$m\ngrs [n]\t\t${p[70]}\t\t\trestart\twith n peers"
  m="$m\nurs [n]\t\t${p[87]}\t\t\trestart\twith n peers"
  m="$m\nbrs [n]\t\t${p[71]}\t\t\trestart\twith n peers"
  m="$m\ncrs [n]\t\t${p[71]}/${p[73]}\trestart\twith n peers"
  m="$m\ngrb [n]\t\tsystem & geth\t\t\treboot\twith n peers"
  m="$m\nurb [n]\t\tsystem & besu\t\t\treboot\twith n peers"
  m="$m\nbrb [n]\t\tsystem & beacon\t\t\treboot\twith n peers"
  m="$m\nirb [h]\t\tsystem (if needed)\t\treboot\tafter h hours"
  m="$m\nyj\t\tsystem journal"
  m="$m\nsl\t[hh:mm]\tsystem journal\tlog lines"
  m="$m\nll\t[hh:mm]\tel/cl\t\tlog lines (last 7 days)"
  m="$m\n[ecm]l\t[hh:mm]\tec/cc/mev\tlog lines"
  m="$m\n[cvn]i\t[hh:mm]\tcc/vc/node\tlog lines (internal)"
  m="$m\nbrl\t\trecalculate cc logs"
  m="$m\nbrm\t\trecalculate cc-daily logs"
  m="$m\nbsl\t\tshrink cc log using barqivo"
  m="$m\nbdl yyyy-mm-dd\tdelete cc log day"
  m="$m\nbio [lines]\timported/observed delays (using [lines] from intern log)"
  m="$m\nbo  [lines]\thomologous report [with max lines]"
  m="$m\nbon [nodes]\thomologous nodes report"
  m="$m\nbo[cl]\t\tall homologous nodes report at [current|last] time"
  m="$m\nbl[f]\t\tcc report [file add & delete log day]"
  m="$m\nbm[f]\t\tcc-daily report [file add & ${p[71]} nodes change/restart]"
  m="$m\nbn[f]\t\tarqivo report [file add]"
  m="$m\n[gub]h[s]\tgeth|besu|beacon\thistoric report [summary]"
  m="$m\nehs\t\tgeth|besu\t\thistoric report summary"
  m="$m\ngbs\t\tgeth/beacon\t\thistoric report summary"
  m="$m\n[m|s]hs\t\t[master|slave] el/cl\thistoric report summary"
  m="$m\ncla\t\tcc add    long-lived parms"
  m="$m\nclr\t\tcc remove long-lived parms"
  m="$m\ncce\t\tcc change ec server ($znm1/$znm4)"
  m="$m\nvcc\t\tvc switch cc server order"
  m="$m\ntvc\t\tvc transfer ($cuvc -> $nxvc)"
  m="$m\nws\t\tfirewall status"
  m="$m\nwa\t\tfirewall arranca"
  m="$m\nwpr\t\tfirewall para"
  m="$m\ncpe [cp]\tclock & cpu & errors status"
  m="$m\nlp\t\tlista portas"
  m="$m\neip\t\tset dynamic DNS"
  m="$m\nnsh\t\tnetwork/route/DNS show "
  m="$m\ndsh [url]\tdns show"
  m="$m\nnrs\t\tdns/netplan reset"
  m="$m\ndrs\t\tdns reset"
  m="$m\ntrs\t\ttime sync restart"
  m="$m\ntsh\t\ttime sync show "
  m="$m\ntmp\t\ttemperature show"
  m="$m\nchk\t\tcheck server with chkrootkit"
  m="$m\nlup\t\tcheck apt list --upgradable"
  swn "\n$m\n"
fi
