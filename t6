#!/bin/bash

source /home/eth/eth2/t1

# Plex Media Server
function rxw { uu "ufw$2 allow from 192.168.8.0/24 $1"; }
function xop { uu 'ufw delete deny 32400             ';rxw 'to any port 32400 comment plex'; }
function xcl { uu 'ufw        deny 32400 comment plex';rxw 'to any port 32400 '   ' delete'; }
function xe { xop;uu 'ufw reload';uu "systemctl enable $plex"; }
function xa { [ "$(systemctl status $plex 2>/dev/null|grep -i 'inactive\|failed')" ] && { uu "systemctl start $plex"; } }
function xp { [ "$(systemctl status $plex 2>/dev/null|grep -i loaded)" ] && { uu "systemctl stop $plex"; } }
function xd { uu "systemctl disable $plex";xcl;uu 'ufw reload'; }
# Transmission BitTorrent Daemon
function rop { uu 'ufw allow 51413 comment torrent';rxw 'to any port 9091 comment torrent'; }
function rcl { uu 'ufw deny  51413 comment torrent';rxw 'to any port 9091'       ' delete'; }
function re { rop;uu 'ufw reload';uu "systemctl enable $trrt"; }
function ra { [ "$(systemctl status $trrt 2>/dev/null|grep -i 'inactive\|failed')" ] && { uu "systemctl start $trrt"; } }
function rp { [ "$(systemctl status $trrt 2>/dev/null|grep -i loaded)" ] && { uu "systemctl stop $trrt"; } }
function rd { uu "systemctl disable $trrt";rcl;uu 'ufw reload'; }
# Bind9
function sop { uu 'ufw delete deny 53            ';rxw 'to any port 53 comment dns'; }
function scl { uu 'ufw        deny 53 comment dns';rxw 'to any port 53 '  ' delete'; }
function se { sop;uu 'ufw reload';uu "systemctl enable $dnsd"; }
function sa { [ "$(systemctl status $dnsd 2>/dev/null|grep -i 'inactive\|failed')" ] && { uu "systemctl start $dnsd"; } }
function sp { [ "$(systemctl status $dnsd 2>/dev/null|grep -i loaded)" ] && { uu "systemctl stop $dnsd"; } }
function sd { uu "systemctl disable $dnsd";scl;uu 'ufw reload'; }

function gfw { if [ "$cust" = "hrv" ];then uu "ufw$2 allow from $zip2 $1";uu "ufw$2 allow from $zip3 $1";else uu "ufw$2 allow from $vip1 $1";uu "ufw$2 allow from $vip3 $1";fi; }
function gop { uu 'ufw allow 30303 comment eth1';uu 'ufw delete deny 8545              ';gfw 'to any port 8545 comment geapi'; }
function gcl { uu 'ufw deny  30303 comment eth1';uu 'ufw        deny 8545 comment geapi';gfw 'to any port 8545'     ' delete'; }
function ofw { if [ "$cust" = "hrv" ];then uu "ufw$2 allow from $zip2 $1";uu "ufw$2 allow from $zip3 $1";else uu "ufw$2 allow from $vip1 $1";uu "ufw$2 allow from $vip3 $1";fi; }
function oop { uu 'ufw allow 30303 comment eth1';uu 'ufw delete deny 8545              ';gfw 'to any port 8545 comment oeapi'; }
function ocl { uu 'ufw deny  30303 comment eth1';uu 'ufw        deny 8545 comment oeapi';gfw 'to any port 8545'     ' delete'; }
function bfw { if [ "$cust" = "hrv" ];then uu "ufw$2 allow from $zip3 $1";else uu "ufw$2 allow from $vip3 $1";fi; }
function bop { uu 'ufw allow 9000 comment eth2';uu 'ufw delete deny 5052              ';bfw 'to any port 5052 comment bnapi'; }
function bcl { uu 'ufw deny  9000 comment eth2';uu 'ufw        deny 5052 comment bnapi';bfw 'to any port 5052'     ' delete'; }
function vfw { if [ "$cust" = "hrv" ];then uu "ufw$2 allow from $zip1 $1";else uu "ufw$2 allow from $vip1 $1";fi; }
function vop { uu 'ufw delete deny 5064              ';vfw 'to any port 5064 comment vcmet'; }
function vcl { uu 'ufw        deny 5064 comment vcmet';vfw 'to any port 5064'     ' delete'; }
function fop { uu 'ufw allow 3000/tcp comment grafana'; }
function fcl { uu 'ufw deny  3000/tcp                '; }

function uu { echo -e "${i}$1${f}";echo $H|sudo -S $1 2>/dev/null; }
function us { echo $H|sudo -S $1 2>/dev/null; }
function ut { echo -e "${i}$1${f}";echo $H|sudo -S $1 2>/dev/null|tail -n $2; }
function jb { uu "journalctl --no-hostname --no-full -f $1"; }
function dr { echo $H|sudo -S systemctl daemon-reload 2>/dev/null; }

function ge { gop;uu 'ufw reload';uu "systemctl enable $ethg"; }
function oe { oop;uu 'ufw reload';uu "systemctl enable $etho"; }
function be { bop;uu 'ufw reload';uu "systemctl enable $ethb"; }
function ve { [ ! -f $dtdi/vc_lock ] && { vop;uu 'ufw reload';uu "systemctl enable $ethv"; } }
function pe { uu 'ufw reload';uu "systemctl enable $ethp"; }
function ne { uu 'ufw reload';uu "systemctl enable $ethn"; }
function fe { fop;uu 'ufw reload';uu "systemctl enable $ethf"; }
function ga { [ "$(systemctl status $ethg 2>/dev/null|grep -i 'inactive\|failed')" ] && [ -d /var/lib/goethereum   ] && { uu "systemctl start $ethg"; } }
function oa { [ "$(systemctl status $etho 2>/dev/null|grep -i 'inactive\|failed')" ] && [ -d /var/lib/openethereum ] && { uu "systemctl start $etho"; } }
function ba { [ "$(systemctl status $ethb 2>/dev/null|grep -i 'inactive\|failed')" ] && { uu "systemctl start $ethb"; } }
function va { [ "$(systemctl status $ethv 2>/dev/null|grep -i 'inactive\|failed')" ] && [ ! -f $dtdi/vc_lock ] && { uu "systemctl start $ethv"; } }
function pa { [ "$(systemctl status $ethp 2>/dev/null|grep -i 'inactive\|failed')" ] && { uu "systemctl start $ethp"; } }
function na { [ "$(systemctl status $ethn 2>/dev/null|grep -i 'inactive\|failed')" ] && { uu "systemctl start $ethn"; } }
function fa { [ "$(systemctl status $ethf 2>/dev/null|grep -i 'inactive\|failed')" ] && { uu "systemctl start $ethf"; } }
function gp { [ "$(systemctl status $ethg 2>/dev/null|grep -i loaded)" ] && { uu "systemctl stop $ethg"; } }
function op { [ "$(systemctl status $etho 2>/dev/null|grep -i loaded)" ] && { uu "systemctl stop $etho"; } }
function bp { [ "$(systemctl status $ethb 2>/dev/null|grep -i loaded)" ] && { uu "systemctl stop $ethb"; } }
function vp { [ "$(systemctl status $ethv 2>/dev/null|grep -i loaded)" ] && { uu "systemctl stop $ethv"; } }
function pp { [ "$(systemctl status $ethp 2>/dev/null|grep -i loaded)" ] && { uu "systemctl stop $ethp"; } }
function np { [ "$(systemctl status $ethn 2>/dev/null|grep -i loaded)" ] && { uu "systemctl stop $ethn"; } }
function fp { [ "$(systemctl status $ethf 2>/dev/null|grep -i loaded)" ] && { uu "systemctl stop $ethf"; } }
function gd { uu "systemctl disable $ethg";gcl;uu 'ufw reload'; }
function od { uu "systemctl disable $etho";ocl;uu 'ufw reload'; }
function bd { uu "systemctl disable $ethb";bcl;uu 'ufw reload'; }
function vd { uu "systemctl disable $ethv";vcl;uu 'ufw reload';touch $dtdi/vc_lock; }
function pd { [ "$(systemctl status $ethp 2>/dev/null|grep -i loaded)" ] && { uu "systemctl disable $ethp"; } }
function nd { [ "$(systemctl status $ethn 2>/dev/null|grep -i loaded)" ] && { uu "systemctl disable $ethn"; } }
function fd { [ "$(systemctl status $ethf 2>/dev/null|grep -i loaded)" ] && { uu "systemctl disable $ethf";fcl;uu 'ufw reload'; } }
function g0 { g0=0;[ -d /var/lib/goethereum   ] && g0=$(echo $H|sudo -S du -s /var/lib/goethereum 2>/dev/null|cut -f1); }
function g1 { g1=0;[ -d /var/lib/goethereum   ] && { if [ "$cunm" = "$znm1" ];then g="http://$zip1:8545";else g="http://$vip1:8545";fi;g1=$(geth attach $g --exec eth.syncing); }; }
function g2 { g2=0;[ -d /var/lib/goethereum   ] && { if [ "$cunm" = "$znm1" ];then g="http://$zip1:8545";else g="http://$vip1:8545";fi;g2=$(geth attach $g --exec net.peerCount); }; }
function g1 { g1=0;[ -d /var/lib/goethereum   ] && { if [ "$cunm" = "$znm1" ];then g="http://$zip1:8545";else g="http://$vip1:8545";fi;g1=$(geth attach $g --exec eth.syncing); }; }
function o1 {
  o1='{"currentBlock":"0xbe7edd","highestBlock":"0xbe82b9","startingBlock":"0xbe7c7a","warpChunksAmount":null,"warpChunksProcessed":null}'
  if [ -d /var/lib/openethereum ]; then
    if [ "$cunm" = "$znm1" ];then o5="POST $zip1:8545";else o5="POST $vip1:8545";fi
    o1=$(curl -s --data '{"method":"eth_syncing","params":[],"id":1,"jsonrpc":"2.0"}' -H 'Content-Type: application/json' -X $o5|sed 's%.*result":\(.*\),.*%\1%')
  fi
}
function o2 {
  o2=0
  if [ -d /var/lib/openethereum ]; then
    if [ "$cunm" = "$znm1" ];then o5="POST $zip1:8545";else o5="POST $vip1:8545";fi
    o6=$(curl -s --data '{"method":"net_peerCount","params":[],"id":1,"jsonrpc":"2.0"}' -H 'Content-Type: application/json' -X $o5|sed 's%.*result":"0x\([a-z0-9]*\)".*%\1%')
    o2=$(echo "obase=10; ibase=16; ${o6^^}"|bc)
  fi
}
function g3 { g3=$(echo $H|sudo -S grep -i peers: /var/log/syslog 2>/dev/null|tail -n 1|sed 's%.*peers: *\([0-9]*\).*%\1%'); }
function gs {
  if [ -d /var/lib/goethereum ] && ([ "$cunm" = "$vnm1" ] || [ "$cunm" = "$znm1" ]); then
    g0;g1;g2
    if [ "$(echo $g1|grep -i false)" ]; then
      m="GETH SYNCED - PEERCOUNT $g2"
    else
      h=$(echo $g1|sed -Ee 's%.*highestBlock: *([0-9]+).*%\1%i')
      c=$(echo $g1|sed -Ee 's%.*currentBlock: *([0-9]+).*%\1%i')
      k=$(echo $g1|sed -Ee 's%.*knownStates: *([0-9]+).*%\1%i')
      p=$(echo $g1|sed -Ee 's%.*pulledStates: *([0-9]+).*%\1%i')
      b=$(echo $H|sudo -S grep -i 'Imported new block headers' /var/log/syslog 2>/dev/null|head -1|cut -d= -f4|cut -d' ' -f1)
      d=$(echo $H|sudo -S grep -i 'Imported new block headers' /var/log/syslog 2>/dev/null|tail -1|cut -d= -f4|cut -d' ' -f1)
      y=$(echo $H|sudo -S grep -i 'Imported new state entries' /var/log/syslog 2>/dev/null|head -1|cut -d= -f4|cut -d' ' -f1)
      t=$(echo $H|sudo -S grep -i 'Imported new state entries' /var/log/syslog 2>/dev/null|tail -1|cut -d= -f4|cut -d' ' -f1)
      m="GETH SYNCING - PEERCOUNT: $g2\nBlocks api: $h ($((h-c)))\tStates api: $k ($((k-p)))\nBlocks log: $d ($((d-b)))\tStates log: $t ($((t-y))))"
    fi
  else
    m="NO GETH HERE ($cunm)"
  fi
}
function rq { echo -e "\nresolvectl query ${1:-pt.archive.ubuntu.com}";resolvectl query "${1:-pt.archive.ubuntu.com}"; }
function rs { echo -e "${i}RESET NETPLAN & SYSTEMD-RESOLVED${f}";echo $H|sudo -S netplan apply 2>/dev/null;sudo systemctl restart systemd-resolved; }
function cr {
  if [ "$cunm" = "$znm1" ] || [ "$cunm" = "$znm2" ] || [ "$cunm" = "$znm3" ]; then
    if [ "$(ip route show|grep 'default via'|cut -d' ' -f3)" = "192.168.8.1" ];then m=3; else m=1;fi
    echo -e "${i}CHANGE ROUTE 192.168.8.${m}"
    sed -e "s%via:.*%via: 192.168.8.$m%" /etc/netplan/00-installer-config.yaml > ~/00-installer-config.save
    echo $H|sudo -S mv ~/00-installer-config.save /etc/netplan/00-installer-config.yaml 2>/dev/null
    sudo chown root:root /etc/netplan/00-installer-config.yaml 
    sudo chmod 644 /etc/netplan/00-installer-config.yaml 
    rs
  fi
}
function ds { echo -e "${i}RESET DNS & SYSTEMD-RESOLVED${f}";sp;sudo systemctl stop  systemd-resolved;sa;sudo systemctl start systemd-resolved; }
#function cf {
#  if [ "$cunm" = "$znm1" ] || [ "$cunm" = "$znm2" ]; then
#    if [ "$(grep 'forwarders {' /etc/bind/named.conf.options |cut -d' ' -f3)" = "192.168.8.1;" ];then m=3; else m=1;fi
#    echo -e "${i}CHANGE FORWARDER 192.168.8.${m}${f}"
#    sed -e "s%forwarders .*%forwarders { 192.168.8.$m; };%" /etc/bind/named.conf.options > ~/named.save
#    echo $H|sudo -S mv ~/named.save /etc/bind/named.conf.options 2>/dev/null
#    sudo chown root:root /etc/bind/named.conf.options 
#    sudo chmod 644 /etc/bind/named.conf.options
#    ds
#  fi
#}
function sr { echo -e "ROUTE\t\t$(ip route show|grep 'default via'|cut -d' ' -f3)"; }
function sf {
  m="$(netstat -i|grep -v '^lo\|Iface\|Kernel'|cut -d' ' -f1)"
  # [ -f /etc/bind/named.conf.options ] && echo -e "FORWARDER\t$(grep 'forwarders {' /etc/bind/named.conf.options 2>/dev/null|cut -d' ' -f3)"
  echo -e "DNS\t\t$(resolvectl|grep 'Current DNS'|cut -d' ' -f6)"
  echo -e "$m\t\t$(resolvectl dns|grep $m|cut -d' ' -f4-6)"
}
function gk {
  t=-1;n=0;v=0;m=""
  if [ "$(systemctl status $ethg 2>/dev/null|grep -i running)" ]; then
    g1;g2
    if [ "$(echo $g1|grep -i false)" ];then m="SYNCED";else m="SYNCING";fi
    m="$m $cunm $(date --rfc-3339=seconds)"
    n=$(echo $H|sudo -S grep -i 'new chain segment' /var/log/syslog 2>/dev/null|wc -l)
    [ -f /home/eth/geth.log ] && t=$(tail -n 1 /home/eth/geth.log|sed 's%.*segments: \([0-9]*\).*%\1%')
  fi
  if [ "$n" -eq "$t" ]; then
    m="BLOCKED $m"
    resolvectl query smtp.gmail.com 2>/dev/null 1>&2
  else
    m="OK $m"
  fi
}
function ok {
  t=-1;n=0;v=0;m=""
  if [ "$(systemctl status $etho 2>/dev/null|grep -i running)" ]; then
    o1;o2
    if [ "$(echo $o1|grep -i false)" ];then m="SYNCED";else m="SYNCING";fi
    n=$(echo $H|sudo -S grep -i 'Imported  *#' /var/log/syslog 2>/dev/null|wc -l)
    m="$m $cunm $(date --rfc-3339=seconds)"
    [ -f /home/eth/oeth.log ] && t=$(tail -n 1 /home/eth/oeth.log|sed 's%.*segments: \([0-9]*\).*%\1%')
  fi
  if [ "$n" -eq "$t" ]; then
    m="BLOCKED $m"
    resolvectl query smtp.gmail.com 2>/dev/null 1>&2
  else
    m="OK $m"
  fi
}
function grs {
  if [ $1 -ne 0 ]; then
    cp /etc/systemd/system/$ethg.service ~/$ethg.save
    g4=$(grep maxpeers ~/$ethg.save|sed 's%.*maxpeers \([0-9]*\).*%\1%')
    g4=$(($g4+$1))
    [ $g4 -ge 5 ] && [ $g4 -le 10 ] && sed "s%--maxpeers [0-9]*%--target-peers $g4%" ~/$ethg.save > /etc/systemd/system/$ethg.service
  fi
  gk
  echo -e "RSGE $m nodes: ${g2:-0}, segments: $n" >> /home/eth/geth.log
  gp;dr;sleep 50s;ga
}
function ors {
  if [ $1 -ne 0 ]; then
    cp /etc/systemd/system/$etho.service ~/$etho.save
    o4=$(grep max-peers ~/$etho.save|sed 's%.*max-peers=\([0-9]*\).*%\1%')
    o4=$(($o4+$1))
    [ $o4 -ge 10 ] && [ $o4 -le 15 ] && sed "s%--max-peers=[0-9]*%--max-peers=$o4%" ~/$etho.save > /etc/systemd/system/$etho.service
  fi
  ok
  echo -e "RSOE $m nodes: ${o2:-0}, segments: $n" >> /home/eth/oeth.log
  op;dr;oa
}
function bk {
  t=0;y=0;v=0;x=0;m=""
  for v in $(echo $H|sudo -S grep -i 'inclusion_lag: [1-9][0-9]*' /var/log/syslog 2>/dev/null|sed 's%.*inclusion_lag: *\([0-9]*\).*%\1%')
  do y=$(($y+1));t=$(($t+$v))
  done
  x=0
  [ "$y" -gt 0 ] && x=$(($t/$y))
  t=0;n=0;v=0;z=0;a=0;p=0;b=0;d=0;h=0;r=0
  for v in $(echo $H|sudo -S grep -i 'gossip' /var/log/syslog 2>/dev/null|sed 's%.*delay_ms: *\([0-9]*\).*%\1%')
  do n=$(($n+1));t=$(($t+$v))
  done
  v=0
  [ "$n" -gt 0 ] && v=$(($t/$n))
  a=$(echo $H|sudo -S grep -i 'attestation success' /var/log/syslog 2>/dev/null|wc -l)
  t=$(echo $H|sudo -S grep -i 'lighthouse'          /var/log/syslog 2>/dev/null|grep    ' INFO '|wc -l)
  r=$(echo $H|sudo -S grep -i 'lighthouse'          /var/log/syslog 2>/dev/null|grep -v ' INFO '|wc -l)
  h=$(echo $H|sudo -S grep -i 'to an incorrect'     /var/log/syslog 2>/dev/null|wc -l)
  z=$(echo $H|sudo -S grep -i 'attestation missing' /var/log/syslog 2>/dev/null|wc -l)
  p=$(echo $H|sudo -S grep -i 'published block'     /var/log/syslog 2>/dev/null|wc -l)
  if [ "$2" ]; then
    resolvectl query pro-api.coinmarketcap.com 2>/dev/null 1>&2
    #resolvectl query beaconcha.in              2>/dev/null 1>&2
    e=$(curl -sX GET "https://pro-api.coinmarketcap.com/v1/cryptocurrency/quotes/latest?symbol=ETH&convert=EUR&CMC_PRO_API_KEY=3ae5f3df-bd71-489d-a9dd-b626995fba31"|sed 's%.*price.:\([0-9]*\.[0-9]*\).*%\1%')
    #n=$(curl -sX GET "https://beaconcha.in/api/v1/validator/11766,11767,11770,11771,11772,11773,11774,11775,11776,11777,11778,11779,11780,11782,11783,11784,11786,11788/performance" -H "accept: application/json")
    #b=$(echo "$n"|python3 -c "$(echo -e "import sys, json\nt=0\nfor x in json.load(sys.stdin)['data']: t=t+x['performance1d']\nprint(t)")")
    #b=$(echo "scale=0;$b*$e/1000000000"|bc)
  else
    e=3000
  fi
  b=$(echo "scale=0;($p*$rblk+$a*$ratt)*$e/1000000000"|bc)
  d=$(echo "scale=2;($h*$pinc+$z*$patt)*$e/1000000000"|bc)
  g3
  m="$cunm $(date --rfc-3339=seconds)"
  if [ "${1:-k}" = "k" ]; then
    m="$m\n\nREWARDS PENALTIES\t$b€\t$d€"
    m="$m\nATTESTATIONS BLOCKS\t$a $p"
    m="$m\nINCORRECT MISSED\t$h $z"
    m="$m\nERRORS\t\t\t$r\t$t"
    m="$m\nNODES\t\t\t${g3:-0}"
    m="$m\nAVG LAGS\t\t$x"
    m="$m\nAVG DELAYS\t\t$v"
  else
    m="$m rewards_penalties: $b€ $d€,"
    m="$m attestations_blocks: $a $p,"
    m="$m incorrect_missed: $h $z,"
    m="$m erros: $r $t,"
    m="$m nodes: ${g3:-0},"
    m="$m avg_lags: $x,"
    m="$m avg_delays: $v"
  fi
  n=0
  [ "$(($a+$p+$t))" -gt 0 ] && n=$(($x*($h+$z+$r)/($a+$p+$t)))
  if [ "${n:-0}" -ge $lirs ] && [ -f /home/eth/beacon.log ] && [ "$(tail -n $hors /home/eth/beacon.log|cut -d' ' -f1|sort -u)" = "BEAC" ]; then
    m="BLOCKED $n $m"
    resolvectl query smtp.gmail.com 2>/dev/null 1>&2
  else
    m="OK $n $m"
  fi
}
function brs {
  b0=$(systemctl status $ethb 2>/dev/null|grep PID|sed 's%.*PID: *\([0-9]*\).*%\1%')
  b1=0
  while [ $b1 -lt 200 ]; do
    b2="$(echo $H|sudo -S grep "lighthouse.$b0" /var/log/syslog 2>/dev/null|grep ' INFO '|tail -n $pors|cut -d' ' -f10|sort -u)"
    if [ "$(echo "$b2"|head -n 1)" = "New" ] && [ "$(echo "$b2"|tail -n 1)" = "Synced" ]; then
      if [ $1 -ne 0 ]; then
        cp /etc/systemd/system/$ethb.service ~/$ethb.save
        b3=$(grep target-peers ~/$ethb.save|sed 's%.*target-peers \([0-9]*\).*%\1%')
        b3=$(($b3+$1))
        [ $b3 -ge 10 ] && [ $b3 -le 30 ] && sed "s%--target-peers [0-9]*%--target-peers $b3%" ~/$ethb.save > /etc/systemd/system/$ethb.service
      fi
      bk l
      echo -e "RSBN $m" >> /home/eth/beacon.log
      bp;dr;ba;
      b1=200
    fi
    sleep 3s
    b1=$(($b1+1))
  done
}
function bs {
  for l in $(echo $H|sudo -S grep -i 'lighthouse.*incorrect' /var/log/syslog 2>/dev/null|sed 's%.* \([0-9]*:[0-9]*:[0-9]*\) .*validator: \([0-9]*\).*epoch: \([0-9]*\).*%\1:\2:\3%'|sort -u|tail -n $1);do
    v=$(echo $l|cut -d: -f4)
    e=$(echo $l|cut -d: -f5)
    s=$(sudo grep -i "lighthouse.*attestation.*$v.*slot.*$e" /var/log/syslog|sed 's%.*slot: \([0-9]*\).*%\1%'|sort -u)
    echo -e "${i}VALIDATOR $v, EPOCH $e, SLOT $s${f}"
    sudo grep "$v.*$e\|$s" /var/log/syslog
  done
}

[ "$1" = "rs"  ] && { rs; }
[ "$1" = "ds"  ] && { ds; }
[ "$1" = "rq"  ] && { rq $2; }
[ "$1" = "cr"  ] && { cr; }
#[ "$1" = "cf"  ] && { cf; }
#[ "$1" = "crf" ] && { cr;cf; }
[ "$1" = "sr"  ] && { sr;sf; }
[ "$1" = "gk"  ] && { gk     ;echo -e "GETH $m \n\nNODES\t\t${g2:-0}\nSEGMENTS\t$n"; }
[ "$1" = "ok"  ] && { ok     ;echo -e "OETH $m \n\nNODES\t\t${o2:-0}\nSEGMENTS\t$n"; }
[ "$1" = "gl"  ] && { gk     ;echo -e "GETH $m nodes: ${g2:-0}, segments: $n"; }
[ "$1" = "ol"  ] && { ok     ;echo -e "OETH $m nodes: ${o2:-0}, segments: $n"; }
[ "$1" = "gh"  ] && { tail -n ${2:-$hors} /home/eth/geth.log;gk;echo -e "GETH $m nodes: ${g2:-0}, segments: $n"; }
[ "$1" = "oh"  ] && { tail -n ${2:-$hors} /home/eth/oeth.log;ok;echo -e "OETH $m nodes: ${o2:-0}, segments: $n"; }
[ "$1" = "gkr" ] && { gk     ;[ "$(echo $m|sed 's%\([A-Z]*\) .*%\1%')" != "OK" ] && grs ${2:-0}; }
[ "$1" = "okr" ] && { ok     ;[ "$(echo $m|sed 's%\([A-Z]*\) .*%\1%')" != "OK" ] && ors ${2:-0}; }
[ "$1" = "grs" ] && { grs ${2:-0}; }
[ "$1" = "ors" ] && { ors ${2:-0}; }
[ "$1" = "bk"  ] && { bk k $2;echo -e "BEAC $m"; }
[ "$1" = "bl"  ] && { bk l $2;echo -e "BEAC $m"; }
[ "$1" = "bh"  ] && { tail -n ${2:-$hors} /home/eth/beacon.log;bk l;echo -e "BEAC $m"; }
[ "$1" = "bkr" ] && { bk l   ;[ "$(echo $m|sed 's%\([A-Z]*\) .*%\1%')" != "OK" ] && brs ${2:-0}; }
[ "$1" = "brs" ] && { brs ${2:-0}; }
[ "$1" = "bs"  ] && { bs  ${2:-1}; }

# lista servicos
[ "$1" = "ll" ] && { uu "systemctl list-units $pate $patp $patf"; }
# lista portas
[ "$1" = "lp" ] && { netstat -tulpn; }
# outros journal system/lighthouse
[ "$1" = "el" ] && { echo $H|sudo -S grep -i 'openethereum\|geth\[\|lighthouse'      /var/log/syslog 2>/dev/null|if [ "$2" ];then grep -i "[a-z]* [0-9]* $2";else grep -v ' INFO ';fi; }
[ "$1" = "sl" ] && { echo $H|sudo -S grep -v 'openethereum\|geth\[\|lighthouse\|UFW' /var/log/syslog 2>/dev/null|if [ "$2" ];then grep -i "[a-z]* [0-9]* $2";else grep -i 'error' ;fi; }
#[ "$1" = "bl" ] && { echo $H|sudo -S grep -i 'Successfully published block' /var/log/syslog 2>/dev/null; }
#[ "$1" = "nr" ] && { ut "grep -i record /var/log/syslog" "${2:-30}"; }
[ "$1" = "np" ] && { g2;g3;echo -e "PEERS: GETH ${g2:-0}, BEACON ${g3:-0}"; }
[ "$1" = "gs" ] && { gs;echo -e $m; }
[ "$1" = "ws" ] && { uu "ufw status numbered"; }
[ "$1" = "wa" ] && if [ "$(echo $H|sudo -S ufw status 2>/dev/null|grep -i inactive)" ];then echo -e "${i}ARRANCA FIREWALL${f}";sudo ufw enable; else echo -e "${i}FIREWALL JA ACTIVE${f}";fi
[ "$1" = "wpr" ] && { uu "ufw disable"; }

# journal
[ "$1" = "yj" ] && { jb; }
[ "$1" = "ej" ] && { jb "-u $pate"; }
[ "$1" = "gj" ] && { jb "-u $ethg"; }
[ "$1" = "oj" ] && { jb "-u $etho"; }
[ "$1" = "bj" ] && { jb "-u $ethb"; }
[ "$1" = "vj" ] && { jb "-u $ethv"; }
[ "$1" = "pj" ] && { jb "-u $ethp"; }
[ "$1" = "nj" ] && { jb "-u $ethn"; }
[ "$1" = "fj" ] && { jb "-u $ethf"; }
[ "$1" = "xj" ] && { jb "-u $plex"; }
[ "$1" = "rj" ] && { jb "-u $trrt"; }
[ "$1" = "sj" ] && { jb "-u $dnsd"; }
# arranca
[ "$1" = "ga" ] && { dr;ga; }
[ "$1" = "oa" ] && { dr;oa; }
[ "$1" = "ba" ] && { dr;ba; }
[ "$1" = "va" ] && { dr;va; }
[ "$1" = "pa" ] && { dr;pa; }
[ "$1" = "na" ] && { dr;na; }
[ "$1" = "fa" ] && { dr;fa; }
[ "$1" = "xa" ] && { dr;xa; }
[ "$1" = "ra" ] && { dr;ra; }
[ "$1" = "sa" ] && { dr;sa; }
# para & arranca & journal
[ "$1" = "gaj" ] && { dr;ga;jb "-u $ethg"; }
[ "$1" = "oaj" ] && { dr;oa;jb "-u $etho"; }
[ "$1" = "baj" ] && { dr;ba;jb "-u $ethb"; }
[ "$1" = "vaj" ] && { dr;va;jb "-u $ethv"; }
[ "$1" = "saj" ] && { dr;sa;jb "-u $dnsd"; }
[ "$1" = "gpa" ] && { gp;dr;ga;jb "-u $ethg"; }
[ "$1" = "opa" ] && { op;dr;oa;jb "-u $etho"; }
[ "$1" = "bpa" ] && { bp;dr;ba;jb "-u $ethb"; }
[ "$1" = "vpa" ] && { vp;dr;va;jb "-u $ethv"; }
[ "$1" = "xpa" ] && { xp;xa; }
[ "$1" = "rpa" ] && { rp;ra; }
[ "$1" = "spa" ] && { sp;sa;jb "-u $dnsd"; }
[ "$1" = "gpd" ] && { gp;gd; }
[ "$1" = "opd" ] && { op;od; }
[ "$1" = "bpd" ] && { bp;bd; }
[ "$1" = "vpd" ] && { vp;vd; }
[ "$1" = "xpd" ] && { xp;xd; }
[ "$1" = "rpd" ] && { rp;rd; }
[ "$1" = "spd" ] && { sp;sd; }
[ "$1" = "gea" ] && { ge;dr;ga;jb "-u $ethg"; }
[ "$1" = "oea" ] && { oe;dr;oa;jb "-u $etho"; }
[ "$1" = "bea" ] && { be;dr;ba;jb "-u $ethb"; }
[ "$1" = "vea" ] && { ve;dr;va;jb "-u $ethv"; }
[ "$1" = "xea" ] && { xe;xa; }
[ "$1" = "rea" ] && { re;ra; }
[ "$1" = "sea" ] && { se;sa;jb "-u $dnsd"; }
# enable
[ "$1" = "ge" ] && { ge; }
[ "$1" = "oe" ] && { oe; }
[ "$1" = "be" ] && { be; }
[ "$1" = "ve" ] && { ve; }
[ "$1" = "pe" ] && { pe; }
[ "$1" = "ne" ] && { ne; }
[ "$1" = "fe" ] && { fe; }
[ "$1" = "xe" ] && { xe; }
[ "$1" = "re" ] && { re; }
[ "$1" = "se" ] && { se; }
# para
[ "$1" = "fpr" ] && { fp; }
[ "$1" = "npr" ] && { np; }
[ "$1" = "ppr" ] && { pp; }
[ "$1" = "vpr" ] && { vp; }
[ "$1" = "bpr" ] && { bp; }
[ "$1" = "gpr" ] && { gp; }
[ "$1" = "opr" ] && { op; }
[ "$1" = "xpr" ] && { xp; }
[ "$1" = "rpr" ] && { rp; }
[ "$1" = "spr" ] && { sp; }
# disable
[ "$1" = "fds" ] && { fd; }
[ "$1" = "nds" ] && { nd; }
[ "$1" = "pds" ] && { pd; }
[ "$1" = "vds" ] && { vd; }
[ "$1" = "bds" ] && { bd; }
[ "$1" = "gds" ] && { gd; }
[ "$1" = "ods" ] && { od; }
[ "$1" = "xds" ] && { xd; }
[ "$1" = "rds" ] && { rd; }
[ "$1" = "sds" ] && { sd; }

if [ -z "$1" ]; then
  c1="\nprimeira letra"
  c1="$c1\ne\t\t$ethg $ethb $ethv"
  c1="$c1\ng\t\t$ethg"
  c1="$c1\no\t\t$etho"
  c1="$c1\nb\t\t$ethb"
  c1="$c1\nv\t\t$ethv"
  c1="$c1\np\t\t$ethp"
  c1="$c1\nn\t\t$ethn"
  c1="$c1\nf\t\t$ethf"
  c1="$c1\nx\t\t$plex"
  c1="$c1\nr\t\t$trrt"
  c1="$c1\ns\t\t$dnsd"
  c1="$c1\n"
  c1="$c1\nsegunda letra"
  c1="$c1\na\t\tarranca"
  c1="$c1\naj\t\tarranca\t& journal"
  c1="$c1\ne\t\tenable"
  c1="$c1\nj\t\tjournal"
  c1="$c1\npr\t\tpara"
  c1="$c1\nds\t\tdisable"
  c1="$c1\npd\t\tpara\t& disable"
  c1="$c1\npa\t\tpara\t& arranca\t& journal"
  c1="$c1\nea\t\tenable\t& arranca\t& journal"
  c1="$c1\nk [s]\t\tcheck s=curl"
  c1="$c1\nl [s]\t\tlog   s=curl"
  c1="$c1\n"
  c1="$c1\noutros"
  c1="$c1\nyj\t\tsystem journal"
  c1="$c1\nsl [s]\t\tlista system journal  s=TOTAL"
  c1="$c1\nel [s]\t\tlista geth,lighthouse s=TOTAL"
  c1="$c1\nbs [n]\t\tlista erros com custo n=max erros"
  c1="$c1\nll\t\tlista servicos"
  c1="$c1\nlp\t\tlista portas"
  c1="$c1\nnp\t\tnode peers"
#  c1="$c1\nnr\t\tnode record"
  c1="$c1\ngs\t\tgeth syncing"
  c1="$c1\ngkr\t\tgeth check/reset (if necessary)"
  c1="$c1\nws\t\tfirewall status"
  c1="$c1\nwa\t\tfirewall arranca"
  c1="$c1\nwpr\t\tfirewall para"
  c1="$c1\ncr\t\tchange route"
#  c1="$c1\ncf\t\tchange forwarders"
#  c1="$c1\ncrf\t\tchange route & forwarders"
  c1="$c1\nsr\t\tshow route & DNS"
  c1="$c1\nrs\t\treset netplan\t& systemd-resolved"
  c1="$c1\nds\t\treset dns\t& systemd-resolved"
  c1="$c1\nrq\t\tdns query"
  echo -e "\n$c1\n"
fi
