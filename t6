#!/bin/bash

source /home/eth/eth2/t1

# utilities for commands/journal
function nu0 { if [ ${1:-0} -eq $1 ] 2>/dev/null;then echo $1;else echo 0;fi; }                                                # force numeric output
function nu1 { echo "scale=$2;$1"|bc; }                                                                                        # arbitrary precision calculations
function nu2 { printf ${3:-%.0f} $(nu1 $1 ${2:-0}); }                                                                          # format arbitrary precision calculations
function nu3 { if [[ $3 -gt $1 ]];then echo $(($2/$3));else echo 0;fi; }                                                       # targeted division for beacon restart index
function nu4 { if [[ ${5:-1} -ne 0 ]];then nu1 "($1*$pmis+$2*$pmat+$3*$pmah+$4*$pdly)/${5:-1}*$rate/$decp" 2;else echo 0;fi; } # penalty calculator for beacon log ordering
function dts { date '+%Y-%m-%d %H:%M:%S'; }
function pst { systemctl status $1 2>/dev/null; }
function pwr { systemctl status $1 2>/dev/null|grep "${2:-inactive\|failed}"; }
function eip { curl -s4 "http://${1}:${2}@dyn.dns.he.net/nic/update?hostname=${1}" 2>/dev/null 1>&2; }
function cex { echo -e "${i}$1${f}";echo $H|sudo -S $1 2>/dev/null; }
function sex { echo $H|sudo -S $1 2>/dev/null 1>&2; }
function jsh { cex "journalctl --no-hostname --no-full -f $1"; }
function rdn { cex "systemctl stop $dnsd";sex 'systemctl stop systemd-resolved';cex "systemctl start $dnsd";sex 'systemctl start systemd-resolved'; }
function dmr { sex "systemctl daemon-reload"; }
function dsh { echo -e "\nresolvectl query $1";resolvectl query "$1"; }
function drs { echo -e 'RESET DNS'                              ;rdn; }
function nrs { echo -e 'RESET NETPLAN & DNS';cex 'netplan apply';rdn; }
function sst { echo "$1 $(printf '%6s' $(echo "$2"|grep Memory:|sed 's%.*Memory: \(.*\)%\1%')) $(dts) status: $(echo "$2"|grep Active:|sed 's%.*Active: \(.*\)%\1%')"; }
function dnn { echo "$1 $2 $(printf 'node%02i:' $3) $(printf '%2i' $4)"; }
# geth error control functions
function gv { nu0 $(pst $ethg|grep maxpeers|sed 's%.*--maxpeers \([0-9]*\).*%\1%'   ); }          # configured peers
function gq { nu0 $(geth attach "http://$cgth:8545" --exec net.peerCount 2>/dev/null); }          # current peers
function gy { geth attach "http://$cgth:8545" --exec eth.syncing         2>/dev/null ; }          # current syncing status
function gb {
  g0=$(echo $H|sudo -S grep 'mported new' $p4 2>/dev/null|wc -l);ok='OK'                          # g0 numero de new imported chain segments
  [[ $g0 -eq $(grep sgs: $p5 2>/dev/null|tail -n1|sed 's%.*sgs: *\([0-9]*\).*%\1%') ]] && ok='BK' # ok OK/BK blocked
}
function gl {
  if [[ $(pwr $ethg running) ]];then
    local e=$(gy);gb
    if [[ $(echo $e|grep false) ]];then
      m=" $ok SYC $(dnn $(dts) $(gv) $(gq)) sgs: $(printf '%4i' $g0)"                             # GETH OK SYC 2021-12-04 17:40:50 node10:  7 sgs: 4726
    else
      local g=$(echo $e|sed -Ee 's%.*highestBlock: *([0-9]+).*%\1%i');local n=$(echo $e|sed -Ee 's%.*currentBlock: *([0-9]+).*%\1%i')
      m=" $ok NSY $(dnn $(dts) $(gv) $(gq)) sgs: $(printf '%4i' $g0) blocks: $((g*1)) ($((g-n)))" # GETH OK NSY 2021-12-04 17:40:37 node10:  4 sgs: 4725 blocks: 13741168 (6)
    fi
  else
    m=" NOT HERE $(dts)"
  fi
}
function grs {
  local n=$(gv)
  if [[ $1 -ne 0 ]];then # [+/-$1] alteracao configured peers
    cp /etc/systemd/system/$ethg.service ~/$ethg.save
    n=$(($1+n));[[ $n -ge 10 && $n -le 15 ]] && sed "s%--maxpeers [0-9]*%--maxpeers $n%" ~/$ethg.save > /etc/systemd/system/$ethg.service
  fi
  resolvectl query smtp.gmail.com 2>/dev/null 1>&2
  sex "systemctl stop $ethg";dmr;sex "systemctl start $ethg";sleep 10s;echo "GETH RESTAR $(dnn $(dts) $n $(gq))" >> $p5 # restart servico geth
}
# beacon error control functions
function bv { nu0 $(pst $ethb|grep target-peers|sed 's%.*--target-peers \([0-9]*\).*%\1%')                                ; } # configured peers
function bq { nu0 $(echo $H|sudo -S grep 'lighthouse.*peers:' $p4 2>/dev/null|tail -n1|sed 's%.*peers: *\([0-9]*\).*%\1%'); } # current peers
function bi { nu4 ${k[$1]} ${z[$1]} ${x[$1]} ${w[$1]} ${c[$1]}; }                                                             # avg penalty from cumulative paid error arrays
function bx { echo $1|sed 's%node\([0-9]*\):%\1%'; }                                                                          # configured peers extraction from node tag
function bz { echo $((10*(9*z6+3*z7+z8+z9))); }                                                                               # numerator paid errors restart index
function bw { echo $((10*z1)); }                                                                                              # numerator processed blocks restart index
function br { echo $((90*z3)); }                                                                                              # numerator general errors restart index
function bu { echo $(($(nu3 200 $(bz) $z5)+$(nu3 100 $(bw) $z2)+$(nu3 100 $(br) $z4))); }                                     # restart index
function bs { tail -n$1 $p2 2>/dev/null|cut -d' ' -f1|sort -u|wc -l; }                                                        # log restart activity test
function bk { cat       $p2 2>/dev/null|                      wc -l; }                                                        # log line count
function bb {
  local e=$(echo $H|sudo -S grep "lighthouse.$bpid" $p4 2>/dev/null|tail -n3600)
  z1=$(echo "$e"|grep 'rocessed block'|wc -l);z2=$(echo "$e"|grep 'block received'|wc -l);z3=$(echo "$e"|grep -v ' INFO '|wc -l);z4=$(echo "$e"|grep ' INFO '|wc -l)
  z5=$(echo $(echo $H|sudo -S grep 'attestation(s) success' $p4 2>/dev/null|sed 's%.*validators: *\[\(.*\)\].*%\1%;s%[,"]%%g')|wc -w)
  z6=$(echo $(echo $H|sudo -S grep 'attestation(s) missing' $p4 2>/dev/null|sed 's%.*validators: *\[\(.*\)\].*%\1%;s%[,"]%%g')|wc -w)
  z7=$(echo $(echo $H|sudo -S grep 'attestation(s).*target' $p4 2>/dev/null|sed 's%.*validators: *\[\(.*\)\].*%\1%;s%[,"]%%g')|wc -w)
  z8=$(echo $(echo $H|sudo -S grep 'attestation(s).*head'   $p4 2>/dev/null|sed 's%.*validators: *\[\(.*\)\].*%\1%;s%[,"]%%g')|wc -w)
  z9=$(echo $(echo $H|sudo -S grep 'attestation(s) had'     $p4 2>/dev/null|sed 's%.*validators: *\[\(.*\)\].*%\1%;s%[,"]%%g')|wc -w)
  ok='OK';local g=$(bu);[[ $g -ge $l1rs ]] && if [[ $g -ge $l2rs ]];then [[ $(bs $l2rs) -eq 1 ]] && ok='BK';else [[ $(bs $hors) -eq 1 ]] && ok='BK';fi
}
function bl {
  b6=$(echo $H|sudo -S grep 'ublished block' $p4 2>/dev/null|wc -l);b5=0;local l=0;local n=0;local v=0
  for v in $(echo $H|sudo -S grep 'src: gossip,' $p4 2>/dev/null|sed 's%.*delay_ms: *\([0-9]*\).*%\1%');do n=$((n+1));l=$((l+v));done
  if [[ $n -gt 0 ]];then b5=$((l/n));dt=$(dts);nn=$(bv);nr=$(bq);bb;blo;else m=" NOT HERE $(dts)";fi
}
function bm {
  bm0;dt=$(dts);nn=$(bv);nr=$(bq);local g=0
  if [[ -f $p7 ]];then
    unset o;read -a o <<< $(tail -n1 $p7);g=${o[1]}
    k[50]=${o[13]};k[45]=${o[14]};k[40]=${o[15]};k[35]=${o[16]};k[30]=${o[17]};k[25]=${o[18]};k[20]=${o[19]}
    z[50]=${o[21]};z[45]=${o[22]};z[40]=${o[23]};z[35]=${o[24]};z[30]=${o[25]};z[25]=${o[26]};z[20]=${o[27]}
    x[50]=${o[29]};x[45]=${o[30]};x[40]=${o[31]};x[35]=${o[32]};x[30]=${o[33]};x[25]=${o[34]};x[20]=${o[35]}
    w[50]=${o[37]};w[45]=${o[38]};w[40]=${o[39]};w[35]=${o[40]};w[30]=${o[41]};w[25]=${o[42]};w[20]=${o[43]}
    c[50]=${o[ 5]};c[45]=${o[ 6]};c[40]=${o[ 7]};c[35]=${o[ 8]};c[30]=${o[ 9]};c[25]=${o[10]};c[20]=${o[11]}
  fi
  [[ -f $p2 ]] && { unset v;while read -a v;do bm1;done <<< $(tail -n$(($(bk)-g)) $p2|grep BEAC); };bm2;[[ ${b2:-0} -eq 0 ]] && bo1
  local l=0;local n=0;[[ -f $p3 ]] && { unset v;while read -a v;do l=$((${v[2]}+l));n=$((1+n));done <<< $(cat $p3); };b3=$(nu2 "($l+$b2)/(1+$n)" 5)
  b4=0;bmn ${a[$nn]};[[ $b2 -le $b3 || $(bs $hors) -gt 1 ]] && b4=0;bmo;bno
}
function bh {
  tail -n${1:-$hors} $p2
  [[ $1 ]] || { bo1;echo -e "BO$(printf '%5i' $(echo "$b1"|wc -l)) $(printf '%3i' $b2)";bo2; }
  [[ $1 ]] || { bl ;echo -e "BL$(printf '%9i' $(cat $p2 2>/dev/null|wc -l))\nBEAC$m"; }
  [[ $1 ]] || { bm ;echo -e "BM$(printf '%9i' $(cat $p3 2>/dev/null|wc -l))\nBEAC$m"; }
  [[ $1 ]] || { sst BEAC "$(pst $ethb)";sst VALI "$(pst $ethv)"; }
}
function blo {
  #    0  1   2          3              4       5  6               7   8    9                 10   11  12 13    14 15 16  17 18     19  20  21   22   23   24         25   26
  # BEAC OK   0 2021-11-22 17:15:58+00:00 node00: 32 reward_penalty: 224 3.54 attestation_block: 2950 2280 0 erros: 2 14 131 29      0 537   0   14 3586 1260     delay: 1000
  m=" $ok $(printf '%3i' $(bu)) $dt $(printf 'node%02i:' $nn) $(printf '%2i' $nr) reward_penalty: $(nu2 "($z5*$ratt+$b6*$rblk)*$rate/$decp" 0 %3i) $(printf '%4.2f' $(nu4 $z6 $z7 $z8 $z9))"
  m="$m attestation_block: $(printf '%4i' $z5) $(printf '%4i' $(bz)) $(printf '%1i' $b6) erros: $(printf '%1i' $z6) $(printf '%2i' $z7) $(printf '%3i' $z8)"
  m="$m $(printf '%2i' $z9) $(printf '%6i' $z1) $(printf '%3i' $z2) $(printf '%3i' $(bw)) $(printf '%4i' $z3) $(printf '%4i' $z4) $(printf '%4i' $(br))     delay: $(printf '%4i' $b5)"
}
# recursively compare avg penalty array with current penalty
function bmn { local g=$1;local n=${2:-20};if [[ $(nu2 ${a[$n]}*100) -lt $(nu2 $g*100) ]];then b4=$((n-nn));g=${a[$n]};fi;[[ $n -lt 50 ]] && bmn $g $((n+5)); }
function bmo {
  #    0  1   2          3        4       5  6    7    8    9   10   11   12   13   14          15   16          17 18
  # BEAC  6   2 2021-12-06 09:54:17 node40: 43 avg: 2.63 2.89 1.49 2.24 2.65 1.95 1.97 global_avg: 2.06 peer_change: 0
  m=" $(printf '%2i' $b3) $(printf '%3i' $b2) $dt $(printf 'node%02i:' $nn) $(printf '%2i' $nr) avg: $(printf '%4.2f' ${a[50]}) $(printf '%4.2f' ${a[45]}) $(printf '%4.2f' ${a[40]})"
  m="$m $(printf '%4.2f' ${a[35]}) $(printf '%4.2f' ${a[30]}) $(printf '%4.2f' ${a[25]}) $(printf '%4.2f' ${a[20]}) global_avg: $(printf '%4.2f' ${a[00]}) peer_change: $b4"
}
function bno {
  #    0   1          2              3    4 5 6 7 8 9 0   1    2 3 4 5 6 7 8   9    0 1 2 3 4 5 6    7    8 9 0 1 2 3 4     5    6 7 8 9 0 1 2    3
  # BEAC 400 2021-11-14 16:52:36+00:00 cnt: 0 0 0 0 0 0 411 mis: 0 0 0 0 0 0 625 mat: 0 0 0 0 0 0 3501 mah: 0 0 0 0 0 0 25550 dly: 0 0 0 0 0 0 3941
  s=" $(bk) $dt cnt: ${c[50]} ${c[45]} ${c[40]} ${c[35]} ${c[30]} ${c[25]} ${c[20]}"
  s="$s mis: ${k[50]} ${k[45]} ${k[40]} ${k[35]} ${k[30]} ${k[25]} ${k[20]} mat: ${z[50]} ${z[45]} ${z[40]} ${z[35]} ${z[30]} ${z[25]} ${z[20]}"
  s="$s mah: ${x[50]} ${x[45]} ${x[40]} ${x[35]} ${x[30]} ${x[25]} ${x[20]} dly: ${w[50]} ${w[45]} ${w[40]} ${w[35]} ${w[30]} ${w[25]} ${w[20]}"
}
function bm0 {
  unset k;k[00]=0;k[50]=0;k[45]=0;k[40]=0;k[35]=0;k[30]=0;k[25]=0;k[20]=0;unset z;z[00]=0;z[50]=0;z[45]=0;z[40]=0;z[35]=0;z[30]=0;z[25]=0;z[20]=0
  unset x;x[00]=0;x[50]=0;x[45]=0;x[40]=0;x[35]=0;x[30]=0;x[25]=0;x[20]=0;unset w;w[00]=0;w[50]=0;w[45]=0;w[40]=0;w[35]=0;w[30]=0;w[25]=0;w[20]=0
  unset c;c[00]=0;c[50]=0;c[45]=0;c[40]=0;c[35]=0;c[30]=0;c[25]=0;c[20]=0;unset a;a[00]=0;a[50]=0;a[45]=0;a[40]=0;a[35]=0;a[30]=0;a[25]=0;a[20]=0
}
function bm1 { local n=$(bx ${v[5]});k[$n]=$((k[n]+v[15]));z[$n]=$((z[n]+v[16]));x[$n]=$((x[n]+v[17]));w[$n]=$((w[n]+v[18]));c[$n]=$((c[n]+1)); }
function bm2 {
  k[00]=$((k[20]+k[25]+k[30]+k[35]+k[40]+k[45]+k[50]));z[00]=$((z[20]+z[25]+z[30]+z[35]+z[40]+z[45]+z[50]))
  x[00]=$((x[20]+x[25]+x[30]+x[35]+x[40]+x[45]+x[50]));w[00]=$((w[20]+w[25]+w[30]+w[35]+w[40]+w[45]+w[50]))
  c[00]=$((c[20]+c[25]+c[30]+c[35]+c[40]+c[45]+c[50]));a[00]=$(bi 00);a[20]=$(bi 20);a[25]=$(bi 25);a[30]=$(bi 30);a[35]=$(bi 35);a[40]=$(bi 40);a[45]=$(bi 45);a[50]=$(bi 50)
}
function bo1 {
  b2=0
  if [[ -f $p2 ]];then
    local e='00:00';local l=$(grep BEAC $p2|tail -n1|sed 's%.* \([0-9]*-[0-9]*-[0-9]*\) \([0-9]*:[0-9]*\):.*%\1 \2%');local d=$(echo $l|cut -d' ' -f1);local n=0
    if [[ $(echo $1|egrep '^[0-9]+:[0-9]+$') ]];then e=$1 ;else if [[ $(echo $2|egrep '^[0-9]+:[0-9]+$') ]];then e=$2 ;else e=$(echo $l|cut -d' ' -f2);fi;fi;b1=$(grep "BEAC.*$e" $p2)
    if [[ $(echo $1|egrep '^[0-9]+$')        ]];then b2=$1;else if [[ $(echo $2|egrep '^[0-9]+$')        ]];then b2=$2;else b2=$(echo "$b1"|sort -k10.1n|grep -n $d|cut -d: -f1);fi;fi
    while [[ ${b2:-0} -eq 0 && $n -lt 50 ]];do n=$((n+1));d=$(date -d "$n days ago $e" '+%Y-%m-%d');b2=$(echo "$b1"|sort -k10.1n|grep -n $d|cut -d: -f1);done
  fi
}
function bo2 {
  if [[ -f $p2 ]];then
    local e=${b2:-0};local d=${b2:-0}
    if [[ $(echo $1|egrep '^[0-9]+$') ]];then e=$1;else if [[ $e -lt $l2rs && $(echo "$b1"|wc -l) -ge $l2rs ]];then d=$l2rs;e=$l2rs;fi;fi
    if [[ $(echo $1|egrep '^[0-9]+$') ]];then d=$1;else if [[ $d -gt $hors ]];then d=$hors;fi;fi
    echo "$b1"|sort -k10.1n|head -n$e|tail -n$d
  fi
}
function brl {
  [[ -f ${p2}new ]] && rm ${p2}new;[[ -f ${p3}new ]] && rm ${p3}new
  unset v;while read -a v;do ok=${v[1]};dt=${v[3]}\ ${v[4]};nn=$(bx ${v[5]});nr=${v[6]}
    if [[ ${v[0]} = BEAC ]];then # published block/delay/processed block/block received/not INFO/INFO/attestation/erros missing/erros target/erros head/erros had
      b6=${v[13]};b5=${v[26]};z1=${v[19]};z2=${v[20]};z3=${v[22]};z4=${v[23]};z5=${v[11]};z6=${v[15]};z7=${v[16]};z8=${v[17]};z9=${v[18]};blo
    else
      m=" $ok $(printf '%3i' ${v[2]}) $dt $(printf 'node%02i:' $nn) $(printf '%2i' $nr)"
    fi
    echo "${v[0]}$m" >> ${p2}new
  done <<< $(cat $p2)
  if [[ -f $p3 ]];then
    unset o;bm0;local d='0000-00-00';local e='23:58';local l=0;local n=0;local h=0;local g=0;while read -a o;do d=${o[3]};h=$g;g=$(grep -n "$d $e" ${p2}new|cut -d: -f1)
      dt=${o[3]}\ ${o[4]};nn=$(bx ${o[5]});nr=${o[6]};b2=$(head -n$g ${p2}new|grep "BEAC.*$e"|sort -k10.1n|grep -n $d|cut -d: -f1);l=$((b2+l));n=$((1+n));b3=$(nu2 $l/$n 5)
      unset v;while read -a v;do bm1;done <<< $(head -n$g ${p2}new|tail -n$((g-h))|grep BEAC);bm2;b4=${o[18]};bmo;echo "${o[0]}$m" >> ${p3}new
    done <<< $(cat $p3)
  fi
}
function bsl {
  [[ -f ${p2}new ]] && rm ${p2}new;[[ -f ${p7}new ]] && rm ${p7}new
  tail -n$(($(cat $p2|wc -l)-$(tail -n1 $p7|sed 's%  *%\t%g'|cut -f2))) $p2 > ${p2}new;head -n$(($(cat $p7|wc -l)-1)) $p7 > ${p7}new;tail -n1 $p7|sed 's%BEAC [0-9]*%BEAC 0%' >> ${p7}new
}
function bnl {
  [[ -f $p2 && -f ${p2}new ]] && { cp $p2 ${p2}sav;mv ${p2}new $p2; }
  [[ -f $p3 && -f ${p3}new ]] && { cp $p3 ${p3}sav;mv ${p3}new $p3; }
  [[ -f $p7 && -f ${p7}new ]] && { cp $p7 ${p7}sav;mv ${p7}new $p7; }
}
function brs {
  if [[ ! -f /home/eth/beacon.restart.inicio ]];then
    touch /home/eth/beacon.restart.inicio;local n=0
    while [[ -f /home/eth/beacon.restart.inicio && $n -lt 200 ]]; do
      local l=$(echo $H|sudo -S grep "lighthouse.$bpid.* INFO " $p4 2>/dev/null|tail -n$pors|sed 's%.* INFO \([^ ]*\) .*%\1%'|sort -u)
      if [[ $(echo "$l"|wc -l) -eq 2 && $(echo "$l"|tail -n1) = Synced && $(echo "$l"|head -n1) = New ]];then
        dt=$(dts);nn=$(bv);nr=$(bq);[[ $2 ]] && { ok=${2:0:2};ok=${ok^^}; }
        if [[ $1 -ne 0 ]];then
          cp /etc/systemd/system/$ethb.service ~/$ethb.save
          nn=$((nn+$1));[[ $nn -ge 20 && $nn -le 50 ]] && sed "s%--target-peers [0-9]*%--target-peers $nn%" ~/$ethb.save > /etc/systemd/system/$ethb.service
        fi
        resolvectl query smtp.gmail.com 2>/dev/null 1>&2
        sex "systemctl stop $ethb";[[ $2 = vcreset ]] && sex "systemctl stop $ethv";dmr;echo "RSTI $ok $(printf '%3i' $n) $dt $(printf 'node%02i:' $nn) $(printf '%2i' $nr)" >> $p2
        if [[ $2 = reboot ]];then
          rm -f /home/eth/beacon.restart.inicio;sex reboot
        else
          sex "systemctl start $ethb";[[ $2 = vcreset ]] && sex "systemctl start $ethv"
        fi
        rm -f /home/eth/beacon.restart.inicio
      fi
      sleep 3s;n=$((n+1))
    done
    rm -f /home/eth/beacon.restart.inicio
  fi
}
function ssp {
  echo -e "${i}QUER MESMO TRANSFERIR VALIDATORS?${f}";read rsp
  if [[ $rsp = sim && ! -f $dtdi/vc_slash && ! -f $dtdi/vc_lock && -f $dtdi/vc_keys ]];then
    vp;vd
    echo -e "${i}SAVE SLASHING PROTECTION DB${f}"
    echo $H|sudo -S cp $vldt/slashing_protection.sqlite /home/eth 2>/dev/null;sudo chown eth:eth /home/eth/slashing_protection.sqlite
    if [[ $cunm = $znm3 ]];then
      scp /home/eth/slashing_protection.sqlite vpss:~         ;echo -e "${i}SAVED SLASHING PROTECTION DB IN vpss${f}"
    else
      scp /home/eth/slashing_protection.sqlite ztc3.fruga.pt:~;echo -e "${i}SAVED SLASHING PROTECTION DB IN ztc3${f}"
    fi
  fi
}
function nsh {
  echo -e "ROUTES\t\t" $(ip route show|grep 'default via'|grep -v 'linkdown'|cut -d' ' -f3) "\nDNS\t\t" $(resolvectl|grep 'Current DNS'|cut -d' ' -f6)
  local v=0;for v in $(ip a|grep 'state UP'|cut -d: -f2);do echo -e "$v\t\t" $(resolvectl dns|grep $v|cut -d' ' -f4-6);done
}
function csh {
  local e='NO';[[ $(timedatectl|grep synchronized:|sed 's%.*synchronized: \([a-z]*\).*%\1%') = yes ]] && e='OK'
  echo "CLCK $e $(printf '%3i' $(echo $H|sudo -S grep 'check system clock' $p4 2>/dev/null|wc -l)) $(dts) status: $(pst systemd-timesyncd|grep Active:|sed 's%.*Active: \(.*\)%\1%')"
}
function esh {
  local l=$(echo $H|sudo -S grep -v 'geth\[\|lighthouse' $p4 2>/dev/null|grep -i 'error' |wc -l)
  local n=$(echo $H|sudo -S grep -i 'geth\[\|lighthouse' $p4 2>/dev/null|grep -v ' INFO '|wc -l)
  local e=$(echo $H|sudo -S grep -v 'geth\[\|lighthouse' $p4 2>/dev/null|grep -i 'error' |tail -n1|sed 's%.*hrv-zotac[0-9] *\(.*\)%\1%;s%:%%g;s%  *% %g'|cut -c1-53)
  local d=$(echo $H|sudo -S grep -i 'geth\[\|lighthouse' $p4 2>/dev/null|grep -v ' INFO '|tail -n1|sed 's%.*[0-9]*:[0-9]*:[0-9]*\.[0-9][0-9][0-9]]* *\(.*\)%\1%;s%:%%g;s%:%%g;s%  *% %g'|cut -c1-53)
  m="ERRO $(printf '%2i' $l) $(printf '%3i' $n) $(dts)";[[ $l -gt 0 ]] && m="$m sys: $e";[[ $n -gt 0 ]] && m="$m eth2: $d";echo "$m"
}
function psh {
  local l=0;local n=0
  local e=$(echo $H|sudo -S grep 'ture/speed normal' $p4 2>/dev/null|tail -n1|sed 's%.* \([0-9]*:[0-9]*:[0-9]*\).*%\1%');if [[ $e ]];then e="normal: $e"   ;else e='';fi
  local d=$(echo $H|sudo -S grep 'e above threshold' $p4 2>/dev/null|head -n1|sed 's%.* \([0-9]*:[0-9]*:[0-9]*\).*%\1%');if [[ $d ]];then d="throttled: $d";else d='';fi
  local v=0;for v in $(sensors 2>/dev/null|grep 'Package\|Core'|sed 's%.*: *\([-+][0-9][0-9]*\.[0-9]*\).*%\1%');do n=$((n+1));l=$(nu1 $l$v 1);done
  [[ $n -eq 0 ]] && n=1;echo "TEMP $(nu2 $l/$n 1 %5.1fC) $(dts) $d $e"
}
# Plex Media Server
function rxw { cex "ufw$2 allow from 192.168.8.0/24 $1"; }
function xop { cex 'ufw delete deny 32400             ';rxw 'to any port 32400 comment plex'; }
function xcl { cex 'ufw        deny 32400 comment plex';rxw 'to any port 32400 '   ' delete'; }
function xe  { xop;cex 'ufw reload';cex "systemctl enable $plex"; }
function xa  { [[ $(pwr $plex       ) ]] && { cex "systemctl start $plex"; } }
function xp  { [[ $(pwr $plex loaded) ]] && { cex "systemctl stop  $plex"; } }
function xd  { cex "systemctl disable $plex";xcl;cex 'ufw reload'; }
# Transmission BitTorrent Daemon
function rop { cex 'ufw allow 51413 comment torrent';rxw 'to any port 9091 comment torrent'; }
function rcl { cex 'ufw deny  51413 comment torrent';rxw 'to any port 9091'       ' delete'; }
function re  { rop;cex 'ufw reload';cex "systemctl enable $trrt"; }
function ra  { [[ $(pwr $trrt       ) ]] && { cex "systemctl start $trrt"; } }
function rp  { [[ $(pwr $trrt loaded) ]] && { cex "systemctl stop  $trrt"; } }
function rd  { cex "systemctl disable $trrt";rcl;cex 'ufw reload'; }
# Bind9
function sop { cex 'ufw delete deny 53            ';rxw 'to any port 53 comment dns'; }
function scl { cex 'ufw        deny 53 comment dns';rxw 'to any port 53 '  ' delete'; }
function se  { sop;cex 'ufw reload';cex "systemctl enable $dnsd"; }
function sa  { [[ $(pwr $dnsd disabled) ]] || { [[ $(pwr $dnsd) ]] && cex "systemctl start $dnsd"; } }
function sp  { [[ $(pwr $dnsd loaded  ) ]] && { cex "systemctl stop $dnsd"; } }
function sd  { cex "systemctl disable $dnsd";scl;cex 'ufw reload'; }
# open/close goethereum/beacon/validator/grafana
function gfw { if [[ $cust = hrv ]];then cex "ufw$2 allow from $zip2 $1";cex "ufw$2 allow from $zip3 $1";else cex "ufw$2 allow from $vip1 $1";cex "ufw$2 allow from $vip3 $1";fi; }
function gop { cex 'ufw allow 30303 comment eth1';cex 'ufw delete deny 8545              ';gfw 'to any port 8545 comment geapi'; }
function gcl { cex 'ufw deny  30303 comment eth1';cex 'ufw        deny 8545 comment geapi';gfw 'to any port 8545'     ' delete'; }
function ofw { if [[ $cust = hrv ]];then cex "ufw$2 allow from $zip2 $1";cex "ufw$2 allow from $zip3 $1";else cex "ufw$2 allow from $vip1 $1";cex "ufw$2 allow from $vip3 $1";fi; }
function oop { cex 'ufw allow 30303 comment eth1';cex 'ufw delete deny 8545              ';gfw 'to any port 8545 comment oeapi'; }
function ocl { cex 'ufw deny  30303 comment eth1';cex 'ufw        deny 8545 comment oeapi';gfw 'to any port 8545'     ' delete'; }
function bfw { if [[ $cust = hrv ]];then cex "ufw$2 allow from 192.168.8.0/24 $1";else cex "ufw$2 allow from $vip3 $1";fi; }
function bop { cex 'ufw allow 9000 comment eth2';cex 'ufw delete deny 5052              ';bfw 'to any port 5052 comment bnapi'; }
function bcl { cex 'ufw deny  9000 comment eth2';cex 'ufw        deny 5052 comment bnapi';bfw 'to any port 5052'     ' delete'; }
function vfw { if [[ $cust = hrv ]];then cex "ufw$2 allow from $zip1 $1";else cex "ufw$2 allow from $vip1 $1";fi; }
function vop { cex 'ufw delete deny 5064              ';`# vfw 'to any port 5064 comment vcmet'` ; }
function vcl { cex 'ufw        deny 5064 comment vcmet';`# vfw 'to any port 5064'     ' delete'` ; }
function fop { cex 'ufw allow 3000/tcp comment grafana'; }
function fcl { cex 'ufw deny  3000/tcp                '; }
# enable/arranca goethereum/beacon/validator/prometheus/grafana
function ge  { gop;cex 'ufw reload';cex "systemctl enable $ethg"; }
function be  { bop;cex 'ufw reload';cex "systemctl enable $ethb"; }
function ve  { [[ ! -f $dtdi/vc_lock ]] && { vop;cex 'ufw reload';cex "systemctl enable $ethv"; } }
function pe  { cex 'ufw reload';cex "systemctl enable $ethp"; }
function ne  { cex 'ufw reload';cex "systemctl enable $ethn"; }
function fe  { fop;cex 'ufw reload';cex "systemctl enable $ethf"; }
function ga  { [[ $(pwr $ethg) ]] && [[ -d /var/lib/goethereum   ]] && { cex "systemctl start $ethg"; } }
function ba  { [[ $(pwr $ethb) ]] && { cex "systemctl start $ethb"; } }
function va  {
  if [[ $(pwr $ethv) ]];then
    if [[ -f $dtdi/vc_lock ]];then
      if [[ -f /home/eth/slashing_protection.sqlite ]];then
        echo $H|sudo -S cp /home/eth/slashing_protection.sqlite $vldt 2>/dev/null
        sudo chown eth3:eth3 $vldt/slashing_protection.sqlite
        sudo chmod 600 $vldt/slashing_protection.sqlite
      fi
    else
      cex "systemctl start $ethv"
      rm $dtdi/vc_slash
    fi
  fi
}
function pa { [[ $(pwr $ethp) ]] && { cex "systemctl start $ethp"; } }
function na { [[ $(pwr $ethn) ]] && { cex "systemctl start $ethn"; } }
function fa { [[ $(pwr $ethf) ]] && { cex "systemctl start $ethf"; } }
# para/disable goethereum/beacon/validator/prometheus/grafana
function gp { [[ $(pwr $ethg loaded) ]] && { cex "systemctl stop $ethg"; } }
function bp { [[ $(pwr $ethb loaded) ]] && { cex "systemctl stop $ethb"; } }
function vp { [[ $(pwr $ethv loaded) ]] && { cex "systemctl stop $ethv";touch $dtdi/vc_slash; } }
function pp { [[ $(pwr $ethp loaded) ]] && { cex "systemctl stop $ethp"; } }
function np { [[ $(pwr $ethn loaded) ]] && { cex "systemctl stop $ethn"; } }
function fp { [[ $(pwr $ethf loaded) ]] && { cex "systemctl stop $ethf"; } }
function gd { cex "systemctl disable $ethg";gcl;cex 'ufw reload'; }
function bd { cex "systemctl disable $ethb";bcl;cex 'ufw reload'; }
function vd { cex "systemctl disable $ethv";vcl;cex 'ufw reload';touch $dtdi/vc_lock; }
function pd { [[ $(pwr $ethp loaded) ]] && { cex "systemctl disable $ethp"; } }
function nd { [[ $(pwr $ethn loaded) ]] && { cex "systemctl disable $ethn"; } }
function fd { [[ $(pwr $ethf loaded) ]] && { cex "systemctl disable $ethf";fcl;cex 'ufw reload'; } }

[[ $1 = eip ]] && { eip $2 $3; }
[[ $1 = dsh ]] && { dsh ${2:-pt.archive.ubuntu.com}; }
[[ $1 = drs ]] && { drs; }
[[ $1 = nsh ]] && { nsh; }
[[ $1 = nrs ]] && { nrs; }
[[ $1 = trs ]] && { [[ $(pwr systemd-timesyncd masked) ]] || { cex "systemctl restart systemd-timesyncd"; };csh; }
[[ $1 = vcp ]] && { ssp; }
[[ $1 = gl  ]] && { gl;echo -e "GETH$m"; }
[[ $1 = glf ]] && { gl;echo -e "GETH$m" >> $p5; }
[[ $1 = bl  ]] && { bl;echo -e "BEAC$m"; }
[[ $1 = bm  ]] && { bm;echo -e "BEAC$m"; }
[[ $1 = bn  ]] && { bm;echo -e "BEAC$s"; }
[[ $1 = blf ]] && { bl;echo -e "BEAC$m" >> $p2; }
[[ $1 = bmf ]] && { bm;echo -e "BEAC$m" >> $p3; }
[[ $1 = bnf ]] && { bm;echo -e "BEAC$s" >> $p7; }
[[ $1 = gh  ]] && { [[ -f $p5           ]] && { tail -n ${2:-$hors} $p5;gl;echo -e "GETH$m\n";sst GETH "$(pst $ethg)";csh;psh;esh; } }
[[ $1 = bh  ]] && { [[ -f $p2           ]] && { bh $2;[[ $2 ]] || { csh;psh;esh; } } }
[[ $1 = brl ]] && { [[ -f $p2           ]] && brl; }
[[ $1 = bsl ]] && { [[ -f $p2 && -f $p7 ]] && bsl; }
[[ $1 = bnl ]] && { bnl; }
[[ $1 = bo  ]] && { bo1 $2 $3;bo2 $2; }
[[ $1 = cpe ]] && { csh;psh;esh; }
[[ $1 = glr ]] && { gb;[[ $ok != 'OK' ]] && grs ${2:-0}    ; }
[[ $1 = blr ]] && { bb;[[ $ok != 'OK' ]] && brs ${2:-0}    ; }
[[ $1 = bmc ]] && { bm;[[ $b4 -ne 0   ]] && brs $b4 pereset; }
[[ $1 = grs ]] && { grs ${2:-0}        ; }
[[ $1 = srs ]] && { brs ${2:-0} reboot ; }
[[ $1 = brs ]] && { brs ${2:-0} bnreset; }
[[ $1 = lrs ]] && { brs ${2:-0} vcreset; }
# lista servicos & portas
[[ $1 = lp  ]] && { netstat -tulpn; }
# outros journal system/lighthouse
[[ $1 = el  ]] && { echo $H|sudo -S grep -i 'geth\[\|lighthouse' $p4 2>/dev/null|if [[ $2 ]];then grep -i "[a-z]* [0-9]* $2";else grep -v ' INFO ';fi; }
[[ $1 = sl  ]] && { echo $H|sudo -S grep -v 'geth\[\|lighthouse' $p4 2>/dev/null|if [[ $2 ]];then grep -i "[a-z]* [0-9]* $2";else grep -i 'error' ;fi; }
[[ $1 = ws  ]] && { cex "ufw status numbered"; }
[[ $1 = wa  ]] && if [[ $(echo $H|sudo -S ufw status 2>/dev/null|grep -i inactive) ]];then echo -e "${i}ARRANCA FIREWALL${f}";sudo ufw enable; else echo -e "${i}FIREWALL JA ACTIVE${f}";fi
[[ $1 = wpr ]] && { cex "ufw disable"; }
# journal
[[ $1 = yj ]] && { jsh; }
[[ $1 = ej ]] && { jsh "-u $ethg -u $ethb -u $ethv"; }
[[ $1 = gj ]] && { jsh "-u $ethg"; }
[[ $1 = bj ]] && { jsh "-u $ethb"; }
[[ $1 = vj ]] && { jsh "-u $ethv"; }
[[ $1 = sj ]] && { jsh "-u $dnsd"; }
# arranca
[[ $1 = ga ]] && { dmr;ga; }
[[ $1 = oa ]] && { dmr;oa; }
[[ $1 = ba ]] && { dmr;ba; }
[[ $1 = va ]] && { dmr;va; }
[[ $1 = pa ]] && { dmr;pa; }
[[ $1 = na ]] && { dmr;na; }
[[ $1 = fa ]] && { dmr;fa; }
[[ $1 = xa ]] && { dmr;xa; }
[[ $1 = ra ]] && { dmr;ra; }
[[ $1 = sa ]] && { dmr;sa; }
# para & arranca & journal
[[ $1 = gaj ]] && { dmr;ga;jsh "-u $ethg"; }
[[ $1 = baj ]] && { dmr;ba;jsh "-u $ethb"; }
[[ $1 = vaj ]] && { dmr;va;jsh "-u $ethv"; }
[[ $1 = saj ]] && { dmr;sa;jsh "-u $dnsd"; }
[[ $1 = gpa ]] && { gp;dmr;ga;jsh "-u $ethg"; }
[[ $1 = bpa ]] && { bp;dmr;ba;jsh "-u $ethb"; }
[[ $1 = vpa ]] && { vp;dmr;va;jsh "-u $ethv"; }
[[ $1 = xpa ]] && { xp;xa; }
[[ $1 = rpa ]] && { rp;ra; }
[[ $1 = spa ]] && { sp;sa;jsh "-u $dnsd"; }
[[ $1 = gpd ]] && { gp;gd; }
[[ $1 = opd ]] && { op;od; }
[[ $1 = bpd ]] && { bp;bd; }
[[ $1 = vpd ]] && { vp;vd; }
[[ $1 = xpd ]] && { xp;xd; }
[[ $1 = rpd ]] && { rp;rd; }
[[ $1 = spd ]] && { sp;sd; }
[[ $1 = gea ]] && { ge;dmr;ga;jsh "-u $ethg"; }
[[ $1 = bea ]] && { be;dmr;ba;jsh "-u $ethb"; }
[[ $1 = vea ]] && { ve;dmr;va;jsh "-u $ethv"; }
[[ $1 = xea ]] && { xe;xa; }
[[ $1 = rea ]] && { re;ra; }
[[ $1 = sea ]] && { se;sa;jsh "-u $dnsd"; }
# enable
[[ $1 = ge ]] && { ge; }
[[ $1 = oe ]] && { oe; }
[[ $1 = be ]] && { be; }
[[ $1 = ve ]] && { ve; }
[[ $1 = pe ]] && { pe; }
[[ $1 = ne ]] && { ne; }
[[ $1 = fe ]] && { fe; }
[[ $1 = xe ]] && { xe; }
[[ $1 = re ]] && { re; }
[[ $1 = se ]] && { se; }
# para
[[ $1 = fpr ]] && { fp; }
[[ $1 = npr ]] && { np; }
[[ $1 = ppr ]] && { pp; }
[[ $1 = vpr ]] && { vp; }
[[ $1 = bpr ]] && { bp; }
[[ $1 = gpr ]] && { gp; }
[[ $1 = opr ]] && { op; }
[[ $1 = xpr ]] && { xp; }
[[ $1 = rpr ]] && { rp; }
[[ $1 = spr ]] && { sp; }
# disable
[[ $1 = fds ]] && { fd; }
[[ $1 = nds ]] && { nd; }
[[ $1 = pds ]] && { pd; }
[[ $1 = vds ]] && { vd; }
[[ $1 = bds ]] && { bd; }
[[ $1 = gds ]] && { gd; }
[[ $1 = ods ]] && { od; }
[[ $1 = xds ]] && { xd; }
[[ $1 = rds ]] && { rd; }
[[ $1 = sds ]] && { sd; }

if [[ ! $1 ]];then
  m="\nprimeira letra"
  m="$m\ne\t\t$ethg $ethb $ethv"
  m="$m\ng\t\t$ethg"
  m="$m\nb\t\t$ethb"
  m="$m\nv\t\t$ethv"
  m="$m\np\t\t$ethp"
  m="$m\nn\t\t$ethn"
  m="$m\nf\t\t$ethf"
  m="$m\nx\t\t$plex"
  m="$m\nr\t\t$trrt"
  m="$m\ns\t\t$dnsd"
  m="$m\n"
  m="$m\nsegunda letra"
  m="$m\na\t\tarranca"
  m="$m\naj\t\tarranca\t& journal"
  m="$m\ne\t\tenable"
  m="$m\nj\t\tjournal"
  m="$m\npr\t\tpara"
  m="$m\nds\t\tdisable"
  m="$m\npd\t\tpara\t& disable"
  m="$m\npa\t\tpara\t& arranca\t& journal"
  m="$m\nea\t\tenable\t& arranca\t& journal"
  m="$m\n"
  m="$m\noutros"
  if [[ $cunm = $znm3 ]];then
    m="$m\nvcp\t\t$ethv copy to $vnm3 server"
  else
    m="$m\nvcp\t\t$ethv copy to $znm3 server"
  fi
  m="$m\ngl[f]\t\tgeth log report"
  m="$m\ngh\t\tgeth historic report"
  m="$m\ngrs [n]\t\t$ethg restart n=nodes to change"
  m="$m\nbrs [n]\t\t$ethb restart n=nodes to change"
  m="$m\nsrs [n]\t\tsystem restart n=nodes to change"
  m="$m\nlrs [n]\t\tlighthouse restart n=nodes to change"
  m="$m\nyj\t\tsystem journal"
  m="$m\nsl [s]\t\tlista system journal  s=TOTAL"
  m="$m\nel [s]\t\tlista geth,lighthouse s=TOTAL"
  m="$m\nbrl\t\tbeacon recalculate logs"
  m="$m\nbsl\t\tbeacon substitute logs"
  m="$m\nbnl\t\tbeacon new logs"
  m="$m\nbl[f]\t\tbeacon log report"
  m="$m\nbm[f]\t\tbeacon medias report"
  m="$m\nbn[f]\t\tbeacon archive report"
  m="$m\nbh\t\tbeacon historic report"
  m="$m\nbo\t\tbeacon homologous report"
  m="$m\nws\t\tfirewall status"
  m="$m\nwa\t\tfirewall arranca"
  m="$m\nwpr\t\tfirewall para"
  m="$m\ncpe\t\tclock & cpu & errors report"
  m="$m\nlp\t\tlista portas"
  m="$m\neip\t\tset dynamic DNS"
  m="$m\nnsh\t\tnetwork/route/DNS show "
  m="$m\ndsh [url]\tdns show"
  m="$m\nnrs\t\tdns/netplan reset"
  m="$m\ndrs\t\tdns reset"
  m="$m\ntrs\t\ttime sync restart"
  echo -e "\n$m\n"
fi
