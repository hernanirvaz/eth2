#!/bin/bash

source /home/eth/eth2/t1

function nu0 { printf %i         ${1:-0}                              2>$p03; }                                                                               # get unformated numeric output
function nu1 { printf ${1:-%i}   ${2:-0}                              2>$p03; }                                                                               # get   formated numeric output
function nu2 { printf ${3:-%.0f} $(echo "scale=${2:-1};$1"|bc 2>$p03) 2>$p03; }                                                                               # get precision calculations
function nu3 { local n=$1;local i=$2;shift;shift;if [[ $# -gt 0 ]];then nu2 "(0$(printf %+.${n}f $@ 2>$p03))/$#"       $((n+1)) %.${i}f;else printf %i;fi; }  # get precision average list numbers
function nu4 { local n=$1;                 shift;if [[ $# -gt 0 ]];then nu2 "(0$(printf %+.${n}f $@ 2>$p03))"          $((n+1)) %.${n}f;else printf %i;fi; }  # get precision sum     list numbers
function nu5 { local n=$1;                 shift;if [[ $# -gt 0 ]];then nu2 "(0$(printf %+.${n}f $@ 2>$p03))/$#*10^$n" $((n+1))        ;else printf %i;fi; }  # get precision average int  numbers
function ll0 { local f=$p16/logs/beacon.log   ;echo $H|sudo -S grep -h $r44                               $f.1 $f 2>$p03                       ; }            # get cc intern lines (specific)
function ll1 { local f=$p16/logs/beacon.log   ;echo $H|sudo -S grep -h $r70                                    $f 2>$p03                       ; }            # get cc intern lines (specific)
function ll2 { local f=$p16/logs/beacon.log   ;echo $H|sudo -S cat                                             $f 2>$p03                       ; }            # get cc intern lines
function ll3 { local f=$p01                   ;echo $H|sudo -S grep -h $r34                                    $f 2>$p03                       ; }            # get all eth syslog lines
function ll4 { local f=$p01                   ;echo $H|sudo -S grep -h $1                                 $f.1 $f 2>$p03                       ; }            # get all eth syslog lines
function ll5 { local f=$p01                   ;echo $H|sudo -S grep -h $r32.*$r65                              $f 2>$p03|lg0 .*$r65            ; }            # get reorgs
function ll6 { local f=$p17/logs/validator.log;echo $H|sudo -S grep -h $r67                               $f.1 $f 2>$p03|tail -n$1|lg0 .*$r67  ; }            # get time_taken_ms vc lines
function ll7 { local f=$p17/logs/validator.log;echo $H|sudo -S grep -h $r53                               $f.1 $f 2>$p03|tail -n$1             ; }            # get latency vc lines
function ll8 { local f=$p17/logs/validator.log;echo $H|sudo -S cat                                             $f 2>$p03                       ; }            # get vc intern lines
function lg0 { sed -n "s%$1 *\([0-9]*\).*%\1%p" $2 2>$p03; }                                                                                                  # get list of numbers
function lg1 { if [[ $l4 ]];then echo "$l4"|gawk "$1";else printf %i 1;fi; }                                                                                  # get s/ms delays from log lines
function lg2 { echo "$l6"|sed -n "s%.*$r53  *\([0-9]*\).*$1.*%\1%p" 2>$p03; }                                                                                 # get list of vc latencies
function lg3 { local n=${1:-0};if [[ $n -gt 0 ]];then l4=$(ll0|tail -n$n);else l4=$(ll0);fi;b1=$(nu3 3 0 $(lg1 "$w0$r45$w2"));b5=$(nu3 3 0 $(lg1 "$w0$r46$w2"));b8=$(nu4 0 $(ll5));if [[ $n -gt 0 ]];then l4=$(ll1|tail -n$((1000*n)));else l4=$(ll1);fi;b9=$(nu3 0 0 $(lg1 "$w0$r71$w1")); }
function lg4 { if v2t;then l6=$(ll7 $1);v0=$(nu5 1 $(lg2 $iip5));v1=$(nu5 1 $(lg2 $zip4));v2=$(nu5 1 $(ll6 $(($1/2))));else v0=0;v1=0;v2=0;fi; }              # set vc delays
function fs0 { pex "grep -h ${2:-$r32}.*$1 $p01"; }                                                                                                           # get specific syslog lines
function fs1 { pex "grep -h ${1:-$r34}     $p01"; }                                                                                                           # get eth      syslog lines
function fs2 { pex "grep -v ${1:-$r34}     $p01"; }                                                                                                           # get sys      syslog lines
function fs3 { fs0 $1 $2|lg0 .*$1 ; }                                                                                                                         # get numbers  syslog lines
function fs4 { fs0 $1 $2|tail -n$3; }                                                                                                                         # get specific syslog lines
function fs5 { fs2      |tail -n300|grep -i Core.*temperature; }                                                                                              # get tail cpu syslog lines
function fs6 { fs0 $1 $2|sed -n "s%.*$1 *\([0-9]*\.[0-9]*\).*%\1%p" 2>$p03; }                                                                                 # get floats   syslog lines
function fln { if [[ $2 ]];then grep -i "^[a-z][a-z][a-z]  *[0-9][0-9]*  *$2";else grep -iv "$1";fi; }
function flp { if [[ $2 ]];then grep -i "^[a-z][a-z][a-z]  *[0-9][0-9]*  *$2";else grep -i  "$1"|grep -iv "$r64";fi; }
function pt0 { until [[ $# -le 1 || $1 =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]];do shift;done;printf %s $1; }                                                       # yyyy-mm-dd test
function pt1 { until [[ $# -le 1 || $1 =~ ^[0-9]{2}:[0-9]{2}$          ]];do shift;done;printf %s $1; }                                                       # hh:mm      test
function pt2 { until [[ $# -le 1 || $1 =~ ^[0-9]+$                     ]];do shift;done;printf %i $1; }                                                       # integer    test
function pt3 { until [[ $# -le 1 || $1 =~ ^[a-z]+$                     ]];do shift;done;printf %s $1; }                                                       # string     test
function tll { [[ $(grep '\-all-' $p04/$s12.service 2>$p03) ]]; }                                                                                             # cc long-lived   test
function jsh { cex "journalctl --no-hostname --no-full -f $1"; }                                                                                              # my journal   format
function spc { nn=$2;cp $p04/$1.service $p02/$1.sav;sed "s%peers\([ =]*\)[0-9]*%peers\1$2%" $p02/$1.sav > $p04/$1.service;dmr; }                              # service configuration change/reload
function snp { [[ -f $p04/$1.service ]] || return;local n=$(($2+nn));(($2!=0&&n>=$3&&n<=$4)) && spc $1 $n;tsa $1 && sex "$s02 $1"; }                          # service peers change/stop
function sra { if trf;then nu0 $(($(date +%s)-$(date -r $p45 +%s)));else printf %i;fi }                                                                       # system reboot age (secounds)
function sci { nu0 $(ip a|sed -n 's% *inet  *192.168.8.\([0-9]*\).*%\1%p' 2>$p03); }                                                                          # get ip/24
function sni { case $1 in 25) printf $znm1;;28) printf $znm2;;31) printf $znm3;;34) printf $znm4;;37) printf $inm5;;*) printf $cunm;;esac; }                  # get name from ip/24
function ss1 { $s01 $1 2>$p03|sed -n "s%.*$2[ =]\(${3:-.}*\).*%\1%p" 2>$p03; }                                                                                # systemctl status 1 extraction
function ss2 { $s01 $1 2>$p03|sed -n "s%.*Active: *\(.*\)%\1%p" 2>$p03|sed "s% *since.*;%%" 2>$p03|cut -c1-40; }                                              # systemctl status 2 extraction
function ss3 { if tsa $1;then ss1 $1 Memory:                     ;else printf 0.0K   ;fi; }                                                                   # systemctl status Memory extraction
function ss4 { if tsa $1;then ss1 $1 $3 "[^$4 ]"|sed -n $2       ;else printf 00:0000;fi; }                                                                   # systemctl status ip/port extraction
function ss5 { if tsa $1;then nu0 $(($(ss1 $1 $2 [0-9])/${3:-1}));else printf %i     ;fi; }                                                                   # systemctl status number extraction
function dmr { sex "$s00 daemon-reload"; }                                                                                                                    # daemon-reload
function dts { read       d0 d1   <<< ${1:-$(date '+%F %H:%M')};dt="$d0 $d1"; }                                                                               # set date/time vars
function dtl { read _ _ _ d0 d1 _ <<< $(bff|tail -n1)          ;dt="$d0 $d1"; }                                                                               # set date/time vars with last beacon log
function dnn { printf '%10s %5s node%02i: %2i' $dt $nn $nr 2>$p03; }                                                                                          # get date/nodes info
function tsy { if [[ $(echo $@|grep false) ]];then printf SYC;else printf NSY;fi; }                                                                           # get el SYN/NSY text
function els { lg0 .*sgs: $1|tail -n1; }                                                                                                                      # get el last segment
function era { tail -n${2:-$s53} $1 2>$p03|cut -d' ' -f1|sort -u|wc -l; }                                                                                     # get el/cc restart activity
function sh0 { [[ -f $1 ]] || return;tail -n${2:-$s53} $1 2>$p03; }                                                                                           # simple historic report
function eb0 { e0=$(fs0 Imported $2|wc -l);ok=OK;[[ $(echo $@|grep false) && ($e0 -eq $(els $1) || $e3 -gt $s64) && $(era $1) -eq 1 ]] && ok=BK; }
function eb1 { nu0 $(((nn*100-nn*60)/100)); } # $nr -lt $(eb1)                                                                                                # get current peers-30%
function ero { [[ -f $2 ]] || return;dts;swn "$(nu1 R%03i $1) ${3:-RS} SRV $(dnn)" >> $2; }                                                                   # log restart info
function ell { pt2 $(wc -l $1   2>$p03) 0; }                                                                                                                  # get ec       line count
function bbl { pt2 $(wc -l $p12 2>$p03) 0; }                                                                                                                  # get cc       line count
function bml { pt2 $(wc -l $p13 2>$p03) 0; }                                                                                                                  # get cc-daily line count
function stg { local n=${1:-0};if ((n>3599));then printf %s $(($(date -d@$n +%H)-1))h;fi;if ((n>0));then printf %s $(date -d@$n +%Mm%Ss);fi;printf %s .$(date -d@$(($(date +%s)+$n)) +%H%M%S); }
function sf1 { printf %s ${1:-$(date +%H:%M:%S)}; }                                                                                                           # get filterd t7 parm 1
function sf2 { printf %i ${2:-24}; }                                                                                                                          # get filterd t7 parm 2
function sft { echo $(sf1) $1 $2 $3 $(basename $4 2>$p03); }                                                                                                     # print restart info line
function cpf { basename $(ls $p02/*.rs.* 2>$p03|sort -t. -k4n|tail -n1) 2>$p03; }                                                                             # get last restart basename
function smn { local g=${1:-24}                  ;nu0 $((g>360?360:g<24?24:g)); }                                                                             # get max/min seconds to future (12x30/24)
function sfn { local g=$(($(bss $1)-$(date +%s)));nu0 $((g>3?g:3))            ; }                                                                             # get min seconds to future
function ssf { [[ $1 -gt 0 ]] || return;local f=$2.s$(stg $1);touch $f;[[ -f $p50 ]] && sft ${3:-$(date +%H:%M:%S)} ${4:-00} ${5:-00} $f;sleep $1s; }
function ssw { while :;do local t=$(sng);if [[ $(sf2 $t) -lt $1 || 24 -ge $(sfn $t) ]];then ssf $(smn $(sfn $t)) $2 $t $1;else break;fi;ts0 $2 && break;done; }
function snn {
  if [[ $# -gt 0 ]];then
    nr=${@:$#};nm=$(printf '%i\n' $@ 2>$p03|sort -n|head -n1);nd=$(nu2 "sqrt(((0$(printf '+%i^2' $@ 2>$p03))-(0$(printf '+%i' $@ 2>$p03))^2/$#)/$#)*1000" 4)  # set cur/min/std peers vars
  else
    nr=0      ;nm=0                                          ;nd=0
  fi
}
function sz0 { gnn 0          ;printf 'el:p%02i:m%02i:d%04i p2p:%5i %s irut:%4i %4i %2i %4i %4i'                   $nr $nm $nd $(ss5 $1 port    ) "$(gb1 $(gcl eth.syncing))" $e1 $e3 $e2 $e4 $(ei0)             2>$p03; }
function sz1 { unn 0          ;printf 'el:p%02i:m%02i:d%04i p2p:%5i %s    i:%i'                                    $nr $nm $nd $(ss5 $1 p2p-port) "$(ub1 $(ucl eth_syncing))" $e1                                2>$p03; }
function sz2 { dtl;bo4;lg3;bnn;printf 'cl:p%02i:m%02i:d%04i p2p:%5i %s iorh:%4i %4i %2i %4i %4i op:c%02i:m%02i:%i' $nr $nm $nd $(ss5 $1 port)     "$(bb1 $(bcl syncing))"     $b1 $b5 $b8 $b9 $(bi1) $b2 $b3 $ln 2>$p03; }
function sz3 { lg4 $s63       ;printf 'vl:m%02i:b%02i:c%02i cc:%13s'                                               $v0 $v1 $v2 $(ss4 $1 $r24 nodes)                                                              2>$p03; }
function sso {
  tse $2 || return;dts;local e="$1 $(printf '%6s %10s %5s %-40s' $(ss3 $2) $dt "$(ss2 $2)" 2>$p03)"                                                           # memory & status
  [[ $1 = GETH ]] && e="$e $(sz0 $2)";[[ $1 = BESU ]] && e="$e $(sz1 $2)";[[ $1 = BEAC ]] && e="$e $(sz2 $2)";[[ $1 = VALI ]] && e="$e $(sz3 $2)";swn "$e"    # set homologous/avg & cl http
}
# el control commands
function grs {
  ts1 $p40 && return;touch $p40.a$(stg);ssw $3 $p40;ts0 $p40 && return
  local t=$(sng);local f=$p40.i$(stg);touch $f;local n=0;paf;while [[ -f $f ]];do ((n+=$(sfn $t)));ssf $(sfn $t) $p40 $t
  if tip $t;then rm $f;gv0;[[ $2 = RB ]] && gq0;snp $s10 $1 10 50
    if [[ $2 = RB ]];then ero $n $p10 $2;sex reboot;else sex "$s03 $s10";ssf 50 $p40;gq0;ero $n $p10 $2;fi
  fi;done;rm -f $p50 $p40.*
}
function gdi { if [[ $1 -gt 0 ]];then l4=$(ll4 $r35|tail -n$1);else l4=$(ll4 $r35);fi;e1=$(nu3 3 0 $(lg1 "$w0$r42$w2")); }                                    # get delay imported
function gdu { if [[ $1 -gt 0 ]];then l4=$(ll4 $r52|tail -n$1);else l4=$(ll4 $r52);fi;e2=$(nu2 "$(nu3 3 2 $(lg1 "$w0$r42$w2"))*10"); }                        # get delay Chain head was updated
function gdt { if [[ $1 -gt 0 ]];then l4=$(ll4 $r72|tail -n1 );else l4=$(ll4 $r72);fi;e4=$(nu3 3 0 $(lg1 "$w0$r42$w2")); }                                    # get delay Persisted the clean trie cache
function gcl { geth attach --exec $1 "http://$ciec:8545" 2>$p03; }                                                                                            # exec RPC HTTP
function gi0 { nu0 $(echo $@|sed -n 's%.*highestBlock: *\([0-9]*\).*%\1%ip' 2>$p03); }                                                                        # get el highest block
function gc0 { nu0 $(echo $@|sed -n 's%.*currentBlock: *\([0-9]*\).*%\1%ip' 2>$p03); }                                                                        # get el current block
function gv0 { nn=$(ss5 $s10 maxpeers); }                                                                                                                     # set configured peers
function gq0 { nr=$(nu0 $(gcl net.peerCount)); }                                                                                                              # set el current peers
function gll { grep "GETH.*$d0" $p10 2>$p03|wc -l; }                                                                                                          # get day geth log lines
function gnn { snn $(fs3 peercount= $r30) $(nu0 $(gcl net.peerCount));gdi $1;e3=$(nu2 "$(nu4 0 $(fs3 rejected= $r30))/$(gll)");gdu $1;gdt $1; }
function gb1 { if [[ $(echo $@|grep false) ]];then printf 'synced';else printf  'syncing: %6i' $(($(gi0 $@)-$(gc0 $@)));fi; }                                 # get el syncing blocks remaining
function gb2 { if [[ $(echo $@|grep false) ]];then printf ''      ;else printf ' syncing: %6i' $(($(gi0 $@)-$(gc0 $@)));fi; }                                 # get el syncing blocks remaining
function gl0 {                                                                                                                                                # el report
  dts;ok=OK
  if tsa $s10;then local e=$(gcl eth.syncing);gnn $s45;gv0;eb0 $p10 $r30 $e
    m="GETH $ok $(tsy $e) $(dnn) sgs: $(nu1 %4i $e0)$(gb2 $e) $(printf 'irut: %3i %3i %2i %4i %3i' $e1 $e3 $e2 $e4 $(ei0) 2>$p03)"
  else
    m="GSRV NOT ON $dt"
  fi
}
function urs {
  ts1 $p41 && return;touch $p41.a$(stg);ssw $3 $p41;ts0 $p41 && return
  local t=$(sng);local f=$p41.i$(stg);touch $f;local n=0;paf;while [[ -f $f ]];do ((n+=$(sfn $t)));ssf $(sfn $t) $p41 $t
  if tip $t;then rm $f;uv0;[[ $2 = RB ]] && uq0;snp $s11 $1 10 50
    if [[ $2 = RB ]];then ero $n $p11 $2;sex reboot;else sex "$s03 $s11";ssf 50 $p41;uq0;ero $n $p11 $2;fi
  fi;done;rm -f $p50 $p41.*
}
function udi { if [[ $1 -gt 0 ]];then l4=$(ll4 $r35|tail -n$1);else l4=$(ll4 $r35);fi;e1=$(nu3 3 0 $(lg1 "$w0$r43$w2")); }                                    # get delay imported
function ucl { curl -sX POST --data "{\"jsonrpc\":\"2.0\",\"method\":\"$1\",\"params\":[],\"id\":51}" "http://$ciec:8545" 2>$p03; }                           # exec RPC HTTP
function ui0 { nu0 $((16#$(nu0 $(echo $@|sed -n 's%.*highestBlock" *: *"0x\([^"]*\)".*%\1%ip' 2>$p03)))); }                                                   # get el highest block
function uc0 { nu0 $((16#$(nu0 $(echo $@|sed -n 's%.*currentBlock" *: *"0x\([^"]*\)".*%\1%ip' 2>$p03)))); }                                                   # get el current block
function up0 { nu0 $((16#$(nu0 $(echo $@|sed -n 's%.*result" *: *"0x\([^"]*\)".*%\1%ip'       2>$p03)))); }                                                   # get el result
function uv0 { nn=$(ss5 $s11 max-peers); }                                                                                                                    # set configured peers
function uq0 { nr=$(up0 $(ucl net_peerCount)); }                                                                                                              # set el current peers
function unn { snn $(fs3 Peers: $r31) $(up0 $(ucl net_peerCount));udi $1;e3=0;e2=0;e4=0; }                                                                    # set cur/min/std el peers
function ub1 { if [[ $(echo $@|grep false) ]];then printf 'synced';else printf  'syncing: %6i' $(($(ui0 $@)-$(uc0 $@)));fi; }                                 # get el syncing blocks remaining
function ub2 { if [[ $(echo $@|grep false) ]];then printf ''      ;else printf ' syncing: %6i' $(($(ui0 $@)-$(uc0 $@)));fi; }                                 # get el syncing blocks remaining
function ul0 {                                                                                                                                                # el report
  dts;ok=OK
  if tsa $s11;then local e=$(ucl eth_syncing);unn $s45;uv0;eb0 $p11 $r31 $e
    m="BESU $ok $(tsy $e) $(dnn) sgs: $(nu1 %4i $e0)$(ub2 $e) $(printf 'i: %3i' $e1 2>$p03)"
  else
    m="USRV NOT ON $dt"
  fi
}
# cc control commands
# curl 192.168.8.37:5052/lighthouse/peers | jq -r '.[] | select(.peer_info.connection_direction=="Incoming") | .peer_info.seen_addresses | .[]'
function bcl { curl -sX GET "http://$cicc:5052/eth/v1/node/$1" -H "accept: application/json" 2>$p03; }                                                        # exec RPC HTTP
function bsd { nu0 $(echo $@|jq -r .data.sync_distance 2>$p03)                        ; }                                                                     # get cl syncing distance
function bpc { nu0 $(echo $@|jq -r .data.connected     2>$p03)                        ; }                                                                     # get cl peers connected
function bz0 { nu2 "(30.0*(0.4*$zk+0.3*$zz+0.2*$zx+0.1*$zw))"                         ; }                                                                     # get numerator paid errors
function bw0 { nu0 $((9*z1))                                                          ; }                                                                     # get numerator processed blocks
function bf0 { nu0 $((59*z3))                                                         ; }                                                                     # get numerator general errors
function bi0 { nu0 $((zk*9+zz*5+zx))                                                  ; }                                                                     # get delete day idx
function bi2 { nu0 $(((z5>400?$(bz0)/z5:0)+(z2>300?$(bw0)/z2:0)+(z4>999?$(bf0)/z4:0))); }                                                                     # get restart idx
function ei0 { nu2 "(0.80*$e1+0.01*$e3+0.17*$e2+0.02*$e4)"                            ; }                                                                     # get imported/rejected/updated/trie data
function bi1 { nu2 "(0.80*$b1+0.11*$b5+0.07*$b8+0.02*$b9)"                            ; }                                                                     # get imported/observed/reorg/http data
function bdp { nu2 "($1*$s48+$2*$s49+$3*$s50+$4*$s51)/${5:-1}*$s55/1000000" 7; }                                                                              # get penalty
function bdr { nu2 "($1*$s47+$2*$s46)*$s55/100000000"                       7; }                                                                              # get reward
function bv0 { nn=$(ss5 $s12 target-peers); }                                                                                                                 # set configured peers
function bs0 { l0=$(fs4 $s54] $r32 3600); }                                                                                                                   # set last cc log lines
function bs3 { l3=$(fs0 $r48); }                                                                                                                              # set attesta log lines
function bs5 { l5=$(echo "$l1"|sed -nEe "s%.+node$g:.+er: +([0-9]+) +([0-9]+) +([0-9]+) +([0-9]+).+%\1\t\2\t\3\t\4%p" 2>$p03); }                              # set penalty errors log lines
function bb0 { bs0;bs3;bl1;bl2;[[ (1 -eq $(era $p12 $s52) && $(bi2) -ge 1) || (1 -eq $(era $p12 5) && $(bi2) -ge 5) ]] && ok=BK; }                            # set ok (OK/BK)
function bfl { grep "BEAC.*$1"      2>$p03; }                                                                                                                 # filter cc lines
function bff { grep "BEAC.*$1" $p12 2>$p03; }                                                                                                                 # filter cc log
function bnn { snn $(fs3 peers:) $(bpc $(bcl peer_count)); }                                                                                                  # set cur/min/std cc peers
function bb1 { if [[ $(echo $@|jq -r .data.is_syncing) = false ]];then printf 'synced';else printf 'syncing: %6i' $(bsd $@);fi; }                                    # get cl syncing distance remaining
function bio { lg3 $1;dts;m="BEIO $(nu1 %6i $1) $dt iorh: $b1 $b5 $b8 $b9 $(bi1)"; }
function bmp { printf '%5i %3s %3i %5i %4i iorh: %4i %4i %2i %4i %4i' ${a[0]} $b7 $b4 $nd $(bi0) $b1 $b5 $b8 $b9 $(bi1) 2>$p03; }
function bl0 { dts;ok=OK;if tsa $s12;then bl3;bv0;bnn;bb0;blo;else m="BSRV NOT ON $dt";fi; }                                                                  # cc report
function bl1 {                                                                                                                                                # set restart idx vars
  z1=${1:-$(echo "$l0"|grep 'RPC block'|wc -l)};z2=${2:-$(echo "$l0"|grep 'New block'|wc -l)};z3=${3:-$(echo "$l0"|grep -v ' INFO '|wc -l)}                   # set processed/received blocks,error lines
  z4=${4:-$(echo "$l0"|grep ' INFO '   |wc -l)};z5=${5:-$(bl4 success)};zw=${6:-$(bl4 had)};ok=${7:-OK}                                                       # set info lines,success/had activities
}
function bl2 { zk=${1:-$(bl4 missing)};zz=${2:-$(bl4 target)};zx=${3:-$(bl4 head)}; }                                                                         # set missing/target/head activities
function bl3 { b0=${1:-$(fs0 $r47|wc -l)};if [[ $2$3$4$5  ]];then b1=$2;b5=$3;b8=$4;b9=$5;else lg3 $s61;fi; }                                                 # set pub-blocks & imported/observed delays
function bl4 { echo "$l3"|sed -n "s%.*$1.*validators: *\[\(.*\)\].*%\1%p"|wc -w; }                                                                            # get number of paid activities
function ml0 { dts;ok=OK;if tsa $s14;then m0=$(nu5 2 $(fs6 duration= $r33));mlo;else m="MSRV NOT ON $dt";fi; }
function vl0 { dts;ok=OK;if tsa $s13;then lg4 $s62;vlo;else m="VSRV NOT ON $dt";fi; }
#    0  1              2     3         4   5
# MEVB OK  11 2023-06-13 01:10 http_avg:  84
function mlo { m="MEVB $ok $(printf '%3i' $(fs1 "$r33"|fln "$r62"|wc -l) 2>$p03) $dt $(printf 'http_avg: %3i' $m0 2>$p03)"; }
#    0  1              2     3     4   5     6   7
# VALI OK     2023-06-03 20:49 int5: 700 ztc4: 240
function vlo { m="VALI $ok $(printf '%3i' $(ll8|fln "$r66"|wc -l) 2>$p03) $dt $(printf '%s: %2i %s: %2i casp: %2i' $(snc $inm5) $v0 $(snc $znm4) $v1 $v2 2>$p03)"; }
#    0  1   2          3     4       5  6   7    8    9  10   11  12 13  14 15 16  17 18 19  20  21 22   23   24    25   26   27 28   29   30
# BEAC OK   0 2023-06-17 03:29 node60: 66 rp:  608  261 ab:  800   78 0 er:  0  1  10  3  0 511   0  3 3597  177 iorh:  423 5097  5 1545 1274
function blo {
  m="BEAC $ok $(printf '%3i' $(bi2) 2>$p03) $(dnn) $(printf 'rp: %4.0f %4.0f ab: %4i %4i %1i' $(bdr $z5 $b0) $(bdp $zk $zz $zx $zw) $z5 $(bz0) $b0 2>$p03)"
  m="$m $(printf 'er: %2i %2i %3i %2i %2i %3i %3i %2i %4i %4i iorh: %4i %4i %2i %4i %4i' $zk $zz $zx $zw $z1 $z2 $(bw0) $z3 $z4 $(bf0) $b1 $b5 $b8 $b9 $(bi1) 2>$p03)"
}
#  0    1   2          3     4       5  6   7     8     9    10    11    12    13    14    15  16  17    18   19    20   21   22 23   24   25
# BM    5   5 2023-06-17 03:31 node60: 66 mp:   347   811  1550  1525  1396  2158  2015  1400 p_: -40  1523   16 iorh:  628 5387  5 2477 1455
function bmo { m="BM $(printf '%4i %3i' $b2 $b3 2>$p03) $(dnn) $(bma 'mp:') $(bmp)"; }
#  0    1   2          3     4       5  6   7     8     9  10  11    12   13   14    15   16 17   18   19
# BM    5   5 2023-06-17 03:32 node60: 66 mp:  1396  1400 p_: -40  1520   16 iorh:  628 5387  5 2476 1455
function bms { m="BM $(printf '%4i %3i' $b2 $b3 2>$p03) $(dnn) mp: $(nu1 %5i ${a[$nn]}) $(bmp)"; }
#    0   1          2     3    4 5 6 7 8 9 10 11   12 13 14 15 16 17 18 19   20 21 22 23 24 25 26 27   28 29 30 31 32 33 34 35   36 37 38 39 40 41 42 43
# BEAC 682 2022-03-16 11:03 cnt: 4 7 0 0 0 10 10 mis: 20 20 20 20 20 20 20 mat: 14 45 30 30 30 30 30 mah: 94 68 40 40 40 40 40 dly: 79 09 50 50 50 50 50
function bno { m="BEAC $(nu1 %6i $(bbl)) $dt $(bnc 'cnt:' ' ') $(bnk 'mis:' ' ') $(bnz 'mat:' ' ') $(bnx 'mah:' ' ') $(bnw 'dly:' ' ')"; }
function bmi { zk=0;zz=0;zx=0;unset v;v[1]=0;unset k;k[0]=0;unset z;z[0]=0;unset x;x[0]=0;unset w;w[0]=0;unset c;c[0]=0;unset a;a[0]=0;bm6; }                 # ini err/cnt/avg penalty arrays
function bm0 {                                                                                                                                                # cc-daily report
  [[ -f $p12 ]] || return;bmi;b4=0;dts;bv0;bnn;bs3;bl2;[[ -f $p14 ]] && bm4;lg3                                                                               # set vars/arrays
  l1=$(tail -n$(($(nu0 $(bbl))-v[1])) $p12 2>$p03|bfl);[[ $l1 ]] && bm1;bm2;[[ $b2 -eq 0 ]] && boi;bo3;bm5 ${a[$nn]};b7=$(bcc)                                # add cc lines & homologous/avg position
}
function bm1 { local g=${1:-$s56};bs5;[[ $l5 ]] && { bkm $g;bzm $g;bxm $g;bwm $g;bcm $g; };((g<s57)) && bm1 $((g+s58)); }                                     # recursively sum penalty errors arrays
function bm2 { k[0]=$(($(bnk)));z[0]=$(($(bnz)));x[0]=$(($(bnx)));w[0]=$(($(bnw)));c[0]=$(($(bnc)));a[0]=$(bm3 0);bm7; }                                      # tot err/cnt/penalty arrays
function bm3 { bdp ${k[$1]} ${z[$1]} ${x[$1]} ${w[$1]} ${c[$1]} ; }                                                                                           # get penalty from paid err arrays
function bm4 { read -a v <<< $(tail -n1 $p14);bmk;bmz;bmx;bmw;bmc; }                                                                                          # set err/cnt penalty arrays from barqivo
function bm5 { local g=${2:-$s56};local n=$1;if ((a[g]<n));then b4=$((g-nn));n=${a[$g]};fi;((g<s57)) && bm5 $n $((g+s58)); }                                  # set recursively peer change <- min penalties
function bm6 { local g=${1:-$s56};k[$g]=0;z[$g]=0;x[$g]=0;w[$g]=0;c[$g]=0;a[$g]=0         ;((g<s57)) && bm6    $((g+s58)); }                                  # ini recursively penalty arrays
function bm7 { local g=${1:-$s56};a[$g]=$(bm3 $g)                                         ;((g<s57)) && bm7    $((g+s58)); }                                  # avg recursively penalty arrays
function bcm { local g=${1:-$s56};((c[g]+=$(echo "$l5"|wc -l 2>$p03)                        )); }                                                             # sum               cnt array
function bkm { local g=${1:-$s56};((k[g]+=$((0$(printf '+%i' $(echo "$l5"|cut -f1) 2>$p03))))); }                                                             # sum missing       err array
function bzm { local g=${1:-$s56};((z[g]+=$((0$(printf '+%i' $(echo "$l5"|cut -f2) 2>$p03))))); }                                                             # sum failed target err array
function bxm { local g=${1:-$s56};((x[g]+=$((0$(printf '+%i' $(echo "$l5"|cut -f3) 2>$p03))))); }                                                             # sum failed head   err array
function bwm { local g=${1:-$s56};((w[g]+=$((0$(printf '+%i' $(echo "$l5"|cut -f4) 2>$p03))))); }                                                             # sum delay         err array
function bmc { local g=${1:-$s56};local n=${2:-5 };c[$g]=${v[$n]};((g<s57)) && bmc $((g+s58)) $((n+1)); }                                                     # set recursively               cnt array
function bmk { local g=${1:-$s56};local n=${2:-13};k[$g]=${v[$n]};((g<s57)) && bmk $((g+s58)) $((n+1)); }                                                     # set recursively missing       err array
function bmz { local g=${1:-$s56};local n=${2:-21};z[$g]=${v[$n]};((g<s57)) && bmz $((g+s58)) $((n+1)); }                                                     # set recursively failed target err array
function bmx { local g=${1:-$s56};local n=${2:-29};x[$g]=${v[$n]};((g<s57)) && bmx $((g+s58)) $((n+1)); }                                                     # set recursively failed head   err array
function bmw { local g=${1:-$s56};local n=${2:-37};w[$g]=${v[$n]};((g<s57)) && bmw $((g+s58)) $((n+1)); }                                                     # set recursively delay         err array
function bma { local g=${2:-$s56};if ((g<=s57));then bma "$1 $(nu1 %5i ${a[$g]})"      $((g+s58));else printf "$1";fi; }                                      # sum recursively penalty       avg array
function bnc { local g=${3:-$s56};if ((g<=s57));then bnc "${1:-0}${2:-+}${c[$g]}" "$2" $((g+s58));else printf "$1";fi; }                                      # sum recursively               cnt array
function bnk { local g=${3:-$s56};if ((g<=s57));then bnk "${1:-0}${2:-+}${k[$g]}" "$2" $((g+s58));else printf "$1";fi; }                                      # sum recursively missing       err array
function bnz { local g=${3:-$s56};if ((g<=s57));then bnz "${1:-0}${2:-+}${z[$g]}" "$2" $((g+s58));else printf "$1";fi; }                                      # sum recursively failed target err array
function bnx { local g=${3:-$s56};if ((g<=s57));then bnx "${1:-0}${2:-+}${x[$g]}" "$2" $((g+s58));else printf "$1";fi; }                                      # sum recursively failed head   err array
function bnw { local g=${3:-$s56};if ((g<=s57));then bnw "${1:-0}${2:-+}${w[$g]}" "$2" $((g+s58));else printf "$1";fi; }                                      # sum recursively delay         err array
function boi {
  unset v;read -a v <<< $(bff|tail -n1);local n=0;local t=${1:-${v[4]}};b6=0;while :;do l2=$(bff $t);if [[ $l2 ]];then break;else t=${v[4]};fi;done           # set homologous lines
  while :;do bo2 ${v[3]};if [[ $b2 -eq 0 && $n -lt 99 ]];then ((n+=1));v[3]=$(date -d "$n days ago $t" +%F);else break;fi;done;ln=$(echo "$l2"|wc -l)         # set homologous position
}
function bo0 { echo "$l2"|sort -k10n -k4r; }                                                                                                                  # get homologous lines sorted
function bo1 { echo "$l2"|sort -k10r -k4n; }                                                                                                                  # get homologous lines reversed
function bo2 { b2=$(bo0|grep -n ${1:-$(date '+%F')}|cut -d: -f1); }                                                                                           # set homologous position
function bo3 { b3=$(nu3 0 0 $b2 $(lg0 BM $p13)); }                                                                                                            # set homologous avg
function bo4 { l2=$(bff $d1);bo2 $d0;bo3;ln=$(echo "$l2"|wc -l); }                                                                                                                   # set homologous position/avg
function bo5 { bo0|head -n$((b6>b2?b6:b2<5?5:b2))|tail -n$((b6>0?b6:b2>s52?s52:b2<5?5:b2)); }                                                                 # homologous report
function bo6 { bo0|grep $(printf node%02i: $1 2>$p03); }                                                                                                      # get homologous node lines sorted
function boa { local g=${1:-$s56};local e=$(bo6 $g);printf 'BO%5i %3i\n' $(echo "$e"|wc -l) $g 2>$p03;echo "$e";((g<s57)) && boa $((g+s58)); }                # recursively show homologous nodes report
function bod {
  [[ -f $p12 ]] || return;l2=$(bff 23:58);local e='';while read -a v;do
    if [[ ${v[9]} -ge $1 && $(echo "$l2"|grep ${v[5]}|wc -l) -gt $2 ]];then local e="$e ${v[3]}";l2=$(echo "$l2"|grep -v ${v[3]});fi                          # gather delete info
  done <<< $(bo1);if [[ $e ]];then local e=${e:1};local e=${e// /\\|};bdw $p12 $e;bdw $p13 $e;fi                                                              # perform logs delete
}
function bh0 {
  [[ -f $p12 ]] || return;tail -n${1:-$s52} $p12;[[ $1 ]] && return;local e='x9 x5  x1 x0 rb  nb c10 er   if  c90'
  boi;swn "BO $(printf '%4i %3i%34s%29s' $b2 $ln    2>$p03)$e";bo5
  bl0;swn "BL $(printf '%8i%34s%29s'         $(bbl) 2>$p03)$e\n$m";bm0
  bmo;swn "BM $(printf '%8i%34s'             $(bml) 2>$p03) i20   i30   i40   i50   i60   i70   i80   avg\n$m"
}
function bss { nu0 $((${2:-0}+$(date -d$(sf1 $1) +%s))); }                                                                                                    # get sum secounds + time
function bwc { bwd|grep -Ex "$(echo ${!b[@]}|tr ' ' '|')"|wc -l; }                                                                                            # get my # validators
function bwd { local n=$((($(date +%s)-s31)/(12*32)));for n in $n $((n+1));do curl -sH "$s28" -X POST -d"[$(echo ${!b[@]}|tr ' ' ',')]" "$s32/sync/$n";curl -sH "$s28" -X GET "$s32/proposer/$n";done 2>$p03|jq -r "$s35"; }
function bro { [[ -f $p12 ]] || return;dts;bb0;bnn;swn "$(printf 'R%03i %2s %3i' $1 ${2:-$ok} $(bi2) 2>$p03) $(dnn)" >> $p12; }
function vro { [[ -f $p49 ]] || return;dts;        swn "$(printf 'R%03i %2s     %10s %5s' $1 ${2:-$ok} $dt 2>$p03)"  >> $p49; }
function ts1 { [[ $(ls $1.* 2>$p03|wc -l) -gt 0 ]]; }
function ts0 { [[ $(ls $1.* 2>$p03|wc -l) -eq 0 ]]; }
function tsb { [[ $(bwc) -gt 0 ]]; }
function tsi { ts1 $1 || tsb; }
function tso { ts0 $1 || tsb; }
# slots = secounds 12,24,36,48,60,72,84,96,108,120,132,144,156,168
function brs {
  tsi $p42 && return;touch $p42.a$(stg);if [[ $3 -gt 0 ]];then ssf $3 $p42;tso $p42 && return;touch $p42.b$(stg);fi;ssw $4 $p42;tso $p42 && return
  local t=$(sng);local f=$p42.i$(stg);touch $f;local n=0;paf;while [[ -f $f ]];do ((n+=$(sfn $t)));ssf $(sfn $t) $p42 $t
  if tip $t;then rm $f;bv0;snp $s12 $1 $s56 $s57                           ;[[ $2 = VC ]] && sex "$s02 $s13"
    if [[ $2 = RB ]];then bro $n $2;gps;ups;sex reboot;else sex "$s03 $s12";[[ $2 = VC ]] && sex "$s03 $s13";ssf 50 $p42;bro $n $2;fi
  fi;done;rm -f $p50 $p42.*
}
function vrs {
  tsi $p46 && return;touch $p46.a$(stg);ssw $1 $p46;tso $p46 && return;local t=$(sng);local f=$p46.i$(stg);touch $f;local n=0;paf
  while [[ -f $f ]];do ((n+=$(sfn $t)));ssf $(sfn $t) $p46 $t;if tip $t;then rm $f;cex "$s02 $s13";dmr;if [[ $2 = RS ]];then cex "$s03 $s13";else cex "$s02 $s12";fi;vro $n $2;fi;done;rm -f $p50 $p46.*
}
function brh { head -n${1:-0} $p12; }                                                                                                                         # new cc head lines
function brl {                                                                                                                                                # recalculate cc logs
  [[ -f $p12 ]] || return;rm -f $p12.r;unset v;while read -a v;do ok=${v[1]};dts ${v[3]}\ ${v[4]};nn=${v[5]:4:2};nr=${v[6]}                                   # uncalculated vars
    if [[ ${v[0]} = BEAC ]];then
      bl1 ${v[19]} ${v[20]} ${v[22]} ${v[23]} ${v[11]} ${v[18]} ${v[1]};bl2 ${v[15]} ${v[16]} ${v[17]};bl3 ${v[13]} ${v[26]} ${v[27]} ${v[28]} ${v[29]};blo
    else
      m="${v[0]} $ok $(nu1 %3i ${v[2]})";if [[ ${v[0]} = BSRV ]];then m="$m $dt";else m="$m $(dnn)";fi;swn "$m"
    fi;swn "$m" >> $p12.r                                                                                                                                     # new cc output
  done <<< $(cat $p12)
}
function brm {                                                                                                                                                # recalculate cc-daily logs
  [[ -f $p12 && -f $p13 ]] || return;rm -f $p13.r;bmi;local d=0000-00-00;local l=0;local n=0;local h=0;local g=0;unset v;while read -a v;do
    d=${v[3]};h=$g;g=$(grep -n "$d 23:58" $p12|cut -d: -f1);[[ ${g:=$h} -le $h ]] && continue;dts $d\ ${v[4]};nn=${v[5]:4:2}                                  # get next cc log position
    nr=${v[6]};nd=${v[12]};zx=${v[13]};l2=$(brh $g|bfl 23:58);bo2 $d;((l+=b2));((n+=1));b3=$(nu2 $l/$n)                                                       # cur/avg homologous position
    l1=$(brh $g|tail -n$((g-h))|bfl);[[ $l1 ]] && bm1;bm2;b7=${v[10]};b4=${v[11]};b1=${v[15]};b5=${v[16]};b8=${v[17]};b9=${v[18]};bms;swn "$m" >> $p13.r      # sum err arrays & new cc-daily output
  done <<< $(cat $p13)
}
function bsl {                                                                                                                                                # shrink cc      log using barqivo
  [[ -f $p12 && -f $p14 ]] || return;rm -f $p12.s;tail -n$(($(cat $p12|wc -l)-$(tail -n1 $p14|cut -d' ' -f2))) $p12 > $p12.s                                  # new    cc      log output
  rm -f $p14.s;head -n$(($(cat $p14|wc -l)-1)) $p14 > $p14.s;tail -n1 $p14|sed 's%BEAC [0-9]*%BEAC 0%' >> $p14.s                                              # new    barqivo log output
}
function bdw { [[ -f $1 ]] || return;cp $1 $1.o;grep -v $2 $1.o > $1;grep $2 $1.o > $1.d; }                                                                   # work to delete cc log day
function bdl { local d=$(pt0 $1 sai);[[ $d = sai ]] && return;bdw $p12 $d;bdw $p13 $d; }                                                                      #         delete cc log day
function wst { echo $@|sed 's%[^: ]*: *%%g;s%inactive%off%;s%active%on%' 2>$p03; }                                                                            # get ufw info
function sm0 { local s='smartctl --json=c -x';pex "$s /dev/nvme0"|jq -r "$r54" 2>$p03; }
function sm1 { local s='smartctl --json=c -x';pex "$s /dev/nvme0"|jq -r "$r54" 2>$p03;pex "$s /dev/nvme1"|jq -r "$r54" 2>$p03;pex "$s /dev/nvme2"|jq -r "$r54" 2>$p03; }
function sm2 { local s=$(pex "smartctl --json=c -x /dev/sda");echo $s|jq -r "$r40" 2>$p03;echo $s|jq -r "$r41" 2>$p03; }
function tmp {
  local d=$(fs5|grep throttled|head -n1|sed "$r27");local e=$(fs5|grep normal|tail -n1|sed "$r27");local g=''
  if [[ $cunm = $znm4 ]];then local g=$(echo $g $(sm0));fi;if [[ $cunm = $inm5 ]];then local g=$(echo $g $(sm1));else local g=$(echo $g $(sm2));fi;local l=$(sensors 2>$p03|sed -n "$r26")
  [[ $1$d$e || $(nu3 1 0 $l) -ge $s59 || $(nu3 1 0 $g) -ge $s59 ]] || return;[[ $d ]] && local d="throttled: $d";[[ $e ]] && local e="normal: $e"
  swn "TEMP $(printf '%5.1fC %10s %5s ssd: %.1fC %s %s' $(nu3 1 1 $l) $dt $(nu3 1 1 $g) $d $e 2>$p03)"                                                        # TEMP cpu/ssd info
}
function nus { fs2|flp "$r61"|grep usb|wc -l; }
function ncp { fs5|wc -l; }
function cpe {                                                                                                                                                # system status
  local e='NO';[[ $($s07|sed -n 's%.*synchronized: \([a-z]*\) *%\1%p') = yes ]] && local e='OK';dts
  if tsa $s19;then local e="CSYS $e";m=$(ss2 $s19);else local e="CNTP $e";m=$(ss2 ntp);fi
  swn "$e $(nu1 %3i $(fs0 clock|wc -l)) $dt $m";[[ $1 = c ]] && return;tmp;[[ $1 = p ]] && return                                                             # clock & temperature info
  if [[ $(cat $p44 2>$p03) -eq 0 ]];then local e=off;else local e=on;fi;if [[ $(cat $p43 2>$p03) -eq 1 ]];then local d=off;else local d=on;fi                 # usb/cpu current state
  m="INFO$(printf '%3i %3i %10s %5s' $(nus) $(ncp) $dt 2>$p03)"                                                                                               # usb/cpu erros count
  m="$m usb $e, turbo $d, ufw $(wst $(pex 'ufw status'|grep Status:))"                                                                                        # usb/cpu/ufw info
  m="$m, uptime:$(uptime|sed "$r75")";swn "$m"
  local l=$(fs2|flp "$r61"|wc -l);local n=$(fs1|fln "$r62"|wc -l)
  local e=$(fs2|flp "$r61"|tail -n1|sed "$r73")
  local d=$(fs1|fln "$r62"|tail -n1|sed "$r74")
  m="ERRO$(printf '%3i %3i' $l $n 2>$p03) $dt";if [[ $l -gt 0 ]];then if [[ $n -gt 0 ]];then m="$m sl: ${e:0:53}";m="$m cl: ${d:0:54}";else m="$m sl: ${e:0:112}";fi;else if [[ $n -gt 0 ]];then m="$m cl: ${d:0:112}";fi;fi;(( l+n )) && echo "$m"
  m='';trf && m="$m, reboot $(($(sra)/60/60)) hours ago $(cpf)";[[ $(bwc) -gt 0 ]] && m="$m, sync/propose duties on";[[ $m ]] && swn "INFO        $dt${m#*,}" # reboot/duties info
  [[ $(nu0 $(/usr/lib/update-notifier/apt-check 2>&1|sed 's%;% %g')) -gt 0 ]] && { echo;apt list --upgradable; }
}
# Plex Media Server
function xop { pde 80 plex/nginx delete;pai 80 192.168.8.0/24 plex/nginx       ;ide 192.168.8.0/24 1900/udp plex/upnp       ; }
function xco { pde 80 plex/nginx       ;pai 80 192.168.8.0/24 plex/nginx delete;ide 192.168.8.0/24 1900/udp plex/upnp delete; }
function xe  { xop;sex 'ufw reload';cex "$s04 $s22";cex "$s04 $s21"; }                                                                                        # enable  plexmediaserver
function xa  { tsa $s22 || cex "$s03 $s22";tsa $s21 || cex "$s03 $s21"; }                                                                                     # start   plexmediaserver
function xp  { tsa $s22 && cex "$s02 $s22";tsa $s21 && cex "$s02 $s21"; }                                                                                     # stop    plexmediaserver
function xd  { cex "$s05 $s21";cex "$s05 $s22";xco;sex 'ufw reload'; }                                                                                        # disable plexmediaserver
# Transmission BitTorrent Daemon
function rop { pae 51413 torrent;pde 9091 torrent delete;pai 9091 192.168.8.0/24 torrent       ; }
function rco { pde 51413 torrent;pde 9091 torrent       ;pai 9091 192.168.8.0/24 torrent delete; }
function re  { rop;sex 'ufw reload';cex "$s04 $s15"; }                                                                                                        # enable  transmission-daemon
function ra  { tsa $s15 || cex "$s03 $s15"; }                                                                                                                 # start   transmission-daemon
function rp  { tsa $s15 && cex "$s02 $s15"; }                                                                                                                 # stop    transmission-daemon
function rd  { cex "$s05 $s15";rco;sex 'ufw reload'; }                                                                                                        # disable transmission-daemon
# Bind9
function sop { pai 53 192.168.8.0/24 dns       ; }
function sco { pai 53 192.168.8.0/24 dns delete; }
function se  { sop;sex 'ufw reload';cex "$s04 $s20"; }                                                                                                        # enable  named
function sa  { tsa $s20 || cex "$s03 $s20"; }                                                                                                                 # start   named
function sp  { tsa $s20 && cex "$s02 $s20"; }                                                                                                                 # stop    named
function sd  { cex "$s05 $s20";sco;sex 'ufw reload'; }                                                                                                        # disable named
# el/cc/vc
function efw { if [[ $cust = hrv ]];then pai $1 192.168.8.0/24 $2 $3;else pai $1 $vip1 $2 $3;pai $1 $vip3 $2 $3;fi; }
function eop { local e=30303;[[ $cunm = $inm5 ]] || e=30304;pae $e elp2p;pde 8545 elapi delete;pde 8551 eljwt delete;efw 8545 elapi       ;efw 8551 eljwt       ; }
function eco { local e=30303;[[ $cunm = $inm5 ]] || e=30304;pde $e elp2p;pde 8545 elapi       ;pde 8551 eljwt       ;efw 8545 elapi delete;efw 8551 eljwt delete; }
function bfw { if [[ $cust = hrv ]];then pai $1 192.168.8.0/24 $2 $3;else pai $1 $vip3 $2 $3;fi; }
function bop { local e=9000 ;[[ $cunm = $znm4 ]] || e=9004 ;pae $e clp2p;pde 5052 clapi delete;pde 8551 cljwt delete;bfw 5052 clapi       ;bfw 8551 cljwt       ; }
function bco { local e=9000 ;[[ $cunm = $znm4 ]] || e=9004 ;pde $e clp2p;pde 5052 clapi       ;pde 8551 cljwt       ;bfw 5052 clapi delete;bfw 8551 cljwt delete; }
function vfw { if [[ $cust = hrv ]];then pai $1 192.168.8.0/24 $2 $3;else pai $1 $vip1 $2 $3;fi; }
function vop { vfw 5064 vcapi       ;pde 5064 vcapi delete; }
function vco { vfw 5064 vcapi delete;pde 5064 vcapi       ; }
# enable/start eth-geth eth-beacon eth-validator prometheus prometheus-node-exporter grafana-server mev-boost
function ge  { eop;sex 'ufw reload';cex "$s04 $s10"; }                                                                                                        # enable eth-geth
function ue  { eop;sex 'ufw reload';cex "$s04 $s11"; }                                                                                                        # enable eth-besu
function be  { bop;sex 'ufw reload';cex "$s04 $s12"; }                                                                                                        # enable eth-beacon
function ve  { vop;sex 'ufw reload';cex "$s04 $s13"; }                                                                                                        # enable eth-validator
function pe  { pai 9090/tcp 192.168.8.0/24 $s16 ;sex 'ufw reload';cex "$s04 $s16"; }                                                                          # enable prometheus
function ne  { sex 'ufw reload';cex "$s04 $s17"; }                                                                                                            # enable prometheus-node-exporter
function fe  { pai 3000/tcp 192.168.8.0/24 grafana  ;sex 'ufw reload';cex "$s04 $s18"; }                                                                      # enable grafana-server
function me  { pai 18550    192.168.8.0/24 mev-boost;sex 'ufw reload';cex "$s04 $s14"; }                                                                      # enable mev-boost
function ga  { tsa $s10 || cex "$s03 $s10"; }                                                                                                                 # start eth-geth
function ua  { tsa $s11 || cex "$s03 $s11"; }                                                                                                                 # start eth-besu
function ba  { tsa $s12 || cex "$s03 $s12"; }                                                                                                                 # start eth-beacon
function va  {
  v2t && [[ -f $p05/vc_keys ]] && ! tsa $s13 || return                                                                                                        # cannot start eth-validator
  if [[ -f $p05/vc_lock ]];then sis $p02/$(basename $p18);else cex "$s03 $s13";rm -f $p05/vc_slash;fi                                                         # start eth-validator
}
function pa  { tsa $s16 || cex "$s03 $s16"; }                                                                                                                 # start prometheus
function na  { tsa $s17 || cex "$s03 $s17"; }                                                                                                                 # start prometheus-node-exporter
function fa  { tsa $s18 || cex "$s03 $s18"; }                                                                                                                 # start grafana-server
function ma  { tsa $s14 || cex "$s03 $s14"; }                                                                                                                 # start mev-boost
function wa  { if [[ $(pex 'ufw status'|grep -i inactive) ]];then yex 'ufw enable';else swu 'FIREWALL ALREADY ACTIVE';fi; }                                   # enable ufw : Proceed with operation (y|n)?
# stop/disable eth-geth eth-beacon eth-validator prometheus prometheus-node-exporter grafana-server mev-boost
function gps { tsa $s10 && sex "$s02 $s10"; }                                                                                                                 # silent stop eth-geth
function ups { tsa $s11 && sex "$s02 $s11"; }                                                                                                                 # silent stop eth-besu
function bps { tsa $s12 && sex "$s02 $s12"; }                                                                                                                 # silent stop eth-beacon
function gp  { tsa $s10 && cex "$s02 $s10"; }                                                                                                                 # stop eth-geth
function up  { tsa $s11 && cex "$s02 $s11"; }                                                                                                                 # stop eth-besu
function bp  { tsa $s12 && cex "$s02 $s12"; }                                                                                                                 # stop eth-beacon
function vp  { tsa $s13 && cex "$s02 $s13";touch $p05/vc_slash; }                                                                                             # stop eth-validator
function pp  { tsa $s16 && cex "$s02 $s16"; }                                                                                                                 # stop prometheus
function np  { tsa $s17 && cex "$s02 $s17"; }                                                                                                                 # stop prometheus-node-exporter
function fp  { tsa $s18 && cex "$s02 $s18"; }                                                                                                                 # stop grafana-server
function mp  { tsa $s14 && cex "$s02 $s14"; }                                                                                                                 # stop mev-boost
function gd  { cex "$s05 $s10";eco;sex 'ufw reload'; }                                                                                                        # disable eth-geth
function ud  { cex "$s05 $s11";eco;sex 'ufw reload'; }                                                                                                        # disable eth-besu
function bd  { cex "$s05 $s12";bco;sex 'ufw reload'; }                                                                                                        # disable eth-beacon
function vd  { cex "$s05 $s13";vco;sex 'ufw reload';touch $p05/vc_lock; }                                                                                     # disable eth-validator
function pd  { cex "$s05 $s16";pai 9090/tcp 192.168.8.0/24 $s16  delete;sex 'ufw reload'; }                                                                   # disable prometheus
function nd  { cex "$s05 $s17"; }                                                                                                                             # disable prometheus-node-exporter
function fd  { cex "$s05 $s18";pai 3000/tcp 192.168.8.0/24 grafana   delete;sex 'ufw reload'; }                                                               # disable grafana-server
function md  { cex "$s05 $s14";pai 18550    192.168.8.0/24 mev-boost delete;sex 'ufw reload'; }                                                               # disable mev-boost
function umt { [[ $(cat $p44 2>$p03) -eq 1 && $(nus) -gt 10 ]]; }                                                                                             # usb messages test
function t0t { [[ $(cat $p43 2>$p03) -eq 0 && $(ncp) -gt 20 ]]; }                                                                                             # cpu no turbo recomended test
function t1t { [[ $(cat $p43 2>$p03) -eq 1 && $(ncp) -le 10 ]]; }                                                                                             # cpu    turbo recomended test
function t2t { [[ $(cat $p43 2>$p03) -eq 1 ]]; }                                                                                                              # cpu no turbo            test
function pas { umt && sex "$p54 usbstop";t1t && sex "$p54 cputurbo";t0t && sex "$p54 cpunoturbo"; }                                                           # set usb/cpu parameters
function paf { t2t && sex "$p54 cputurbo"; }                                                                                                                  # set turbo   parameter
function hsg { sso GETH $s10; }
function hsu { sso BESU $s11; }
function hsb { sso BEAC $s12; }
function hsv { sso VALI $s13; }
function hsm { sso MEVB $s14; }
function hs0 { echo $1;if [[ $cunm = $1 ]];then hsg;hsu;else ssh $(snc $1) "$p53 hse";fi;[[ $1 = $2 ]] || echo $2;if [[ $cunm = $2 ]];then hsb;hsv;cpe;else ssh $(snc $2) "$p53 hsc";fi; }
function nsh { $s08 list;$s08 status;$s09 status|sed -n 's%\(Current DNS\).*:%   \1:%ip'; }                                                                   # network/dns info
function wlp { local e="$1";shift;until [[ $# -lt 1 ]];do e="$e\|$1";shift;done;fs2|grep '\[UFW'|if [[ $e ]];then grep -v "$e";else cat;fi; }
function c0c { local e="$r11";[[ $(sed -n "$r12" $p04/$s12.service 2>$p03) = $zip1 ]] && e="$r10";sed "$e" $s12.sav > $p04/$s12.service; }                    # cc change el server
function ble { tbf || return;cp $p04/$s12.service $p02/$s12.sav;sed "$1" $p02/$s12.sav > $p04/$s12.service;dmr; }                                             # cc service edit
function cce { tbf || return;cp $p04/$s12.service $p02/$s12.sav;c0c;cmw $p04/$s12.service 644 eth; }                                                          # cc change el server (merge)
function vcc { tvf || return;cp $p04/$s13.service $p02/$s13.sav;sed "$r19" $s13.sav > $p04/$s13.service;cmw $p04/$s13.service 644 eth; }                      # vc switch cc server order
function trs { if tsa $s19;then nex "$s06 $s19";else nex "$s06 ntp";fi; }                                                                                     # systemd-timesyncd/ntp restart
function dpa { nex "$s02 $s20";nex "$s02 systemd-resolved";nex "$s03 $s20";nex "$s03 systemd-resolved"; }                                                     # DNS stop/start
function nrs { nex 'netplan apply';dpa; }                                                                                                                     # netplan/DNS restart
function lcp { local f=$1;shift;[[ -x $f ]] && until [[ $# -lt 1 ]];do if [[ $1 = $(snc $cunm) ]];then lci $f;else scp $f $1:$p02;fi;shift;done; }            # propagate lighthouse
function lci { [[ -x $1 && ! -d $1   ]] || return;sex "mv $p00/lighthouse $p00/lighthouse.sav";sex "cp $1 $p00"; }                                            # lighthouse binary install
function lmd { [[ -x $p00/lighthouse ]] || return;cmw $p00/lighthouse 755 eth;swb 'LIGHT INSTALADO'; }                                                        # lighthouse set permissions
function lpi { [[ $cunm = $znm2 ]] && lcp $1 ztc2 ztc3;[[ $cunm = $znm4 ]] && lcp $1 ztc4;[[ $cunm = $inm5 ]] && lcp $1 int5;[[ $cunm = $vnm1 ]] && lcp $1 vpsl;lci $p02/lighthouse;sex "rm $p02/lighthouse";lmd; }
function luc {                                                                                                                                                # lighthouse upgrade/compile
  if [[ -f $p06/lighthouse/README.md ]];then
    cd $p06/lighthouse;make clean;cargo clean                                                                                                                 # clean compile dirs
  else
    cd $p06;sex "rm -rf $p06/lighthouse";git clone https://github.com/sigp/lighthouse.git;cd $p06/lighthouse                                                  # get new git
  fi
  git fetch;if [[ $(echo $2|egrep 'v[0-9]+\.[0-9]+\.[0-9]+') ]];then m=$2;else m=$(git describe --tags $(git rev-list --tags --max-count=1));fi               # fetch (vX.X.X/last) version
  git checkout $m;swb "VAI COMPILAR LIGHTHOUSE $m";FEATURES=modern PROFILE=maxperf make;[[ $? -eq 0 && -x $1 ]] || swb "ERRO COMPILAR $m"                     # checkout stable version & compile
}
function jw0 { [[ -f jwt ]] && return;openssl rand -hex 32|tr -d '\n'|tee jwt 1>$p03; }                                                                       # create jwt file
function ruv { if [[ $1 ]];then swn "RUST OVERRIDE SET $1";rustup override set $1;else swn 'RUST UPDATE';rustup update stable;fi; }                           # set/update rust version
function v0t { tsa $s13; }                                                                                                                                    # vc running  test
function v1t { [[ $cunm = $nxvc ]]; }                                                                                                                         # vc next     test
function v2t { [[ $cunm = $cuvc ]]; }                                                                                                                         # vc current  test
function v3t { [[ $cuvc = $nxvc ]]; }                                                                                                                         # vc transfer test
function v4t { [[ $cunm = $cub1 ]]; }
function v5t { [[ $(grep $d0 $p12 2>$p03|wc -l) -gt 0 ]]; }
function tvc {
  swn "$s24";v3t && return;if v2t && v0t;then swn "TRANSFERIR VC -> $(snc $nxvc) (SIM/nao)?";else return;fi;local rsp=nao;read rsp
  if [[ $rsp = SIM && ! -f $p05/vc_slash && ! -f $p05/vc_lock && -f $p05/vc_keys ]];then vp;vd;swu "COPY SLASH -> $nxvc";local f=$p02/$(basename $p18);sex "cp $p18 $p02";cmw $f 666 eth;scp $f $(snc $nxvc):~;sex "rm $f";fi
}
function svr { local t='';for t in $(printf '%s\n' $@|sort -u);do curl -sX GET "$s33=$t"|sed -n "$r23";done; }                                                # show mev validator registration
function mvr { if [[ $(ls $p19/key*.json 2>$p03) ]];then svr $(sed -n "$r28" $p19/key*.json 2>$p03);else svr ${b[@]};fi; }                                    # choose validator keys
function ibk {
  local f="$p02/pubkeys.old";sex "cp $p16/pubkeys $f";sex "chown eth:eth $f"
  echo "$(cat $f)$(for f in $(jq -r .pubkey $p19/key*.json 2>$p03);do printf %s ",0x$f";done)" > $p02/pubkeys.new
  local f="$p16/pubkeys";sex "cp $p02/pubkeys.new $f";sex "chown eth2:eth2 $f";cmw $f 600;dmr;cex "$s03 $s12"
}
function ivk {
  v2t && [[ ! -f $p05/vc_lock && -d $p19 && $(ls $p19 2>$p03) ]] || return;vrs $1 PR;tsa $s12 || ibk
  if ! tsa $s13;then
    swb 'IMPORTAR CHAVES';sex "chown -R $meeu:$meeu $p17";cmw $p17 755;imk;sex "chown -R eth3:eth3 $p17";cmw $p17 700
    [[ -f $p05/vc_lock ]] || cex "$s03 $s13";[[ -f $p12 ]] && { dts;swn "$(printf 'BSRV VK %3i %10s %5s' $(ls $p19 2>$p03|wc -l) $dt 2>$p03)" >> $p12; }
  fi
}
function sn0 { local n=$((($1-s36)/32));for n in $n $((n+1));do curl -sH "$s28" -X POST -d"[$(echo ${!b[@]}|tr ' ' ',')]" "$s32/attester/$n"|jq -r "$s34";done 2>$p03;echo $(((n+1)*32)); }
function sng { local t=$(((($(date +%s)-s31)/12)+s36));local e=0;local i=0;local s=0;for s in $(sn0 $t|sort -nu);do if ((s<t));then continue;else if (((s-t)>e));then e=$((s-t));i=$t;fi;fi;t=$((s+1));done;printf '%s %i' $(date -d@$((s31+i*12)) +%T) $((e*12)); }

function bcc { printf p;if v4t;then if tbp $s44;then if trb $s44;then printf r;else printf c;fi;else if tsd;then printf d;else printf _;fi;fi;else if trb;then printf r;else if tsd;then printf d;else printf _;fi;fi;fi;printf :; }
function trb { [[ $(sra) -ge $((60*60*${1:-9})) ]]; }
function tip { [[ $(date +%s) -ge $(bss $1 6) ]]; }
function tpc { [[ $b4 -ne 0 ]]; }
function tha { [[ $b2 -gt $((b3*2)) ]]; }
function tsd { [[ $((nd+$(bi0))) -ge $s60 ]]; }
function tpm { [[ $nm -ge $((nn-5)) ]]; }
function trf { [[ -f $p45 ]]; }
function tbf { [[ -f $p04/$s12.service ]]; }
function tvf { [[ -f $p04/$s13.service ]]; }
function tbp { [[ $(era $p12 $s52) -eq 1 ]] && ( (tpc && tpm && tha && ! tsd && ! trf) || trb $1); }
function btr { if trf;then printf RB  ;else printf PE  ;fi; }
function btg { if trf;then printf $s38;else printf $s39;fi; }
function irb { rm $p39.*.hours 2>$p03;if trb $1;then if v2t;then brs 0 RB 0 $s37;else gps;ups;bps;sex reboot;fi;else if trf;then touch $p39.$1.hours;fi;fi; }
function gp0 { if tsa $s10;then bp;gp;local i=$(pt2 $(pex "du -s $p08"));sudo -u eth1 geth --datadir $p08 $@;local n=$(pt2 $(pex "du -s $p08"));echo "fs-diff $(((i-n)/1024/1024))M $@";dmr;ga;ba;fi; }

[[ $1 = irb ]] && { irb $2;pas; }
[[ $1 = bmf ]] && { bm0;[[ $2 ]] && b4=$2;bms;v5t && swn "$m" >> $p13;if v4t;then tbp $s44 && brs $b4 $(btr) $s43 $(btg);else trb && brs 0 RB $s43 $s39;fi; }
[[ $1 = snr ]] && { cex "$s42 lxd";cex "$s42 core20";cex "$s42 snapd";cex 'apt remove --autoremove snapd -y';echo -e "$s41" > nosnap.pref;cex "mv nosnap.pref $p47";cmw $p47/nosnap.pref 644 root;cex 'apt update'; }
[[ $1 = mvr ]] && { mvr; }
[[ $1 = jwt ]] && { [[ $cunm = $znm1 || $cunm = $vnm1 ]] && jw0;if [[ -f jwt ]];then sjw eth1 $p08/geth;sjw eth1 $p09/data;sjw eth2 $p16;fi; }
[[ $1 = lpi ]] && { lpi $p02/.cargo/bin/lighthouse; }
[[ $1 = luc ]] && { luc $p02/.cargo/bin/lighthouse $2; }
[[ $1 = ruv ]] && { ruv $2; }
[[ $1 = clr ]] && { tll && ble "$r17"; }
[[ $1 = cla ]] && { tll || ble "$r18"; }
[[ $1 = vcc ]] && { vcc; }
[[ $1 = cce ]] && { cce; }
[[ $1 = chk ]] && { cex 'chkrootkit'; }
[[ $1 = eip ]] && { curl -s4 "https://${3:-meo.fruga.pt}:$2@dyn.dns.he.net/nic/update?hostname=${3:-meo.fruga.pt}" &>$p03; }
[[ $1 = dsh ]] && { $s09 query ${2:-smtp.gmail.com}; }
[[ $1 = drs ]] && { dpa; }
[[ $1 = nrs ]] && { nrs; }
[[ $1 = trs ]] && { trs; }
[[ $1 = dmr ]] && { dmr; }
[[ $1 = tsh ]] && { cex "$s07";cex "$s07 timesync-status";cex "$s07 show-timesync"; }
[[ $1 = nsh ]] && { nsh; }
[[ $1 = tvc ]] && { tvc; }
[[ $1 = tmp ]] && { dts;tmp s; }
# slots = secounds 12,24,36,48,60,72,84,96,108,120,132,144,156,168
[[ $1 = grs ]] && { touch $p50;grs ${2:-0} SR   ${3:-$s40}; }
[[ $1 = urs ]] && { touch $p50;urs ${2:-0} SR   ${3:-$s40}; }
[[ $1 = brs ]] && { touch $p50;brs ${2:-0} BN 0 ${3:-$s39}; }
[[ $1 = crs ]] && { touch $p50;brs ${2:-0} VC 0 ${3:-$s38}; }
[[ $1 = vrs ]] && { touch $p50;vrs              ${2:-$s38} RS; }
[[ $1 = grb ]] && { touch $p50;grs      0  RB   ${2:-$s38}; }
[[ $1 = urb ]] && { touch $p50;urs      0  RB   ${2:-$s38}; }
[[ $1 = brb ]] && { touch $p50;brs      0  RB 0 ${2:-$s37}; }
[[ $1 = ivk ]] && { touch $p50;ivk              ${2:-$s38}; }
[[ $1 = ul  ]] && { ul0;swn "$m"; }
[[ $1 = ulf ]] && { ul0;swn "$m" >> $p11;[[ $ok != OK ]] && urs 0 $ok $s40; }
[[ $1 = gl  ]] && { gl0;swn "$m"; }
[[ $1 = glf ]] && { gl0;swn "$m" >> $p10;[[ $ok != OK ]] && grs 0 $ok $s40; }
[[ $1 = bl  ]] && { bl0;swn "$m"; }
[[ $1 = blf ]] && { bl0;swn "$m" >> $p12;if [[ $d1 = 23:58 ]];then if tsd;then bdl $d0;else if [[ $(bbl) -gt 7128 ]];then bod 0 1;fi;fi;fi;[[ $ok != OK ]] && v4t && brs 0 $ok 0 $s39;pas; }
[[ $1 = vl  ]] && { vl0;swn "$m"; }
[[ $1 = vlf ]] && { vl0;swn "$m" >> $p49; }
[[ $1 = ml  ]] && { ml0;swn "$m"; }
[[ $1 = mlf ]] && { ml0;swn "$m" >> $p52; }
[[ $1 = bn  ]] && { bm0;bno;swn "$m"; }
[[ $1 = bnf ]] && { bm0;bno;swn "$m" >> $p14; }
[[ $1 = bm  ]] && { bm0;bmo;swn "$m"; }
[[ $1 = gh  ]] && { sh0 $p10 $2;[[ $2 ]] || { gl0;swn "GL $(printf '%8i' $(ell $p10) 2>$p03)\n$m"; } }
[[ $1 = uh  ]] && { sh0 $p11 $2;[[ $2 ]] || { ul0;swn "UL $(printf '%8i' $(ell $p11) 2>$p03)\n$m"; } }
[[ $1 = bh  ]] && { bh0 $2; }
[[ $1 = vh  ]] && { sh0 $p49 $2;[[ $2 ]] || { vl0;swn "VL $(printf '%8i' $(ell $p49) 2>$p03)\n$m"; } }
[[ $1 = mh  ]] && { sh0 $p52 $2;[[ $2 ]] || { ml0;swn "ML $(printf '%8i' $(ell $p52) 2>$p03)\n$m"; } }
[[ $1 = bio ]] && { bio ${2:-$s61};swn "$m"; }
[[ $1 = hs0 ]] && { hs0 $cue1 $cub1;hs0 $cue2 $cub2;if v2t;then hsv;cpe;else echo $cuvc;ssh $(snc $cuvc) "$p53 hsv";fi; }
[[ $1 = hs1 ]] && { hs0 $cue1 $cub1; }
[[ $1 = hs2 ]] && { hs0 $cue2 $cub2; }
[[ $1 = hse ]] && { hsg;hsu; }
[[ $1 = hsc ]] && { hsb;hsv;cpe; }
[[ $1 = hsv ]] && { hsv;cpe; }
[[ $1 = hsm ]] && { hsm;cpe; }
[[ $1 = bo  && -f $p12 ]] && { boi $(pt1 $@ 00:00);if [[ $(pt3 $@ s) = n ]];then b6=$b2;else b6=$(pt2 $@ 0);fi;bo5; }
[[ $1 = bon && -f $p12 ]] && { bv0;l2=$(bff 23:58);bo6 $(pt2 $2 $nn); }
[[ $1 = boc && -f $p12 ]] && { unset v;read -a v <<< $(bff|tail -n1);l2=$(bff $(pt1 $2 ${v[4]}));boa; }
[[ $1 = bol && -f $p12 ]] && { l2=$(bff 23:58);boa; }
[[ $1 = bod ]] && { bod ${2:-0} ${3:-1}; }
[[ $1 = bdl ]] && { bdl $2; }
[[ $1 = brl ]] && { brl; }
[[ $1 = brm ]] && { brm; }
[[ $1 = bsl ]] && { bsl; }
[[ $1 = cpe ]] && { cpe $2; }
[[ $1 = gpn ]] && { gp0 snapshot prune-state; }
[[ $1 = gpg ]] && { gp0 removedb; }
[[ $1 = rsh ]] && { cd $p02;ls -rtGg *.rs.*;echo $(sf1) $(sng); }
[[ $1 = rst ]] && { cd $p02;rm -f    *.rs.*; }
[[ $1 = rpt ]] && { touch $p50; }
[[ $1 = lp  ]] && { netstat -tulpn; }
# outros journal system/lighthouse
[[ $1 = sl  ]] && { fs2                 |flp "$r61" $2              ; }
[[ $1 = el  ]] && { fs1 "\($r30\|$r31\)"|fln "$r62" $2|sed -E "$r58"; }
[[ $1 = al  ]] && { fs0 "\($r47\|$r48\)"|fln "$r63" $2|sed -E "$r58"; }
[[ $1 = cl  ]] && { fs1 "$r32"          |fln "$r62" $2|sed -E "$r58"; }
[[ $1 = rl  ]] && { fs1 "$r33"          |fln "$r62" $2|sed -E "$r60"; }
[[ $1 = ll  ]] && { ll3                 |fln "$r62" $2|sed -E "$r60"; }
[[ $1 = ci  ]] && { ll2                 |fln "$r66" $2|sed -E "$r69"; }
[[ $1 = vi  ]] && { ll8                 |fln "$r66" $2|sed -E "$r69"; }
[[ $1 = clp ]] && { fs0 peers:                        |sed -E "$r59"|grep -v "peers: *$(ss5 $s12 target-peers 10)[${2:-0}-9]"; }
[[ $1 = elz ]] && { fs1 "\($r30\|$r31\)"|fln "$r62" $2; }
[[ $1 = alz ]] && { fs0 "\($r47\|$r48\)"|fln "$r63" $2; }
[[ $1 = clz ]] && { fs1 "$r32"          |fln "$r62" $2; }
[[ $1 = rlz ]] && { fs1 "$r33"          |fln "$r62" $2; }
[[ $1 = llz ]] && { ll3                 |fln "$r62" $2; }
[[ $1 = ciz ]] && { ll2                 |fln "$r66" $2; }
[[ $1 = viz ]] && { ll8                 |fln "$r66" $2; }
[[ $1 = ws  ]] && { cex 'ufw status numbered'; }
[[ $1 = wa  ]] && { wa; }
[[ $1 = we  ]] && { yex 'ufw enable'; }
[[ $1 = wpr ]] && { cex 'ufw disable'; }
[[ $1 = wds ]] && { cex 'ufw disable'; }
[[ $1 = wl  ]] && { wlp ${@:2:$#}; }
# journal
[[ $1 = yj  ]] && { jsh; }
[[ $1 = ej  ]] && { jsh "-u $s10 -u $s12 -u $s13"; }
[[ $1 = gj  ]] && { jsh "-u $s10"; }
[[ $1 = uj  ]] && { jsh "-u $s11"; }
[[ $1 = bj  ]] && { jsh "-u $s12"; }
[[ $1 = vj  ]] && { jsh "-u $s13"; }
[[ $1 = sj  ]] && { jsh "-u $s20"; }
[[ $1 = mj  ]] && { jsh "-u $s14"; }
# arranca
[[ $1 = ga  ]] && { dmr;ga; }
[[ $1 = ua  ]] && { dmr;ua; }
[[ $1 = ba  ]] && { dmr;ba; }
[[ $1 = va  ]] && { dmr;va; }
[[ $1 = pa  ]] && { dmr;pa; }
[[ $1 = na  ]] && { dmr;na; }
[[ $1 = fa  ]] && { dmr;fa; }
[[ $1 = xa  ]] && { dmr;xa; }
[[ $1 = ra  ]] && { dmr;ra; }
[[ $1 = sa  ]] && { dmr;sa; }
[[ $1 = ma  ]] && { dmr;ma; }
# para & arranca & journal
[[ $1 = gaj ]] && { dmr;ga;jsh "-u $s10"; }
[[ $1 = uaj ]] && { dmr;ua;jsh "-u $s11"; }
[[ $1 = baj ]] && { dmr;ba;jsh "-u $s12"; }
[[ $1 = vaj ]] && { dmr;va;jsh "-u $s13"; }
[[ $1 = saj ]] && { dmr;sa;jsh "-u $s20"; }
[[ $1 = maj ]] && { dmr;ma;jsh "-u $s14"; }
[[ $1 = gpa ]] && { gp;dmr;ga;jsh "-u $s10"; }
[[ $1 = upa ]] && { up;dmr;ua;jsh "-u $s11"; }
[[ $1 = bpa ]] && { bp;dmr;ba;jsh "-u $s12"; }
[[ $1 = vpa ]] && { vp;dmr;va;jsh "-u $s13"; }
[[ $1 = spa ]] && { sp;sa; }
[[ $1 = mpa ]] && { mp;dmr;ma;jsh "-u $s14"; }
[[ $1 = gpd ]] && { gp;gd; }
[[ $1 = upd ]] && { up;ud; }
[[ $1 = bpd ]] && { bp;bd; }
[[ $1 = vpd ]] && { vp;vd; }
[[ $1 = xpd ]] && { xp;xd; }
[[ $1 = rpd ]] && { rp;rd; }
[[ $1 = spd ]] && { sp;sd; }
[[ $1 = mpd ]] && { mp;md; }
[[ $1 = gea ]] && { ge;dmr;ga;jsh "-u $s10"; }
[[ $1 = uea ]] && { ue;dmr;ua;jsh "-u $s11"; }
[[ $1 = bea ]] && { be;dmr;ba;jsh "-u $s12"; }
[[ $1 = vea ]] && { ve;dmr;va;jsh "-u $s13"; }
[[ $1 = rea ]] && { re;dmr;ra; }
[[ $1 = sea ]] && { se;dmr;sa; }
[[ $1 = xea ]] && { xe;dmr;xa; }
[[ $1 = mea ]] && { me;dmr;ma;jsh "-u $s14"; }
# enable
[[ $1 = ge  ]] && { ge; }
[[ $1 = ue  ]] && { ue; }
[[ $1 = be  ]] && { be; }
[[ $1 = ve  ]] && { ve; }
[[ $1 = pe  ]] && { pe; }
[[ $1 = ne  ]] && { ne; }
[[ $1 = fe  ]] && { fe; }
[[ $1 = xe  ]] && { xe; }
[[ $1 = re  ]] && { re; }
[[ $1 = se  ]] && { se; }
[[ $1 = me  ]] && { me; }
# para
[[ $1 = fpr ]] && { fp; }
[[ $1 = npr ]] && { np; }
[[ $1 = ppr ]] && { pp; }
[[ $1 = vpr ]] && { vp; }
[[ $1 = bpr ]] && { bp; }
[[ $1 = gpr ]] && { gp; }
[[ $1 = upr ]] && { up; }
[[ $1 = xpr ]] && { xp; }
[[ $1 = rpr ]] && { rp; }
[[ $1 = spr ]] && { sp; }
[[ $1 = mpr ]] && { mp; }
# disable
[[ $1 = fds ]] && { fd; }
[[ $1 = nds ]] && { nd; }
[[ $1 = pds ]] && { pd; }
[[ $1 = vds ]] && { vd; }
[[ $1 = bds ]] && { bd; }
[[ $1 = gds ]] && { gd; }
[[ $1 = uds ]] && { ud; }
[[ $1 = xds ]] && { xd; }
[[ $1 = rds ]] && { rd; }
[[ $1 = sds ]] && { sd; }
[[ $1 = mds ]] && { md; }
[[ $1 = lup ]] && { apt list --upgradable; }

if [[ ! $1 ]];then
  m="primeira letra"
  m="$m\ne\t\t$s10 $s12 $s13"
  m="$m\ng\t\t$s10"
  m="$m\nu\t\t$s11"
  m="$m\nb\t\t$s12"
  m="$m\nv\t\t$s13"
  m="$m\np\t\t$s16"
  m="$m\nn\t\t$s17"
  m="$m\nf\t\t$s18"
  m="$m\nx\t\t$s21"
  m="$m\nr\t\t$s15"
  m="$m\ns\t\t$s20"
  m="$m\nm\t\t$s14"
  m="$m\nsegunda letra"
  m="$m\na[j]\t\tarranca\t[& journal]"
  m="$m\ne\t\tenable"
  m="$m\nj\t\tjournal"
  m="$m\npr\t\tpara"
  m="$m\nds\t\tdisable"
  m="$m\npd\t\tpara\t& disable"
  m="$m\npa\t\tpara\t& arranca\t& journal"
  m="$m\nea\t\tenable\t& arranca\t& journal"
  m="$m\noutros"
  m="$m\ngl[f]\t\tec log report"
  m="$m\ngpn\t\t$s10 pruNe DB - TAKES HOURS"
  m="$m\ngpg\t\t$s10 purGe DB - KEEP ANCIENT"
  m="$m\ngrs [n] [g]\t$s10\t\t\trestart\twith n peers, mim gap time"
  m="$m\nurs [n] [g]\t$s11\t\t\trestart\twith n peers, mim gap time"
  m="$m\nbrs [n] [g]\t$s12\t\t\trestart\twith n peers, mim gap time"
  m="$m\ncrs [n] [g]\t$s12/$s13\trestart\twith n peers, mim gap time"
  m="$m\ngrb [g]\t\tsystem & geth\t\t\treboot\tmim gap time"
  m="$m\nurb [g]\t\tsystem & besu\t\t\treboot\tmim gap time"
  m="$m\nbrb [g]\t\tsystem & beacon\t\t\treboot\tmim gap time"
  m="$m\nivk [g]\t\timport validator keys\t\tmim gap time"
  m="$m\nirb [h]\t\tsystem (if needed)\t\treboot\tafter h hours"
  m="$m\nr[sh|pt|st]\tshow|print|stop restart info (time & next gap without validator tasks)"
  m="$m\nyj\t\tsystem journal"
  m="$m\nsl\t[hh:mm]\tsystem journal\tlog lines"
  m="$m\nll\t[hh:mm]\tel/cl\t\tlog lines (last 7 days)"
  m="$m\n[ecr]l\t[hh:mm]\tec/cc/relay\tlog lines"
  m="$m\n[cv]i\t[hh:mm]\tcc/vc\tlog lines (internal)"
  m="$m\nbrl\t\trecalculate cc logs"
  m="$m\nbrm\t\trecalculate cc-daily logs"
  m="$m\nbsl\t\tshrink cc log using barqivo"
  m="$m\nbdl yyyy-mm-dd\tdelete cc log day"
  m="$m\nbio [lines]\timported/observed delays (using [lines] from intern log)"
  m="$m\nbo  [lines]\thomologous report [with max lines]"
  m="$m\nbon [node]\thomologous node report"
  m="$m\nboc [hour]\thomologous hour report"
  m="$m\nbol\t\thomologous 23:58 report"
  m="$m\nbod [p] [n] \tdelete logs for last penalty >= p(0) && node days > n(1)"
  m="$m\nbo[cl]\t\tall homologous nodes report at [current|last] time"
  m="$m\nbm[f]\t\tcc-daily report [file add & $s12 nodes change/restart]"
  m="$m\nbn[f]\t\tarqivo report [file add]"
  m="$m\n[gubvm]l[f]\t[geth|besu|beacon|vc|mev]\tmy progress report [file add]"
  m="$m\n[gubvm]h\t[geth|besu|beacon|vc|mev]\tmy historic report"
  m="$m\nhs[012ecgubvm]\thistoric summary report [0-both|1-main|2-backup|el|cc|geth|besu|beacon|vc|mev]"
  m="$m\nclp [i]\t\tshow peers excluding [$(ss5 $s12 target-peers 10)][i(0)-9]"
  m="$m\ncla\t\tcc add    long-lived parms"
  m="$m\nclr\t\tcc remove long-lived parms"
  m="$m\ncce\t\tcc change ec server ($znm1/$znm4)"
  m="$m\nvcc\t\tvc switch cc server order"
  m="$m\ntvc\t\tvc transfer ($cuvc -> $nxvc)"
  m="$m\nmvr\t\tvc mev validator registration"
  m="$m\nws\t\tfirewall status"
  m="$m\nwa\t\tfirewall arranca"
  m="$m\nwpr\t\tfirewall para"
  m="$m\ncpe [cp]\tclock & cpu & errors status"
  m="$m\nlp\t\tlista portas"
  m="$m\neip\t\tset dynamic DNS"
  m="$m\nnsh\t\tnetwork/route/DNS show "
  m="$m\ndsh [url]\tdns show"
  m="$m\nnrs\t\tdns/netplan reset"
  m="$m\ndrs\t\tdns reset"
  m="$m\ntrs\t\ttime sync restart"
  m="$m\ntsh\t\ttime sync show "
  m="$m\ntmp\t\ttemperature show"
  m="$m\nchk\t\tcheck server with chkrootkit"
  m="$m\nlup\t\tcheck apt list --upgradable"
  m="$m\nsnr\t\tremove snapd"
  swn "\n$m\n"
fi
