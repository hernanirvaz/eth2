#!/bin/bash

source /home/eth/eth2/t1

function nu0 { if [ ${1:-0} -eq $1 ] 2>$s3;then echo $1;else echo 0;fi; }                                                                                     # get numeric output (must use [ ] test)
function nu1 { echo "scale=$2;$1"|bc; }                                                                                                                       # get arbitrary precision calculations
function nu2 { if [[ $# -gt 0 ]];then nu5 "sqrt(((0$(printf '+%i^2' $@))-(0$(printf '+%i' $@))^2/$#)/$#)" 1000 5;else echo 0;fi; }                            # get standard deviation list of numbers
function nu3 { if [[ $# -gt 0 ]];then nu5 "(0$(printf '+%i' $@))/$#"                                            ;else echo 0;fi; }                            # get average            list of numbers
function nu4 { if [[ $5 -gt 0 ]];then nu5 "($1*$pmis+$2*$pmat+$3*$pmah+$4*$pdly)/$5*$rate/$decp"          1000 5;else echo 0;fi; }                            # get penalty
function nu5 { printf ${4:-%.0f} $(nu1 $1*${2:-1} ${3:-1}); }                                                                                                 # format arbitrary precision calculations
function fs0 { pex "grep ${3:-lighthouse}.*$1 $s1"|if [[ ${2:-0} -le 0 ]];then cat;else tail -n${2:-0};fi; }                                                  # get specific syslog lines
function fs1 { pex "grep -i $o3 $s1"; }                                                                                                                       # get eth      syslog lines
function fs2 { pex "grep -v $o3 $s1"; }                                                                                                                       # get sys      syslog lines
function fs3 { fs2|tail -n300|grep Core.*temperature; }                                                                                                       # get tail cpu syslog lines
function fs4 { fs0 $1|lg1 .*$1; }                                                                                                                             # get peers    syslog lines
function fs5 { fs3                       |wc -l; }                                                                                                            # get # temperature messages
function fs6 { fs2|grep usb|grep -i error|wc -l; }                                                                                                            # get # usb errors
function lg0 { grep $1 $p5 2>$s3|tail -n1|lg1 $1; }                                                                                                           # get last     number from log
function lg1 { sed "s%$1 *\([0-9]*\).*%\1%" $2 2>$s3; }                                                                                                       # get list of numbers from log
function rl0 { local n=${1:-0};((n<5)) && rl0 $((n+1));local e=$p7/logs/beacon.log;((n>0)) && e="$e.$n";echo $H|sudo -S cat $e 2>$s3; }                       # get beacon   intern lines
function rl1 { local n=${1:-0};((n<7)) && rl1 $((n+1));local e=$s1;((n>0)) && e="$e.$n";echo $H|sudo -S grep -i $o3 $e 2>$s3; }                               # get all eth  syslog lines
function pt0 { until [[ $# -le 1 || $1 =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]];do shift;done;echo $1; }                                                            # yyyy-mm-dd test
function pt1 { until [[ $# -le 1 || $1 =~ ^[0-9]{2}:[0-9]{2}$          ]];do shift;done;echo $1; }                                                            # hh:mm      test
function pt2 { until [[ $# -le 1 || $1 =~ ^[0-9]+$                     ]];do shift;done;echo $1; }                                                            # integer    test
function pt3 { until [[ $# -le 1 || $1 =~ ^[a-z]+$                     ]];do shift;done;echo $1; }                                                            # string     test
function dts { read d0 d1 <<< ${1:-$(date '+%F %H:%M')};dt="$d0 $d1"          ; }                                                                             # set date/time         vars
function bnn { nr=${@:$#};nm=$(printf '%i\n' $@|sort -n|head -n1);nd=$(nu2 $@); }                                                                             # set cur/min/std peers vars
function dnn { echo "$dt $(printf 'node%02i:' $nn) $(printf '%2i' $nr)"       ; }                                                                             # get date/nodes info
function dmr { sex "$w0 daemon-reload"                       ; }                                                                                              # daemon-reload
function jsh { cex "journalctl --no-hostname --no-full -f $1"; }                                                                                              # my journal   format
function spc { nn=$2;cp $s4/$1.service $p0/$1.sav;sed "s%peers *[0-9]*%peers $2%" $p0/$1.sav > $s4/$1.service; }                                              # service configuration change
function spp { resolvectl query smtp.gmail.com &>$s3;sex "$w2 $1";dmr                                        ; }                                              # service process stop/load
function snp { local n=$(($2+nn));(($2!=0&&n>=$3&&n<=$4)) && spc $1 $n;spp $1                                ; }                                              # service node change/stop/load
function srt { [[ -f $s5 ]]; }                                                                                                                                # system needs reboot test
function sra { if srt;then echo $(($(date +%s)-$(date -r $s5 +%s)));else echo 0;fi }                                                                          # system reboot age (secounds)
function sot { [[ $(sra) -ge $((60*60*${1:-24})) ]]; }                                                                                                        # 24 hours old system reboot test
function stt { [[ $d1 =~ 23:5[89] ]]; }                                                                                                                       # time test
function sst { $w1 $1 2>$s3|grep "${2:-inactive\|failed}"; }                                                                                                  # service status word test
function ss1 { $w1 $1 2>$s3|sed -n "s%.*$2 \(${3:-.}*\).*%\1%p"; }                                                                                            # service status 1 extraction
function ss2 { $w1 $1 2>$s3|sed -n "s%.*Active: *\(.*\)%\1%;s% *since.*;%%p"; }                                                                               # service status 2 extraction
function ss3 { printf '%s' "$(printf '%-30s' "$(ss2 $1)") $(printf '%9s' ${1/[a-z]*-/})"; }                                                                   # service status 2 extraction formated
function sgx { geth attach --exec net.peerCount "http://$cuec:8545" 2>$s3; }                                                                                  # get el current peers
function sbx { pex "grep lighthouse.*$1 $s1"|tail -n1|sed "s%.*$1 *\([0-9]*\).*%\1%"; }                                                                       # get cl current peers
function sso {
  dts;local e="$1 $(printf '%6s' $(ss1 $2 Memory:)) $dt status: $(ss3 $2)"                                                                                    # memory & status
  [[ $1 = GETH ]] && e="$e $(printf 'el:m%ic%i:p2p:%i' $(ss1 $2 peers [0-9]) $(sgx) $(ss1 $2 port [0-9]))"                                                    # el peers tag & p2p port tag
  [[ $1 = BEAC ]] && e="$e $(printf 'cl:m%ic%i:p2p:%i' $(ss1 $2 peers [0-9]) $(sbx peers:) $(ss1 $2 port [0-9]))"                                             # cl peers tag
  [[ $1 = BEAC ]] && e="$e el:http $(ss1 $2 endpoints* '[^ ]'|sed -n 's%http://192.168.8.\([0-9]*:[0-9]*\)%\1%gp')"                                           # el http(s)
  [[ $1 = VALI ]] && e="$e cl:http $(ss1 $2 nodes '[^ ]'|sed -n 's%http://192.168.8.\([0-9]*:[0-9]*\)%\1%gp')";swn "$e"                                       # cl http(s)
}
function ssp {
  swu 'QUER MESMO TRANSFERIR VALIDATORS?';read rsp
  if [[ $rsp = sim && ! -f $p1/vc_slash && ! -f $p1/vc_lock && -f $p1/vc_keys ]];then
    vp;vd
    swu 'SAVE SLASHING PROTECTION DB'
    sex "cp $p8/slashing_protection.sqlite $p0"
    sex "chown eth:eth $p0/slashing_protection.sqlite"
    scp $p0/slashing_protection.sqlite $2:~
    swu 'SAVED SLASHING PROTECTION DB IN $2'
  fi
}

# geth control commands
function gy  { geth attach --exec eth.syncing   "http://$cuec:8545" 2>$s3; }                                                                                  # get current syncing status
function gv  { nn=$(nu0 $(ss1 $n0 maxpeers [0-9])); }                                                                                                         # set configured peers
function gq  { nr=$(nu0 $(sgx))                   ; }                                                                                                         # set current    peers
function gi  { echo $@|sed 's%.*highestBlock: *\([0-9]*\).*%\1%'; }                                                                                           # get highest geth block
function gc  { echo $@|sed 's%.*currentBlock: *\([0-9]*\).*%\1%'; }                                                                                           # get current geth block
function gb  { g0=$(fs0 Imported 0 geth|wc -l);ok=OK;[[ $g0 -eq $(lg0 .*sgs:) ]] && ok=BK; }                                                                  # imported new chain segments & OK/BK
function gh0 { [[ -f $p5 ]] || return;tail -n${1:-$hors} $p5;[[ $1 ]] && return;gl0;swn "$m\n";sso GETH $n0;cpe; }                                            # geth historic report
function gl0 {                                                                                                                                                # geth report
  dts;ok=OK;if [[ $(sst $n0 running) ]];then local e=$(gy);gb;gv;gq;m="$(dnn) sgs: $(printf '%4i' $g0)"
    if [[ $(echo $e|grep false) ]];then m="GETH $ok SYC $m";else m="GETH $ok NSY $m blocks: $(($(gi $e)-$(gc $e)))";fi                                        # OK SYC/NSY (dnn) sgs: 5 blocks: 8 (6)
  else
    m="GSRV NOT ON $dt"
  fi
}
function glt { tail -n$1 $p5 2>$s3|cut -d' ' -f1|sort -u|wc -l; }                                                                                             # get geth restart activity test
function grt { [[ $(glt 6) -eq 1 ]] && sot 6; }                                                                                                               # 6 hours old system reboot test
function grb { ok=OK;swn "RSTR SYSTEM $(dnn)" >> $p5;sex reboot; }                                                                                            # geth system reboot
function grs { gv;snp $n0 $1 10 50;sex "$w3 $n0";sleep 20s;dts;gq;[[ -f $p5 ]] && swn "RSTR SERVIC $(dnn)" >> $p5; }                                          # change/stop/load/start/log geth
# beacon control commands
function bz  { echo $((10*(5*zk+2*zz+zx+zw)))                                       ; }                                                                       # get numerator paid errors
function bw  { echo $((10*z1))                                                      ; }                                                                       # get numerator processed blocks
function bf  { echo $((90*z3))                                                      ; }                                                                       # get numerator general errors
function bi  { echo $((nd+zk*300+zz*20+zx))                                         ; }                                                                       # get delete day idx
function bu  { echo $(((z5>400?$(bz)/z5:0)+(z2>300?$(bw)/z2:0)+(z4>999?$(bf)/z4:0))); }                                                                       # get restart idx
function bv  { nu0 $(ss1 $n1 target-peers [0-9]); }                                                                                                           # get configured peers
function bb  { l0=$(fs0 $bpid] 3600);bl1;bl2;[[ (1 -eq $(bl6 $hors) && $(bu) -ge 1) || (1 -eq $(bl6 5) && $(bu) -ge 5) ]] && ok=BK; }                         # set ok (OK/BK)
function bbl { cat $p2 2>$s3|wc -l; }                                                                                                                         # get beacon line count
function bml { cat $p3 2>$s3|wc -l; }                                                                                                                         # get medias line count
function bfl { grep "BEAC.*$1"    ; }                                                                                                                         # filter beacon lines
function bff { grep "BEAC.*$1" $p2; }                                                                                                                         # filter beacon log
function bl0 { dts;ok=OK;if [[ $(sst $n1 running) ]];then bl3;nn=$(bv);bnn $(fs4 peers:);bb;blo;else m="BSRV NOT ON $dt";fi; }                                # beacon report
function bl1 {                                                                                                                                                # set restart idx vars
  z1=${1:-$(echo "$l0"|grep 'rocessed block'|wc -l)};z2=${2:-$(echo "$l0"|grep 'block received'|wc -l)};z3=${3:-$(echo "$l0"|grep -v ' INFO ' |wc -l)}        # set processed/received blocks,error lines
  z4=${4:-$(echo "$l0"|grep    ' INFO '     |wc -l)};z5=${5:-$(bl7 success)};ok=${6:-OK}                                                                      # set info lines,success/had activities
}
function bl2 { zk=${1:-$(bl7 missing)};zz=${2:-$(bl7 target)};zx=${3:-$(bl7 head)};zw=${4:-$(bl7 had)}; }                                                     # set missing/target/head activities
function bl3 { b0=${1:-$(fs0 Valid.block|wc -l)};b1=${2:-$(nu3 $(fs4 delay_ms:))}; }                                                                          # set published blocks/avg delays
function bl5 { sed 's%.*validators: *\[\(.*\)\].*%\1%'|wc -w; }                                                                                               # get number of validators
function bl6 { tail -n$1 $p2 2>$s3|cut -d' ' -f1|sort -u|wc -l; }                                                                                             # get beacon restart activity
function bl7 { fs0 attestation.s.*$1|bl5; }                                                                                                                   # get number of paid activities
#    0  1   2          3     4       5  6               7    8    9                  10   11  12 13  14 15 16  17 18 19  20  21 22   23   24     25  26
# BEAC OK   0 2022-02-17 23:40 node45: 48 reward_penalty: 3037 2315 attestation_blocks: 3996 1340 0 err: 0  6 102 14  0 352   0  4 3596  360 delay: 332
function blo {
  m="BEAC $ok $(printf '%3i' $(bu)) $(dnn) reward_penalty: $(nu5 "($z5*$ratt+$b0*$rblk)*$rate/$decp" 10 2 %4.0f)"
  m="$m $(printf '%4i' $(nu4 $zk $zz $zx $zw 1)) attestation_blocks: $(printf '%4i' $z5) $(printf '%4i' $(bz)) $(printf '%1i' $b0)"
  m="$m err: $(printf '%1i' $zk) $(printf '%2i' $zz) $(printf '%3i' $zx) $(printf '%2i' $zw) $(printf '%2i' $z1) $(printf '%3i' $z2)"
  m="$m $(printf '%3i' $(bw)) $(printf '%2i' $z3) $(printf '%4i' $z4) $(printf '%4i' $(bf)) delay: $(printf '%3i' $b1)"
}
function bcc { if bct       ;then echo c;else echo _;fi; }                                                                                                    # get change configured peers char
function bdc { if bht && bst;then echo d;else echo _;fi; }                                                                                                    # get delete beacon log day   char
function bmi { zk=0;zz=0;zx=0;unset o;o[1]=0;unset k;k[0]=0;unset z;z[0]=0;unset x;x[0]=0;unset w;w[0]=0;unset c;c[0]=0;unset a;a[0]=0;bm6; }                 # ini err/cnt/avg penalty arrays
function bm0 {                                                                                                                                                # medias report
  [[ -f $p2 ]] || return
  bmi;b4=0;b5=$(fs0 reduce|wc -l);dts;nn=$(bv);bnn $(fs4 peers:);bl2;[[ -f $p6 ]] && bm4;l3=$(tail -n$(($(bbl)-o[1])) $p2 2>$s3|bfl);[[ $l3 ]] && bm1;bm2     # ini vars/arrays & add beacon lines
  bo4;bm5 ${a[$nn]};b7="rm$(bdc)$(bcc)$(date +%w)_peers:"                                                                                                     # homologous/avg position & outputs
}
function bm1 {
  local g=${1:-$bpri};l1=$(echo "$l3"|sed -nEe "s%.+node$g:.+err: +([0-9]+) +([0-9]+) +([0-9]+) +([0-9]+).+%\1\t\2\t\3\t\4%p")                                # set paid errors for current array
  [[ $l1 ]] && { bkm $g;bzm $g;bxm $g;bwm $g;bcm $g; };((g<bprf)) && bm1 $((g+bprs))                                                                          # recursively sum paid err arrays
}
function bm2 { k[0]=$(($(bnk)));z[0]=$(($(bnz)));x[0]=$(($(bnx)));w[0]=$(($(bnw)));c[0]=$(($(bnc)));a[0]=$(bm3 0);bm7; }                                      # tot err/cnt/penalty arrays
function bm3 { nu4 ${k[$1]} ${z[$1]} ${x[$1]} ${w[$1]} ${c[$1]} ; }                                                                                           # get penalty from paid err arrays
function bm4 { read -a o <<< $(tail -n1 $p6);bmk;bmz;bmx;bmw;bmc; }                                                                                           # set err/cnt penalty arrays from barqivo
function bm5 { local g=${2:-$bpri};local n=$1;if ((a[g]<n));then b4=$((g-nn));n=${a[$g]};fi;((g<bprf)) && bm5 $n $((g+bprs)); }                               # set recursively peer change <- min penalties
function bm6 { local g=${1:-$bpri};k[$g]=0;z[$g]=0;x[$g]=0;w[$g]=0;c[$g]=0;a[$g]=0         ;((g<bprf)) && bm6    $((g+bprs)); }                               # ini recursively penalty arrays
function bm7 { local g=${1:-$bpri};a[$g]=$(bm3 $g)                                         ;((g<bprf)) && bm7    $((g+bprs)); }                               # avg recursively penalty arrays
function bcm { local g=${1:-$bpri};((c[g]+=$(echo "$l1"|wc  -l)                       )); }                                                                   # sum               cnt array
function bkm { local g=${1:-$bpri};((k[g]+=$((0$(printf '+%i' $(echo "$l1"|cut -f1)))))); }                                                                   # sum missing       err array
function bzm { local g=${1:-$bpri};((z[g]+=$((0$(printf '+%i' $(echo "$l1"|cut -f2)))))); }                                                                   # sum failed target err array
function bxm { local g=${1:-$bpri};((x[g]+=$((0$(printf '+%i' $(echo "$l1"|cut -f3)))))); }                                                                   # sum failed head   err array
function bwm { local g=${1:-$bpri};((w[g]+=$((0$(printf '+%i' $(echo "$l1"|cut -f4)))))); }                                                                   # sum delay         err array
function bmc { local g=${1:-$bpri};local n=${2:-5 };c[$g]=${o[$n]};((g<bprf)) && bmc $((g+bprs)) $((n+1)); }                                                  # set recursively               cnt array
function bmk { local g=${1:-$bpri};local n=${2:-13};k[$g]=${o[$n]};((g<bprf)) && bmk $((g+bprs)) $((n+1)); }                                                  # set recursively missing       err array
function bmz { local g=${1:-$bpri};local n=${2:-21};z[$g]=${o[$n]};((g<bprf)) && bmz $((g+bprs)) $((n+1)); }                                                  # set recursively failed target err array
function bmx { local g=${1:-$bpri};local n=${2:-29};x[$g]=${o[$n]};((g<bprf)) && bmx $((g+bprs)) $((n+1)); }                                                  # set recursively failed head   err array
function bmw { local g=${1:-$bpri};local n=${2:-37};w[$g]=${o[$n]};((g<bprf)) && bmw $((g+bprs)) $((n+1)); }                                                  # set recursively delay         err array
function bma { local g=${2:-$bpri};if ((g<=bprf));then bma "$1 $(printf '%4i' ${a[$g]})" $((g+bprs));else echo "$1";fi; }                                     # sum recursively penalty       avg array
function bnc { local g=${3:-$bpri};if ((g<=bprf));then bnc "${1:-0}${2:-+}${c[$g]}" "$2" $((g+bprs));else echo "$1";fi; }                                     # sum recursively               cnt array
function bnk { local g=${3:-$bpri};if ((g<=bprf));then bnk "${1:-0}${2:-+}${k[$g]}" "$2" $((g+bprs));else echo "$1";fi; }                                     # sum recursively missing       err array
function bnz { local g=${3:-$bpri};if ((g<=bprf));then bnz "${1:-0}${2:-+}${z[$g]}" "$2" $((g+bprs));else echo "$1";fi; }                                     # sum recursively failed target err array
function bnx { local g=${3:-$bpri};if ((g<=bprf));then bnx "${1:-0}${2:-+}${x[$g]}" "$2" $((g+bprs));else echo "$1";fi; }                                     # sum recursively failed head   err array
function bnw { local g=${3:-$bpri};if ((g<=bprf));then bnw "${1:-0}${2:-+}${w[$g]}" "$2" $((g+bprs));else echo "$1";fi; }                                     # sum recursively delay         err array
#    0  1   2          3     4       5  6               7    8    9   10   11   12   13   14          15   16          17 18 19   20  21
# BEAC 19  32 2022-06-04 11:05 node60: 64 median_penalty: 1408 1475 1443 1251 1093 1156 1726 all_median: 1289 rm__6_peers: 0 59 1578   0
function bmo {
  m="BEAC $(printf '%2i' $b3) $(printf '%3i' $b2) $(dnn) $(bma 'median_penalty:') all_median: $(printf '%4i' ${a[0]})"
  m="$m $b7 $b5 $(printf '%2i' $nm) $(printf '%4i' $(bi)) $(printf '%3i' $b4)"
}
#    0  1   2          3     4       5  6        7    8    9   10          11 12 13   14  15
# BEAC 19  32 2022-06-04 11:04 node60: 65 penalty: 1093 avg: 1289 rm__6_peers: 0 59 1579   0
function bms {
  m="BEAC $(printf '%2i' $b3) $(printf '%3i' $b2) $(dnn) penalty: $(printf '%4i' ${a[$nn]}) avg: $(printf '%4i' ${a[0]})"
  m="$m $b7 $b5 $(printf '%2i' $nm) $(printf '%4i' $(bi)) $(printf '%3i' $b4)"
}
#    0   1          2     3    4 5 6 7 8 9 10 11   12 13 14 15 16 17 18 19   20 21 22 23 24 25 26 27   28 29 30 31 32 33 34 35   36 37 38 39 40 41 42 43
# BEAC 682 2022-03-16 11:03 cnt: 4 7 0 0 0 10 10 mis: 20 20 20 20 20 20 20 mat: 14 45 30 30 30 30 30 mah: 94 68 40 40 40 40 40 dly: 79 09 50 50 50 50 50
function bno { m="BEAC $(printf '%6i' $(bbl)) $dt $(bnc 'cnt:' ' ') $(bnk 'mis:' ' ') $(bnz 'mat:' ' ') $(bnx 'mah:' ' ') $(bnw 'dly:' ' ')"; }
function boi {
  unset v;read -a v <<< $(bff|tail -n1);local n=0;local t=${1:-00:00};[[ $t = 00:00 ]] && t=${v[4]};b6=0;l2=$(bff $t)                                         # set homologous lines
  while [[ ${b2:=0} -eq 0 && $n -lt 500 ]];do bo2 ${v[3]};((n+=1));v[3]=$(date -d "$n days ago $t" +%F);done                                                  # set homologous position
}
function bo0 { [[ -f $p2 ]] || return;boi $(pt1 $@ 00:00);if [[ $(pt3 $@ s) = n ]];then b6=$b2;else b6=$(pt2 $@ 0);fi;bo6; }                                  # homologous report
function bo1 { echo "$l2"|sort -k10n -k4r; }                                                                                                                  # get homologous beacon lines sorted
function bo2 { b2=$(bo1|grep -n $1|cut -d: -f1); }                                                                                                            # set homologous position
function bo3 { b3=$(nu3 ${b2:=0} $(lg1 BEAC\ *[0-9]* $p3)); }                                                                                                 # set homologous avg
function bo4 { [[ ${b2:=0} -eq 0 && -f $p2 ]] && boi;bo3; }                                                                                                   # set homologous position/avg
function bo5 { l2=$(bff $d1);bo2 $d0;bo3; }                                                                                                                   # set homologous position/avg
function bo6 { bo1|head -n$((b6>b2?b6:b2<5?5:b2))|tail -n$((b6>0?b6:b2>hors?hors:b2<5?5:b2)); }                                                               # homologous report
function bo7 { bo1|grep $(printf 'node%02i:' $1); }                                                                                                           # get homologous node lines sorted
function bon { [[ -f $p2 ]] || return;nn=$(pt2 $1 $(bv));l2=$(bff 23:58);bo7 $nn; }                                                                           # homologous nodes report
function boa { local g=${1:-$bpri};echo "BO$(printf '%5i' $(bo7 $g|wc -l)) $(printf '%3i' $g)";bo7 $g;((g<bprf)) && boa $((g+bprs)); }                        # recursively show homologous nodes report
function bh0 {
  [[ -f $p2 ]] || return;tail -n${1:-$hors} $p2;[[ $1 ]] && return                                                                                            # last beacon            report
  boi;swn "BO$(printf '%5i' $(echo "$l2"|wc -l)) $(printf '%3i' $b2)$(printf '%91s')x5 x2  x1 x1";bo6                                                         # homologous             report
  bl0;swn "BL$(printf '%9i' $(bbl))\n$m";bm0                                                                                                                  # current beacon         report
  bmo;swn "BM$(printf '%9i' $(bml))$(printf '%46s')i20  i30  i40  i50  i60  i70  i80\n$m";sso BEAC $n1;sso VALI $n3;cpe                                       # medias/services/system report
}
function brb { if srt;then echo RB;else echo $1;fi; }                                                                                                         # get reboot/other tag
function bro { dts;bb;bnn $(fs4 peers:);[[ -f $p2 ]] && swn "$(printf 'R%03i' $1) ${2:-$ok} $(printf '%3i' $(bu)) $(dnn)" >> $p2; }                           # log restart info
function bpt { [[ $(date +%s) -ge $(bss $1 6) ]]; }                                                                                                           # ideal position test (based on time)
function btg { echo $(date -d@${1:-0} +%M:%S|tr -d :)t$(date -d@$(($(date +%s)+${1:-0})) +%H:%M:%S|tr -d :); }                                                # get end file sleep tag
function bss { echo $((${2:-0}+$(date -d$(bf1 $1) +%s))); }                                                                                                   # get sum secounds + time
function bfn { local n=$(($(bss $1)-$(date +%s)));echo $((n>3?n:3)); }                                                                                        # get min seconds to future
function bmn { local n=${1:-24};echo $((n>360?360:n<24?24:n)); }                                                                                              # get max/min seconds to future (12x30/24)
function bf1 { echo ${1:-$(date +%H:%M:%S)}; }                                                                                                                # get filterd t7 parm 1
function bf2 { echo ${2:-24}; }                                                                                                                               # get filterd t7 parm 2
function bng { $p0/eth2/t7 2>$s3; }                                                                                                                           # get next gap
function bsc { pex "grep lighthouse.$bpid].*INFO $s1"|tail -n99|grep sync_committee|wc -l; }                                                                  # get # committee messages
function bsf { [[ ${1:-0} -gt 0 ]] || return;local e=$p4.s$(btg $1);touch $e;sleep $1s;rm -f $e; }                                                            # sleep with file info
function bsw { while :;do local t=$(bng);if [[ $(bf2 $t) -le ${1:-36} || ${2:-24} -ge $(bfn $t) ]];then bsf $(bmn $(bfn $t));else break;fi;done; }            # sleep while small (gap or remaining) time
: '
function bsf { [[ ${1:-0} -gt 0 ]] || return;local e=$p4.s$(btg $1);echo $(bf1) t$(btg $1) s$1;touch $e;sleep $1s;rm -f $e; }
function bsw { while :;do local t=$(bng);echo $(bf1) $(bf2 $t) -le ${1:-36} or ${2:-24} -ge $(bfn $t);if [[ $(bf2 $t) -le ${1:-36} || ${2:-24} -ge $(bfn $t) ]];then bsf $(bmn $(bfn $t));else echo $(bf1) break t$(btg $(bfn $t)) s$(bfn $t);break;fi;done; }
function b0r {
  [[ $(ls $p4.* 2>$s3) || $(bsc) -gt 0 ]] && return;bsf $3;local n=${4:-36};[[ $2 = VC ]] && n=60;[[ $2 = RB ]] && n=84;bsw $n;local t=$(bng)
  local e=$p4.i$(btg);echo $(bf1) i$(btg);touch $e;local n=0;while [[ -f $e ]];do ((n+=$(bfn $t)));echo $(bf1) while $(bf2 $t) n=$n;bsf $(bfn $t)
  if bpt $t;then rm $e;echo $(bf1) work;else echo $(bf1) continue;fi
  done;rm -f $e
}
# '
# slots = secounds 12,24,36,48,60,72,84,96,108,120,132,144
function b1r {                                                                                                                                                # beacon/validator gap restart
  [[ $(ls $p4.* 2>$s3) || $(bsc) -gt 0 ]] && return;bsf $3;local n=${4:-36};[[ $2 = VC ]] && n=60;[[ $2 = RB ]] && n=84;bsw $n;local t=$(bng)
  local e=$p4.i$(btg);touch $e;local n=0;paf;while [[ -f $e ]];do ((n+=$(bfn $t)));bsf $(bfn $t)
  if bpt $t;then rm $e;nn=$(bv);snp $n1 $1 $bpri $bprf           ;[[ $2 = VC ]] && sex "$w2 $n3"                                                              #         stop beacon/validator
    if [[ $2 = RB ]];then bro $n $2;sex reboot;else sex "$w3 $n1";[[ $2 = VC ]] && sex "$w3 $n3";bsf 20;bro $n $2;fi                                          # reboot/start beacon/validator
  fi;done;rm -f $e
}
function brh { head -n${1:-0} ${p2}r; }                                                                                                                       # new beacon head lines
function brl {                                                                                                                                                # recalculate beacon/medias logs
  [[ -f $p2 ]] || return;rm -f ${p2}r
  unset v;while read -a v;do ok=${v[1]};dts ${v[3]}\ ${v[4]};nn=${v[5]:4:2};nr=${v[6]}                                                                        # uncalculated vars
    if [[ ${v[0]} = BEAC ]];then
      bl1 ${v[19]} ${v[20]} ${v[22]} ${v[23]} ${v[11]} ${v[1]};bl2 ${v[15]} ${v[16]} ${v[17]} ${v[18]};bl3 ${v[13]} ${v[26]};blo                              # BEAC lines calculated output
    else
      if [[ ${v[0]} = BSRV ]];then
        m="${v[0]} ${v[1]} ${v[2]} $dt"                                                                                                                       # BSRV lines
      else
        m="${v[0]} $ok $(printf '%3i' ${v[2]}) $(dnn)"                                                                                                        # restart lines
      fi
    fi                                                                                           ;swn "$m" >> ${p2}r                                          # new beacon output
  done <<< $(cat $p2)
  [[ -f $p3 ]] || return;rm -f ${p3}r;bmi;local d=0000-00-00;local l=0;local n=0;local h=0;local g=0;while read -a o;do
    d=${o[3]};h=$g;g=$(grep -n "$d 23:58" ${p2}r|cut -d: -f1);[[ ${g:=$h} -le $h ]] && continue;dts $d\ ${o[4]};nn=${o[5]:4:2}                                # get next beacon log position
    nr=${o[6]};nm=${o[13]};nd=${o[14]};l2=$(brh $g|bfl 23:58);bo2 $d;((l+=b2));((n+=1));b3=$(nu5 $l/$n)                                                       # cur/avg homologous position
    l3=$(brh $g|tail -n$((g-h))|bfl);[[ $l3 ]] && bm1;bm2;b4=${o[15]};b5=${o[12]};b7=${o[11]};bms;swn "$m" >> ${p3}r                                          # sum err arrays & new medias output
  done <<< $(cat $p3)
}
function bsl {                                                                                                                                                # shrink beacon log using barqivo
  [[ -f $p2 && -f $p6 ]] || return;rm -f ${p2}s;tail -n$(($(cat $p2|wc -l)-$(tail -n1 $p6|cut -d' ' -f2))) $p2 > ${p2}s                                       # new beacon  log output
  rm -f ${p6}s;head -n$(($(cat $p6|wc -l)-1)) $p6 > ${p6}s;tail -n1 $p6|sed 's%BEAC [0-9]*%BEAC 0%' >> ${p6}s                                                 # new barqivo log output
}
function bnt { [[ $b4 -ne 0 ]]; }                                                                                                                             # peers need change test
function bht { [[ $b2 -gt $b3 ]]; }                                                                                                                           # homologous/avg position test
function bst { [[ $(bi) -ge 2500 ]]; }                                                                                                                        # peers standard deviation test
function btt { bnt && bht && ! bst; }                                                                                                                         # peers change global test
function bbt { [[ $(grep $d0 ${p2} 2>$s3|wc -l) -gt 0 ]]; }                                                                                                   # exists beacon log day test
function bct { local n=$((nn-5));[[ $nm -ge $n && $(bl6 $hors) -eq 1 ]] && ( btt || sot ); }                                                                  # change configured peers test
function bdl { local d=$(pt0 $1 sai);[[ -f $p2 && $d != sai ]] || return;cp $p2 ${p2}o;grep -v $d ${p2}o > $p2;grep $d ${p2}o > ${p2}d; }                     # delete beacon log day
function nsh { swn "ROUTES\t\t$(ip r|sed -n 's%.*default via \([^ ]*\) .*%\1%ip')";resolvectl dns|sed -n 's%.*(\(.*\)): \([0-9].*\)%\1\t\t\2%p'; }            # routes/dns info
function wst { echo $@|sed 's%[^: ]*: *%%g;s%,[^,]*(routed)%%;s% (incoming),% <<%;s% (outgoing)% >>%'; }
function cpe {                                                                                                                                                # system status
  local e='NO';[[ $(timedatectl|sed -n 's%.*synchronized: \([a-z]*\) *%\1%p') = yes ]] && e='OK';dts
  if [[ $(sst $n7 masked) ]];then m=$(ss3 ntp);else m=$(ss3 $n7);fi;swn "CLCK $e $(printf '%3i' $(fs0 clock|wc -l)) $dt status: $m"                           # CLCK info
  [[ $1 = c ]] && return;local l=0;local n=0;local v=0
  local d=$(fs3|grep throttled|head -n1|sed 's%.* \([0-9]*:[0-9]*\):[0-9]*.*%\1%')
  local e=$(fs3|grep normal   |tail -n1|sed 's%.* \([0-9]*:[0-9]*\):[0-9]*.*%\1%')
  local v=0;for v in $(sensors 2>$s3|sed -n "s%\($o4\).*: *\([-+][0-9][0-9]*\.[0-9]*\).*%\2%p");do ((n+=1));l=$(nu1 $l$v 1);done
  [[ $d ]] && d="throttled: $d";[[ $e ]] && e="normal: $e";swn "TEMP $(nu5 $l/$((n==0?1:n)) 1 2 %5.1fC) $dt $d $e"                                            # TEMP cpu info
  [[ $1 = p ]] && return
  if [[ $(cat $s6) -eq 0 ]];then e=off;else e=on;fi;if [[ $(cat $s7) -eq 1 ]];then d=off;else d=on;fi                                                         # usb/cpu current state
  m="INFO$(printf '%3i' $(fs6)) $(printf '%3i' $(fs5)) $dt"                                                                                                   # usb/cpu erros count
  m="$m usb $e, turbo $d, ufw: $(wst $(pex 'ufw status verbose'|grep -i 'status:\|default:'))"                                                                # usb/cpu/ufw info
  m="$m, uptime:$(uptime|sed 's%[0-9]*:[0-9]*:[0-9]*%%;s%[0-9]*:[0-9]*,%%;s%[0-9]* users*,%%;s% average\([^,]*\).*%\1%;s%  *% %g')";swn "$m"                  # uptime/load info
  local l=$(fs2|grep -i 'error' |wc -l);local n=$(fs1|grep -v ' INFO '|wc -l)
  local e=$(fs2|grep -i 'error' |tail -n1|sed 's%.*hrv-zotac[0-9] *\(.*\)%\1%;s%  *% %g'                         |cut -c1-70)
  local d=$(fs1|grep -v ' INFO '|tail -n1|sed 's%.*[0-9]*:[0-9]*:[0-9]*\.[0-9][0-9][0-9]]* *\(.*\)%\1%;s%  *% %g'|cut -c1-70)
  m="ERRO$(printf '%3i' $l) $(printf '%3i' $n) $dt";[[ $l -gt 0 ]] && m="$m system: $e";[[ $n -gt 0 ]] && m="$m ethrum: $d";(( l+n )) && swn "$m"             # sys/eth errors info
  m='';srt && m="$m, reboot $(($(sra)/60/60)) hours ago";[[ $(bsc) -gt 0 ]] && m="$m, committee on";[[ $m ]] && swn "INFO        $dt${m#*,}"                  # reboot/committee info
  [[ $(swn $(/usr/lib/update-notifier/apt-check --human-readable)) -gt 0 ]] && { echo;apt list --upgradable; }
}
# Plex Media Server
function xop { pde 32400 plex delete;pai 32400 192.168.8.0/24 plex       ;ide 192.168.8.0/24 1900/udp plex/upnp       ; }
function xcl { pde 32400 plex       ;pai 32400 192.168.8.0/24 plex delete;ide 192.168.8.0/24 1900/udp plex/upnp delete; }
function xe  { xop;sex 'ufw reload';cex "$w4 $o0"; }
function xa  { [[ $(sst $o0       ) ]] && { cex "$w3 $o0"; } }
function xp  { [[ $(sst $o0 loaded) ]] && { cex "$w2 $o0"; } }
function xd  { cex "$w5 $o0";xcl;sex 'ufw reload'; }
# Transmission BitTorrent Daemon
function rop { pae 51413 torrent;pde 9091 torrent delete;pai 9091 192.168.8.0/24 torrent       ; }
function rcl { pde 51413 torrent;pde 9091 torrent       ;pai 9091 192.168.8.0/24 torrent delete; }
function re  { rop;sex 'ufw reload';cex "$w4 $o1"; }
function ra  { [[ $(sst $o1       ) ]] && { cex "$w3 $o1"; } }
function rp  { [[ $(sst $o1 loaded) ]] && { cex "$w2 $o1"; } }
function rd  { cex "$w5 $o1";rcl;sex 'ufw reload'; }
# Bind9
function sop { pai 53 192.168.8.0/24 dns       ; }
function scl { pai 53 192.168.8.0/24 dns delete; }
function se  { sop;sex 'ufw reload';cex "$w4 $n8"; }
function sa  { [[ $(sst $n8 disabled) ]] || { [[ $(sst $n8) ]] && cex "$w3 $n8"; } }
function sp  { [[ $(sst $n8 loaded  ) ]] && { cex "$w2 $n8"; } }
function sd  { cex "$w5 $n8";scl;sex 'ufw reload'; }
# geth/beacon/validator
function gfw { if [[ $cust = hrv ]];then pai $1 192.168.8.0/24 $2 $3;else pai $1 $vip1 $2 $3;pai $1 $vip3 $2 $3;fi; }
function gop { local e=30303;[[ $cunm = $znm1 ]] || e=30304;pae $e elp2p;pde 8545 elapi delete;pde 8551 eljwt delete;gfw 8545 elapi       ;gfw 8551 eljwt       ; }
function gcl { local e=30303;[[ $cunm = $znm1 ]] || e=30304;pde $e elp2p;pde 8545 elapi       ;pde 8551 eljwt       ;gfw 8545 elapi delete;gfw 8551 eljwt delete; }
function bfw { if [[ $cust = hrv ]];then pai $1 192.168.8.0/24 $2 $3;else pai $1 $vip3 $2 $3;fi; }
function bop { local e=9000 ;[[ $cunm = $znm3 ]] || e=9004 ;pae $e clp2p;pde 5052 clapi delete;pde 8551 cljwt delete;bfw 5052 clapi       ;bfw 8551 cljwt       ; }
function bcl { local e=9000 ;[[ $cunm = $znm3 ]] || e=9004 ;pde $e clp2p;pde 5052 clapi       ;pde 8551 cljwt       ;bfw 5052 clapi delete;bfw 8551 cljwt delete; }
function vfw { if [[ $cust = hrv ]];then pai $1 192.168.8.0/24 $2 $3;else pai $1 $vip1 $2 $3;fi; }
function vop { vfw 5064 vcapi       ;pde 5064 vcapi delete; }
function vcl { vfw 5064 vcapi delete;pde 5064 vcapi       ; }
# enable/arranca goethereum/beacon/validator/prometheus/grafana
function ge  { gop;sex 'ufw reload';cex "$w4 $n0"; }
function be  { bop;sex 'ufw reload';cex "$w4 $n1"; }
function ve  { [[ -f $p1/vc_lock ]] || { vop;sex 'ufw reload';cex "$w4 $n3"; } }
function pe  { pai 9090/tcp 192.168.8.0/24 prometheus;sex 'ufw reload';cex "$w4 $n4"; }
function ne  { sex 'ufw reload';cex "$w4 $n5"; }
function fe  { pai 3000/tcp 192.168.8.0/24 grafana   ;sex 'ufw reload';cex "$w4 $n6"; }
function ga  { [[ $(sst $n0) && -d $p9 ]] && cex "$w3 $n0"; }
function ba  { [[ $(sst $n1) && -d $p7 ]] && cex "$w3 $n1"; }
function va  {
  [[ $(sst $n3) && -d $p8 ]] || return
  if [[ -f $p1/vc_lock ]];then
    if [[ -f $p0/slashing_protection.sqlite ]];then                                                                                                           # slashing_protection
      cex "cp $p0/slashing_protection.sqlite $p8"
      cmw $p8/slashing_protection.sqlite 600 eth3
    fi
  else
    cex "$w3 $n3"
    rm $p1/vc_slash
  fi
}
function pa  { [[ $(sst $n4) ]] && { cex "$w3 $n4"; } }
function na  { [[ $(sst $n5) ]] && { cex "$w3 $n5"; } }
function fa  { [[ $(sst $n6) ]] && { cex "$w3 $n6"; } }
function wa  {
  if [[ $(pex 'ufw status'|grep -i inactive) ]];then
    yex 'ufw enable'                                                                                                                                          # enable asks: Proceed with operation (y|n)?
  else
    swu 'FIREWALL ALREADY ACTIVE'
  fi
}
# para/disable goethereum/beacon/validator/prometheus/grafana
function gp  { [[ $(sst $n0 loaded) ]] && { cex "$w2 $n0"; } }
function bp  { [[ $(sst $n1 loaded) ]] && { cex "$w2 $n1"; } }
function vp  { [[ $(sst $n3 loaded) ]] && { cex "$w2 $n3";touch $p1/vc_slash; } }
function pp  { [[ $(sst $n4 loaded) ]] && { cex "$w2 $n4"; } }
function np  { [[ $(sst $n5 loaded) ]] && { cex "$w2 $n5"; } }
function fp  { [[ $(sst $n6 loaded) ]] && { cex "$w2 $n6"; } }
function gd  { cex "$w5 $n0";gcl;sex 'ufw reload'; }
function bd  { cex "$w5 $n1";bcl;sex 'ufw reload'; }
function vd  { cex "$w5 $n3";vcl;sex 'ufw reload';touch $p1/vc_lock; }
function pd  { [[ $(sst $n4 loaded) ]] && { cex "$w5 $n4";pai 9090/tcp 192.168.8.0/24 prometheus delete;sex 'ufw reload'; } }
function nd  { [[ $(sst $n5 loaded) ]] && { cex "$w5 $n5"; } }
function fd  { [[ $(sst $n6 loaded) ]] && { cex "$w5 $n6";pai 3000/tcp 192.168.8.0/24 grafana    delete;sex 'ufw reload'; } }
function dpa { cex "$w2 $n8";sex "$w2 $n9";cex "$w3 $n8";sex "$w3 $n9"; }                                                                                     # DNS stop/start
function umt { [[ $(cat $s6) -eq 1 && $(fs6) -gt 10 ]]; }                                                                                                     # usb messages test
function t0t { [[ $(cat $s7) -eq 0 && $(fs5) -gt 20 ]]; }                                                                                                     # cpu no turbo recomended test
function t1t { [[ $(cat $s7) -eq 1 && $(fs5) -le 10 ]]; }                                                                                                     # cpu    turbo recomended test
function t2t { [[ $(cat $s7) -eq 1 ]]; }                                                                                                                      # cpu no turbo            test
function pas { umt && sex "$p0/eth2/t5 usbstop";t1t && sex "$p0/eth2/t5 cputurbo";t0t && sex "$p0/eth2/t5 cpunoturbo"; }                                      # set usb/cpu parameters
function paf { t2t && sex "$p0/eth2/t5 cputurbo"; }                                                                                                           # set turbo   parameter
function ghs { sso GETH $n0; }
function bhs { sso BEAC $n1;[[ $(sst $n3 loaded) ]] && sso VALI $n3; }
function ah1 { swn "\n\n$znm1";ghs;cpe;swn "\n\n$znm3";ssh ztc3 "export H=$H;$p0/eth2/t6 bhs";swn "\n\n$znm4";ssh ztc4 "export H=$H;$p0/eth2/t6 ehs"; }
function ah2 { swn "\n\n$znm1";ssh ztc1 "export H=$H;$p0/eth2/t6 ghs";swn "\n\n$znm3";ssh ztc3 "export H=$H;$p0/eth2/t6 bhs";swn "\n\n$znm4";ssh ztc4 "export H=$H;$p0/eth2/t6 ehs"; }
function ah3 { swn "\n\n$znm1";ssh ztc1 "export H=$H;$p0/eth2/t6 ghs";swn "\n\n$znm3";bhs;cpe;swn "\n\n$znm4";ssh ztc4 "export H=$H;$p0/eth2/t6 ehs"; }
function ah4 { swn "\n\n$znm1";ssh ztc1 "export H=$H;$p0/eth2/t6 ghs";swn "\n\n$znm3";ssh ztc3 "export H=$H;$p0/eth2/t6 bhs";swn "\n\n$znm4";ghs;bhs;cpe; }
function jw0 { openssl rand -hex 32|tr -d '\n'|tee jwt 1>$s3;[[ -f jwt ]] && jw4; }
function jw1 { sex "cp jwt $2";cmw $2/jwt 600 $1; }
function jw3 { scp jwt $1:~;ssh $1 "export H=$H;eth2/t6 jwt"; }
function jw4 { jw3 ztc2;jw3 ztc3;jw3 ztc4; }
function sr0 { cp $s4/$n0.service $n0.sav;sed "s%peers *\([0-9]*\)%peers \1 --authrpc.addr $zip1 --authrpc.jwtsecret $p9/geth/jwt%" $n0.sav > $n0.jwt;sr9 $n0; }
function sr1 { cp $s4/$n1.service $n1.sav;sed "s%--eth1-endpoints *\([^,]*:8545\)[^ ]*%--execution-endpoint http://$zip1:8551 --execution-jwt $p7/jwt --suggested-fee-recipient $o9%" $n1.sav > $n1.jwt;sr9 $n1; }
function sr3 { cp $s4/$n3.service $n3.sav;sed "s%beacon-nodes *\([^,]*:5052\)[^ ]*%beacon-nodes \1,http://$zip2:5052 --suggested-fee-recipient $o9%" $n3.sav > $n3.jwt;sr9 $n3; }
function sr9 { chmod 644 $1.jwt;sex "mv $1.jwt $s4/$1.jwt"; }

[[ $1 = jwt ]] && { [[ $cunm = $znm1 || $cunm = $vnm1 ]] && jw0;if [[ -f jwt ]];then [[ -d $p9/geth ]] && jw1 eth1 $p9/geth;[[ -d $p7 ]] && jw1 eth2 $p7;sex "rm jwt";fi; }
[[ $1 = srv ]] && { [[ -f $s4/$n0.service ]] && sr0;[[ -f $s4/$n1.service ]] && sr1;[[ -f $s4/$n3.service ]] && sr3; }
[[ $1 = chk ]] && { cex 'chkrootkit'; }
[[ $1 = eip ]] && { curl -s4 "https://${3:-meo.fruga.pt}:$2@dyn.dns.he.net/nic/update?hostname=${3:-meo.fruga.pt}" &>$s3; }
[[ $1 = dsh ]] && { resolvectl query ${2:-smtp.gmail.com}; }
[[ $1 = drs ]] && { dpa; }
[[ $1 = nrs ]] && { cex 'netplan apply';dpa; }
[[ $1 = nsh ]] && { nsh; }
[[ $1 = trs ]] && { [[ $(sst $n7 masked) ]] || cex "$w0 restart $n7";cpe c; }
[[ $1 = vcp ]] && { [[ $2 ]] && ssp $2; }
[[ $1 = gl  ]] && { gl0;swn "$m"; }
[[ $1 = glf ]] && { gl0;swn "$m" >> $p5;grt && grb;[[ $ok != OK ]] && grs 0;pas; }                                                                            # el log/reboot/restart & parameter set
[[ $1 = bl  ]] && { bl0;swn "$m"; }
[[ $1 = bm  ]] && { bm0;bmo;swn "$m"; }
[[ $1 = bn  ]] && { bm0;bno;swn "$m"; }
[[ $1 = blf ]] && { bl0;swn "$m" >> $p2;stt && bo5 && bht && bst && bdl $d0;[[ $ok != OK ]] && b1r 0;pas; }                                                   # cl log/delete/restart & parameter set
[[ $1 = bmf ]] && { bm0;bms;bbt && swn "$m" >> $p3;bct && b1r $b4 $(brb PE) 120; }
[[ $1 = bnf ]] && { bm0;bno;swn "$m" >> $p6; }
[[ $1 = gh  ]] && { gh0 $2; }
[[ $1 = bh  ]] && { bh0 $2; }
[[ $1 = ahs ]] && { [[ $cunm = $znm1 ]] && ah1;[[ $cunm = $znm2 ]] && ah2;[[ $cunm = $znm3 ]] && ah3;[[ $cunm = $znm4 ]] && ah4; }
[[ $1 = ghs ]] && { ghs    ;cpe ; }                                                                                                                           # el      & system report
[[ $1 = bhs ]] && { bhs    ;cpe ; }                                                                                                                           # cl      & system report
[[ $1 = ehs ]] && { ghs;bhs;cpe ; }                                                                                                                           # el & cl & system report
[[ $1 = bo  ]] && { bo0 $2 $3 $4; }
[[ $1 = bon ]] && { bon $2; }
[[ $1 = boc && -f $p2 ]] && { read -a v <<< $(bff|tail -n1);l2=$(bff $(pt1 $2 ${v[4]}));boa; }
[[ $1 = bol && -f $p2 ]] && { l2=$(bff 23:58);boa; }
[[ $1 = bdl ]] && { bdl $2; }
[[ $1 = brl ]] && { brl; }
[[ $1 = bsl ]] && { bsl; }
[[ $1 = cpe ]] && { cpe $2; }
[[ $1 = grs ]] && { grs ${2:-0}   ; }
[[ $1 = gpn ]] && { if [[ $(sst $n0 running) ]];then gp;cex "du -h $p9";sudo -u eth1 $s8/geth --datadir $p9 snapshot prune-state;cex "du -h $p9";dmr;ga;fi; }
[[ $1 = srs ]] && { b1r ${2:-0} RB; }
[[ $1 = brs ]] && { b1r ${2:-0} BN; }
[[ $1 = lrs ]] && { b1r ${2:-0} VC; }
[[ $1 = urs ]] && { sot ${2:-3} && sex reboot;pas; }                                                                                                          # system reboot needs & parameter set
# lista servicos & portas
[[ $1 = lp  ]] && { netstat -tulpn; }
# outros journal system/lighthouse
[[ $1 = sl  ]] && { fs2|if [[ $2 ]];then grep -i "[a-z]* [0-9]* $2";else grep -i 'error' ;fi; }
[[ $1 = el  ]] && { fs1|if [[ $2 ]];then grep -i "[a-z]* [0-9]* $2";else grep -v ' INFO ';fi; }
[[ $1 = ll  ]] && { rl1|if [[ $2 ]];then grep -i "[a-z]* [0-9]* $2";else grep -v ' INFO ';fi; }
[[ $1 = nl  ]] && { rl0|if [[ $2 ]];then grep -i               "$2";else grep -v ' INFO ';fi; }
[[ $1 = ws  ]] && { cex 'ufw status numbered'; }
[[ $1 = wa  ]] && { wa; }
[[ $1 = we  ]] && { yex 'ufw enable'; }
[[ $1 = wpr ]] && { cex 'ufw disable'; }
[[ $1 = wds ]] && { cex 'ufw disable'; }
[[ $1 = wl  ]] && { fs2|grep UFW|if [[ $2 ]];then grep -v $2;else cat;fi; }
# journal
[[ $1 = yj  ]] && { jsh; }
[[ $1 = ej  ]] && { jsh "-u $n0 -u $n1 -u $n3"; }
[[ $1 = gj  ]] && { jsh "-u $n0"; }
[[ $1 = bj  ]] && { jsh "-u $n1"; }
[[ $1 = vj  ]] && { jsh "-u $n3"; }
[[ $1 = sj  ]] && { jsh "-u $n8"; }
# arranca
[[ $1 = ga  ]] && { dmr;ga; }
[[ $1 = oa  ]] && { dmr;oa; }
[[ $1 = ba  ]] && { dmr;ba; }
[[ $1 = va  ]] && { dmr;va; }
[[ $1 = pa  ]] && { dmr;pa; }
[[ $1 = na  ]] && { dmr;na; }
[[ $1 = fa  ]] && { dmr;fa; }
[[ $1 = xa  ]] && { dmr;xa; }
[[ $1 = ra  ]] && { dmr;ra; }
[[ $1 = sa  ]] && { dmr;sa; }
# para & arranca & journal
[[ $1 = gaj ]] && { dmr;ga;jsh "-u $n0"; }
[[ $1 = baj ]] && { dmr;ba;jsh "-u $n1"; }
[[ $1 = vaj ]] && { dmr;va;jsh "-u $n3"; }
[[ $1 = saj ]] && { dmr;sa;jsh "-u $n8"; }
[[ $1 = gpa ]] && { gp;dmr;ga;jsh "-u $n0"; }
[[ $1 = bpa ]] && { bp;dmr;ba;jsh "-u $n1"; }
[[ $1 = vpa ]] && { vp;dmr;va;jsh "-u $n3"; }
[[ $1 = spa ]] && { sp;sa; }
[[ $1 = gpd ]] && { gp;gd; }
[[ $1 = bpd ]] && { bp;bd; }
[[ $1 = vpd ]] && { vp;vd; }
[[ $1 = xpd ]] && { xp;xd; }
[[ $1 = rpd ]] && { rp;rd; }
[[ $1 = spd ]] && { sp;sd; }
[[ $1 = gea ]] && { ge;dmr;ga;jsh "-u $n0"; }
[[ $1 = bea ]] && { be;dmr;ba;jsh "-u $n1"; }
[[ $1 = vea ]] && { ve;dmr;va;jsh "-u $n3"; }
[[ $1 = rea ]] && { re;ra; }
[[ $1 = sea ]] && { se;sa; }
[[ $1 = xea ]] && { xe;xa; }
# enable
[[ $1 = ge  ]] && { ge; }
[[ $1 = be  ]] && { be; }
[[ $1 = ve  ]] && { ve; }
[[ $1 = pe  ]] && { pe; }
[[ $1 = ne  ]] && { ne; }
[[ $1 = fe  ]] && { fe; }
[[ $1 = xe  ]] && { xe; }
[[ $1 = re  ]] && { re; }
[[ $1 = se  ]] && { se; }
# para
[[ $1 = fpr ]] && { fp; }
[[ $1 = npr ]] && { np; }
[[ $1 = ppr ]] && { pp; }
[[ $1 = vpr ]] && { vp; }
[[ $1 = bpr ]] && { bp; }
[[ $1 = gpr ]] && { gp; }
[[ $1 = xpr ]] && { xp; }
[[ $1 = rpr ]] && { rp; }
[[ $1 = spr ]] && { sp; }
# disable
[[ $1 = fds ]] && { fd; }
[[ $1 = nds ]] && { nd; }
[[ $1 = pds ]] && { pd; }
[[ $1 = vds ]] && { vd; }
[[ $1 = bds ]] && { bd; }
[[ $1 = gds ]] && { gd; }
[[ $1 = xds ]] && { xd; }
[[ $1 = rds ]] && { rd; }
[[ $1 = sds ]] && { sd; }
[[ $1 = lup ]] && { apt list --upgradable; }

if [[ ! $1 ]];then
  m="primeira letra"
  m="$m\ne\t\t$n0 $n1 $n3"
  m="$m\ng\t\t$n0"
  m="$m\nb\t\t$n1"
  m="$m\nv\t\t$n3"
  m="$m\np\t\t$n4"
  m="$m\nn\t\t$n5"
  m="$m\nf\t\t$n6"
  m="$m\nx\t\t$o0"
  m="$m\nr\t\t$o1"
  m="$m\ns\t\t$n8"
  m="$m\nsegunda letra"
  m="$m\na[j]\t\tarranca\t[& journal]"
  m="$m\ne\t\tenable"
  m="$m\nj\t\tjournal"
  m="$m\npr\t\tpara"
  m="$m\nds\t\tdisable"
  m="$m\npd\t\tpara\t& disable"
  m="$m\npa\t\tpara\t& arranca\t& journal"
  m="$m\nea\t\tenable\t& arranca\t& journal"
  m="$m\noutros"
  m="$m\nvcp url\t\t$n3 copy to server url"
  m="$m\ngl[f]\t\tgeth log report"
  m="$m\ngh[s]\t\tgeth historic report [summary]"
  m="$m\ngpn\t\t$n0 prune DB - TAKES HOURS"
  m="$m\ngrs [n]\t\t$n0 restart n nodes to change"
  m="$m\nbrs [n]\t\t$n1 restart n nodes to change"
  m="$m\nsrs [n]\t\tsystem restart n=nodes to change"
  m="$m\nlrs [n]\t\tlighthouse restart n=nodes to change"
  m="$m\nurs [h]\t\treboot if system needs it after h hours"
  m="$m\nyj\t\tsystem journal"
  m="$m\nsl [hh:mm]\tsystem journal  log lines"
  m="$m\nel [hh:mm]\tgeth/lighthouse log lines"
  m="$m\nll [hh:mm]\tgeth/lighthouse all log lines"
  m="$m\nnl [hh:mm]\tbeacon node     log lines"
  m="$m\nbrl\t\trecalculate beacon/medias logs"
  m="$m\nbsl\t\tshrink beacon log using barqivo"
  m="$m\nbdl yyyy-mm-dd\tdelete beacon log day"
  m="$m\nbo  [lines]\thomologous report [with max lines]"
  m="$m\nbon [nodes]\thomologous nodes report"
  m="$m\nbo[cl]\t\tall homologous nodes report at [current|last] time"
  m="$m\nbl[f]\t\tbeacon report [file add & delete log day]"
  m="$m\nbm[f]\t\tmedias report [file add & $n1 nodes change/restart]"
  m="$m\nbn[f]\t\tarqivo report [file add]"
  m="$m\nbh[s]\t\tlighthouse historic report [summary]"
  m="$m\nws\t\tfirewall status"
  m="$m\nwa\t\tfirewall arranca"
  m="$m\nwpr\t\tfirewall para"
  m="$m\ncpe [cp]\tclock & cpu & errors status"
  m="$m\nlp\t\tlista portas"
  m="$m\neip\t\tset dynamic DNS"
  m="$m\nnsh\t\tnetwork/route/DNS show "
  m="$m\ndsh [url]\tdns show"
  m="$m\nnrs\t\tdns/netplan reset"
  m="$m\ndrs\t\tdns reset"
  m="$m\ntrs\t\ttime sync restart"
  m="$m\nchk\t\tcheck server with chkrootkit"
  m="$m\nlup\t\tcheck apt list --upgradable"
  swn "\n$m\n"
fi
