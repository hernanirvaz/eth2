#!/bin/bash

source /home/eth/eth2/t1

function nu0 { printf %.0f       ${1:-0}                              2>$p03; }                                                                               # get unformated numeric output
function nu1 { printf $1         ${2:-0}                              2>$p03; }                                                                               # get   formated numeric output
function nu2 { printf ${3:-%.0f} $(echo "scale=${2:-1};$1"|bc 2>$p03) 2>$p03; }                                                                               # get precision calculations
function nu3 {                  if [[ $# -gt 0 ]];then               echo                "(0$(printf %+.0f    $@ 2>$p03))"         |bc 2>$p03        ;else printf %i;fi; }
function nu4 { local n=$1;shift;if [[ $# -gt 0 ]];then printf %.0f $(echo "scale=$((n+1));(0$(printf %+.${n}f $@ 2>$p03))/$#*10^$n"|bc 2>$p03) 2>$p03;else printf %i;fi; }
function nu5 { local n=$1;shift;if [[ $# -gt 0 ]];then printf %.0f $(echo "scale=$((n+1));(0$(printf %+.${n}f $@ 2>$p03))/$#"      |bc 2>$p03) 2>$p03;else printf %i;fi; }
function nu6 { printf '%i\n' $@ 2>$p03|sort -n|head -n1; }                                                                                                    # get min from list numbers
function nu7 { nu2 "sqrt(((0$(printf +%i^2 $@ 2>$p03))-(0$(printf +%i $@ 2>$p03))^2/$#)/$#)*1000" 4; }                                                        # get std from list numbers
function nu8 { printf '%i\n' $@ 2>$p03|grep -c '^0$'; }                                                                                                       # get # zeros from list numbers
function ll0 { local f=$p16/logs/beacon.log   ;echo $H|sudo -S cat                       $f.1     $f     2>$p03|tail -n$((n15*2)); }                          # get cc intern lines
function ll1 { local f=$p16/logs/beacon.log   ;echo $H|sudo -S egrep -ah  "$1"           $f.1     $f     2>$p03|tail -n$n15      ; }                          # get cc intern lines (specific)
function ll2 { local f=$p01                   ;echo $H|sudo -S egrep -ah  "$1"                    $f     2>$p03                  ; }                          # get all eth syslog lines
function ll3 { local f=$p01                   ;echo $H|sudo -S egrep -ahv "$g13"                  $f     2>$p03                  ; }                          # get not eth syslog lines
function ll4 { local f=$p17/logs/validator.log;echo $H|sudo -S cat                       $f.1     $f     2>$p03|tail -n$n15      ; }                          # get vc intern lines
function ll5 { local f=$p17/logs/validator.log;echo $H|sudo -S egrep -ah  "$1" $f.3 $f.2 $f.1     $f     2>$p03|tail -n$2        ; }                          # get vc intern lines (specific)
function ll6 { local f=$p61/logs/mainnet.logs ;echo $H|sudo -S egrep -ah  "$1"           $f.0.txt $f.txt 2>$p03                  ; }                          # get neth intern lines
function ln0 {                              snf "s%.*$1 *([0-9]+).*%\1%p"              $2   ; }                                                               # get sed list of numbers (file)
function ln1 { if [[ $l6 ]];then echo "$l6"|snf "s%.*$1 *-?([0-9]*\.?[0-9]+)$2.*%\1%p"   ;fi; }                                                               # get sed list of numbers (stdin)
function ln2 { if [[ $l4 ]];then echo "$l4"|gawk "$1" 2>$p03;fi; }                                                                                            # get awk list of numbers (Âµs|ms|s)
function ln3 { l6=$(ll2 "$2.*$1");ln1 $1; }                                                                                                                   # get numbers all  syslog lines
function ln4 { if g0t $3;then l6=$(ll2 "$2.*$1"|tail -n$3);else l6=$(ll2 "$2.*$1");fi;ln1 $1; }                                                               # get numbers tail syslog lines
function fl0 { ll3|tail -n300|flp "Core.*temperature" $1; }                                                                                                   # get temp  cpu lines
function fl1 { ll3           |flp "$g29" $1|grep -ai usb; }                                                                                                   # get error usb lines
function fln { if [[ $2 ]];then egrep -ai "^$g41$2";else egrep -aiv "$1";fi; }                                                                                # get negate re syslog lines
function flp { if [[ $2 ]];then egrep -ai "^$g41$2";else egrep -ai  "$1"|grep -aiv "$g38";fi; }                                                               # get posite re syslog lines
function tln { if [[ $2 ]];then egrep -ai "^$g23$2";else egrep -aiv "$1";fi; }                                                                                # get negate re syslog lines
function pt0 { until [[ $# -le 1 || $1 =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]];do shift;done;printf %s $1; }                                                       # yyyy-mm-dd test
function pt1 { until [[ $# -le 1 || $1 =~ ^[0-9]{2}:[0-9]{2}$          ]];do shift;done;printf %s $1; }                                                       # hh:mm      test
function pt2 { until [[ $# -le 1 || $1 =~ ^[0-9]+$                     ]];do shift;done;printf %i $1; }                                                       # integer    test
function pt3 { until [[ $# -le 1 || $1 =~ ^[a-z]+$                     ]];do shift;done;printf %s $1; }                                                       # string     test
function ss1 { $s01 $1 2>$p03|snf "s%.*$2[ =](${3:-.}+).*%\1%p"; }                                                                                            # systemctl status 1 extraction
function ss2 { $s01 $1 2>$p03|snf "$e57"|sef "$e58"|cut -c1-40; }                                                                                             # systemctl status 2 extraction
function ss3 { if tsa $1;then ss1 $1 Memory: '[^ ]'         ;else printf 0.0K   ;fi; }                                                                        # systemctl status Memory extraction
function ss4 { if tsa $1;then ss1 $1 $3      '[^ ]'|sef "$2";else printf 00:0000;fi; }                                                                        # systemctl status ip/port extraction
function ss5 { if tsa $1;then nu0 $(($(ss1 $1 $2 [0-9])/${3:-1}));else printf %i     ;fi; }                                                                   # systemctl status number extraction
function e0t { [[ $1 -eq 0 ]]; }
function g0t { [[ $1 -gt 0 ]]; }
function llt { [[ $(grep '\-all-' $p04/$s12.service 2>$p03) ]]; }                                                                                             # cc long-lived test
function t0t { [[ $(cat $p43 2>$p03) -eq 0 && $(fl0|wc -l) -gt 20 ]]; }                                                                                       # cpu no turbo recomended test
function t1t { [[ $(cat $p43 2>$p03) -eq 1 && $(fl0|wc -l) -le 10 ]]; }                                                                                       # cpu    turbo recomended test
function t2t { [[ $(cat $p44 2>$p03) -eq 1 && $(fl1|wc -l) -gt 10 ]]; }                                                                                       # usb messages            test
function t3t { [[ $(cat $p43 2>$p03) -eq 1 ]]; }                                                                                                              # cpu no turbo            test
function v0t { g0t $(grep -c $d0 $p12 2>$p03); }                                                                                                              # cc  log day             test
function z1t { [[ $cunm = $cunt ]]; }                                                                                                                         # main ntp                test
function z4t { [[ $cunm = $znm4 ]]; }                                                                                                                         # best zotac              test
function n1t { [[ $cunm = $cun1 ]]; }
function n2t { [[ $cunm = $cun2 ]]; }
function n3t { [[ $cun1 != $cun2 ]]; }
function n4t { [[ $cun1 != $cun2 || $cun1 != $cumv ]]; }
function vct { [[ $cunm = $cuvc ]]; }
function mct { [[ $cunm = $cumv ]]; }
function i5t { [[ $cunm = $inm5 ]]; }
function ict { [[ $cunm = $cuvc || $cunm = $cun1 || $cunm = $cun2 || $cunm = $vnm1 || $cunm = $vnm2 ]]; }
function iet { [[ $cunm = $cun1 || $cunm = $cun2                  || $cunm = $vnm1 || $cunm = $vnm2 ]]; }
function irt { [[ $cunm = $cumv                                   || $cunm = $vnm1 || $cunm = $vnm2 ]]; }
function v1t { [[ $cunm = $vnm1 ]]; }
function vst { [[ $cun1 != $cuvc && $cun2 != $cuvc ]]; }
function mst { [[ $cun1 != $cumv && $cun2 != $cumv ]]; }
function nst { [[ $cust = hrv && $cumv != $cunt ]]; }
function s1t { e0t $(ls $1.* 2>$p03|wc -l); }
function s2t { g0t $(ls $1.* 2>$p03|wc -l); }
function s3t { s2t $1 || g0t $(bwc); }
function s4t { s1t $1 || g0t $(bwc); }
function s5t { ict    && g0t $(bwc); }
function s6t { [[ -e $1 && -b $1 ]]; }
function s7t { local s=$(basename $p62);sex "rm -f $p61/$s";sex "cp $p62 $p61/$s";[[ -f $p61/$1$s && -s $p61/$s ]]; }
function rbt { [[ $(sra) -ge $((60*60*${1:-9})) ]]; }
function ipt { [[ $(date +%s) -ge $(bss $1 6) ]]; }
function pct { [[ $b4 -ne 0 ]]; }
function hat { [[ ${a[$nn]} -gt ${a[0]} ]]; }                                                                                                                 # function hat { [[ $b2 -gt $(b00) ]]; }
function bdt { [[ $(b03 $zk $zz $zx $zw) -gt $n20 || $nz -gt 0 ]]; }
function pmt { [[ $nm -gt $(b05) ]]; }
function fft { [[ -f $1 ]]; }
function sft { [[ -f $p04/$1.service ]]; }
function bpt { [[ $(era $p12 $n12) -eq 1 ]] && ( (pct && pmt && hat && ! bdt && ! fft $p45) || rbt $n06); }
function llc { pt2 $(wc -l $1 2>$p03) 0; }                                                                                                                    # get log line count
function jrn { if [[ $2 ]];then local s="-g $2";else local s=;fi;cex "journalctl --no-hostname --no-full -f $1 $s"; }                                         # my journal   format
function dmr { sex "$s00 daemon-reload"; }                                                                                                                    # daemon-reload
function si1 { local n=${1:-0};printf %i $((20*n))   2>$p03; }
function si2 { local n=${1:-0};printf %i $((1000*n)) 2>$p03; }
function svi { local n=${1:-0};if g0t $n;then l6=$(ll1 "$g18"|tail -n$n);else l6=$(ll1 "$g18");fi;i0=$(nu5 0 $(ln1 $g54));i1=$(nu5 0 $(ln1 $g55));i4=$(nu5 0 $(ln1 $g56));b1=$(nu3 $(ln3 "$g27" "$g49"));if g0t $n;then l4=$(ll1 "$g19"|tail -n$(si2 $n));else l4=$(ll1 "$g19");fi;i2=$(nu2 "$(nu5 0 $(ln2 "${w0}elapsed: *$w3"))/1000");if g0t $n;then l6=$(ll1 "$g20"|tail -n$(si1 $n));else l6=$(ll1 "$g20");fi;i3=$(nu5 2 $(ln1 $g15)); }
function svv { l6=$(ll5 "$g16" $1);v0=$(nu4 1 $(ln1 $g33 ".*$(sni $cun1)"));v1=$(nu4 1 $(ln1 $g33 ".*$(sni $cun2)"));l6=$(ll5 "$g17" $(($1/2)));v2=$(nu4 1 $(ln1 $g32)); }
function smm { m0=$(nu4 3 $(ln4 "$g34" "$g09" $1));m1=$(rlr|wc -l); }
function spc { nn=$2;cp $p04/$1.service $p02/$1.sav;sef "$e65$2%" $p02/$1.sav > $p04/$1.service; }                                                            # service configuration change/reload
function snp { sft $1 || return;local n=$(($2+$5));(($2!=0&&n>=$3&&n<=$4)) && spc $1 $n;tsa $1 && sex "$s02 $1";dmr; }                                        # service peers change/stop
function sra { if fft $p45;then nu0 $(($(date +%s)-$(date -r $p45 +%s)));else printf %i;fi }                                                                  # system reboot age (secounds)
function dts { read       d0 d1   <<< ${1:-$(date '+%F %H:%M')};dt="$d0 $d1"; }                                                                               # set date/time vars
function dtl { read _ _ _ d0 d1 _ <<< $(bff|tail -n1)          ;dt="$d0 $d1"; }                                                                               # set date/time vars with last beacon log
function tsy { if [[ $(echo $@|grep false) ]];then printf SYC;else printf NSY;fi; }                                                                           # get el SYN/NSY text
function era { tail -n${2:-$n13} $1 2>$p03|cut -d' ' -f1|sort -u|wc -l; }                                                                                     # get el/cc restart activity
function eh0 {
  local n=${1:-$n13};local i=${1:-0}
  if fft $p10;then tail -n$n $p10;fi;if [[ $i -eq 0 ]] && tsa $s10;then gl0;swn "GL $(printf '%8i' $(llc $p10) 2>$p03)\n$m";fi
  if fft $p11;then tail -n$n $p11;fi;if [[ $i -eq 0 ]] && tsa $s11;then ul0;swn "UL $(printf '%8i' $(llc $p11) 2>$p03)\n$m";fi
  if fft $p62;then tail -n$n $p62;fi;if [[ $i -eq 0 ]] && tsa $s44;then tl0;swn "NL $(printf '%8i' $(llc $p62) 2>$p03)\n$m";fi
}
function ch0 {
  local n=${1:-$n13};local i=${1:-0}
  if fft $p12;then tail -n$n $p12;fi;if [[ $i -eq 0 ]] && tsa $s12;then bl0;swn "BL $(printf '%8i' $(llc $p12) 2>$p03)\n$m";fi
  if fft $p49;then tail -n$n $p49;fi;if [[ $i -eq 0 ]] && tsa $s13;then vl0;swn "VL $(printf '%8i' $(llc $p49) 2>$p03)\n$m";fi
  if fft $p52;then tail -n$n $p52;fi;if [[ $i -eq 0 ]] && tsa $s14;then ml0;swn "ML $(printf '%8i' $(llc $p52) 2>$p03)\n$m";fi
}
function eb0 { e0=$(ll2 "$g12"|wc -l);ok=OK;fft $1 || return;[[ $(echo $@|grep false) && ($e0 -eq $(ln0 $s53 $1|tail -n1) || $(ei0) -gt $n24) && $(era $1) -eq 1 ]] && ok=BK; }
function stg { local n=${1:-0};if ((n>3599));then printf %s $(($(date -d@$n +%H)-1))h;fi;if ((n>0));then printf %s $(date -d@$n +%Mm%Ss);fi;printf %s .$(date -d@$(($(date +%s)+$n)) +%H%M%S); }
function sf1 { printf %s ${1:-$(date +%H:%M:%S)}; }                                                                                                           # get filterd t7 parm 1
function sf2 { printf %i ${2:-24}; }                                                                                                                          # get filterd t7 parm 2
function rsf { cd $p02;ls -rt$1 *.rs.* 2>$p03; }                                                                                                              # get list restart files
function bss { nu0 $((${2:-0}+$(date -d$(sf1 $1) +%s))); }                                                                                                    # get sum secounds + time
function smn { local g=${1:-24}                  ;nu0 $((g>360?360:g<24?24:g)); }                                                                             # get max/min seconds to future (12x30/24)
function sfn { local g=$(($(bss $1)-$(date +%s)));nu0 $((g>3?g:3))            ; }                                                                             # get min seconds to future
function ssf { g0t $1 || return;local f=$2.s${4:-00}n${5:-00}s$(stg $1);touch $f;[[ -f $p50 ]] && echo $(sf1) $(basename $f 2>$p03);sleep $1s; }
function ssw { while :;do local t=$(sng);if [[ $(sf2 $t) -lt $1 || 24 -ge $(sfn $t) ]];then ssf $(smn $(sfn $t)) $2 $t $1;else break;fi;s1t $2 && break;done; }
function csn { if g0t $#;then nr=${@:$#};nm=$(nu6 $@);nd=$(nu7 $@);nz=$(nu8 $@);else nr=0;nm=0;nd=0;nz=0;fi; }
function esn { if g0t $#;then er=${@:$#};em=$(nu6 $@);ed=$(nu7 $@);ez=$(nu8 $@);else er=0;em=0;ed=0;ez=0;fi; }
function npn { if [[ $2 -ge 100 ]];then printf '%10s %5s nod%03i %3i' $dt $1 $2;else printf '%10s %5s nod%03i: %2i' $dt $1 $2;fi 2>$p03; }                    # get date/nodes info
function bnn { csn $(ln3 "$g31:" $g08) $(bpc $(bcl peer_count)); }                                                                                            # set cur/min/std cc peers
function sz0 { gnn 0          ;printf 'el:p%03i:m%03i:l%03i:z%02i:d%04i p2p:%5i %s     iu: %4i %5i %4i'                 $er $em $(b06) $ez $ed $(ss5 $1 port    ) "$(gb1 $(gcl eth.syncing))" $e1 $e2 $(ei0)                 2>$p03; }
function sz1 { unn 0          ;printf 'el:p%03i:m%03i:l%03i:z%02i:d%04i p2p:%5i %s      i: %4i'                         $er $em $(b06) $ez $ed $(ss5 $1 p2p-port) "$(ub1 $(ucl eth_syncing))" $e1                            2>$p03; }
function sz5 { tnn 0          ;printf 'el:p%03i:m%03i:l%03i:z%02i:d%04i p2p:%5i %s     ps: %4i %5i %4i'                 $er $em $(b06) $ez $ed $(ss5 $1 P2PPort ) "$(tb1 $(tcl eth_syncing))" $e1 $e2 $(ei0)                 2>$p03; }
function sz2 { dtl;svi;bv0;bnn;printf 'cl:p%03i:m%03i:l%03i:z%02i:d%04i p2p:%5i %s iearhp: %4i %5i %4i %2i %2i %2i %4i' $nr $nm $(b05) $nz $nd $(ss5 $1 port    ) "$(bb1 $(bcl syncing))"     $i0 $i1 $i4 $b1 $i2 $i3 $(b01) 2>$p03; }
function sz3 { svv $n23       ;printf 'vl:m%03i:b%03i:c%02i api:%s'                                                     $v0 $v1 $v2            $(ss4 $1 "$e32" nodes)                                                        2>$p03; }
function sz4 { smm 0          ;printf 'ml:h%03i:r%03i api:%s'                                                           $m0 $m1                $(ss4 $1 "$e32" addr )                                                        2>$p03; }
function sso { tse $2 || return;dts;local e="$1 $(printf '%6s %10s %5s %-40s' $(ss3 $2) $dt "$(ss2 $2)" 2>$p03)";case $1 in GETH) e="$e $(sz0 $2)";;BESU) e="$e $(sz1 $2)";;NETH) e="$e $(sz5 $2)";;BEAC) e="$e $(sz2 $2)";;VALI) e="$e $(sz3 $2)";;MEVB) e="$e $(sz4 $2)";;esac;swn "$e"; }
# el control commands
function grs {
  s2t $p40 && return;gv0;gq0;touch $p40.a$(stg);ssw $3 $p40;s1t $p40 && return
  local t=$(sng);local f=$p40.i$(stg);touch $f;local n=0;paf;while fft $f;do ((n+=$(sfn $t)));ssf $(sfn $t) $p40 $t
  if ipt $t;then rm $f;snp $s10 $2 $n34 $n25 $en
    if [[ $1 = RB ]];then ero $1 $n $p10;rm -f $p50 $p40.*;sex reboot;else sex "$s03 $s10";ssf $n26 $p40;gq0;ero $1 $n $p10;fi
  fi;done;rm -f $p50 $p40.*
}
function gdi { if g0t $1;then l4=$(ll2 "$g12"|tail -n$1);else l4=$(ll2 "$g12");fi;e1=$(nu5 3 $(ln2 "${w0}elapsed= *$w2")); }
function gdu { if g0t $1;then l4=$(ll2 "$g44"|tail -n$1);else l4=$(ll2 "$g44");fi;e2=$(nu5 3 $(ln2 "${w0}elapsed= *$w2")); }
function gcl { $p00/geth attach --exec $1 $s30 2>$p03; }                                                                                                      # exec RPC HTTP
function gi0 { nu0 $(echo $@|snf "$e61"); }                                                                                                                   # get el highest block
function gc0 { nu0 $(echo $@|snf "$e62"); }                                                                                                                   # get el current block
function gv0 { en=$(ss5 $s10 maxpeers); }                                                                                                                     # set configured peers
function gq0 { er=$(nu0 $(gcl net.peerCount)); }                                                                                                              # set el current peers
function gnn { esn $(ln3 "$g35" $g06) $(nu0 $(gcl net.peerCount));gdi $1;gdu $1; }
function gb1 { if [[ $(echo $@|grep false) ]];then printf 'synced';else printf  'syncing: %6i' $(($(gi0 $@)-$(gc0 $@)));fi; }                                 # get el syncing blocks remaining
function gb2 { if [[ $(echo $@|grep false) ]];then printf ''      ;else printf ' syncing: %6i' $(($(gi0 $@)-$(gc0 $@)));fi; }                                 # get el syncing blocks remaining
function gl0 {                                                                                                                                                # el report
  dts;ok=OK
  if tsa $s10;then local e=$(gcl eth.syncing);gv0;gnn $n07;eb0 $p10 $e
    m="GETH $ok $(tsy $e) $(npn $en $er) $s53 $(nu1 %4i $e0)$(gb2 $e) $(printf 'iu: %3i %2i %3i' $e1 $e2 $(ei0) 2>$p03)"
  else
    m="GSRV NOT ON $dt"
  fi
}
function tfa { sex "$s03 $s44";ssf $n26 $p63;tq0;ero $1 $2 $p62; }
function trs {
  s2t $p63 && return;tv0;tq0;touch $p63.a$(stg);ssw $3 $p63;s1t $p63 && return
  local t=$(sng);local f=$p63.i$(stg);touch $f;local n=0;paf;while fft $f;do ((n+=$(sfn $t)));ssf $(sfn $t) $p63 $t
  if ipt $t;then rm $f;snp $s44 $2 $n34 $n25 $en
    case $1 in RB) ero $1 $n $p62;rm -f $p50 $p63.*;sex reboot;;PR) ero $1 $n $p62;;*) tfa $1 $n;;esac
  fi;done;rm -f $p50 $p63.*
}
function tdi { if g0t $1;then l4=$(ll6 "$g37"|tail -n$1);else l4=$(ll6 "$g37");fi;e1=$(nu5 2 $(ln2 "${w0}\| *$w1$w4"));e2=$(nu5 2 $(ln2 "${w0}slot *$w1$w4")); }
function tcl { curl $s30 -sX POST -H "Content-Type: application/json" --data "{\"jsonrpc\":\"2.0\",\"method\":\"$1\",\"params\":[],\"id\":0}" 2>$p03|jq -r .result; }
function tv0 { en=$(ss5 $s44 MaxActivePeers); }
function tq0 { er=$(nu0 $(tcl net_peerCount)); }
function tnn { esn $(ln3 "$g30" $g10) $(nu0 $(tcl net_peerCount));tdi $1; }
function tb1 { if [[ $(echo $@|grep false) ]];then printf 'synced';else printf  'syncing';fi; }
function tb2 { if [[ $(echo $@|grep false) ]];then printf ''      ;else printf ' syncing';fi; }
function tl0 {
  dts;ok=OK
  if tsa $s44;then local e=$(tcl eth_syncing);tv0;tnn $n07;eb0 $p62 $e
    m="NETH $ok $(tsy $e) $(npn $en $er) $s53 $(nu1 %4i $e0)$(tb2 $e) $(printf 'ps: %3i %5i %4i' $e1 $e2 $(ei0) 2>$p03)"
  else
    m="NSRV NOT ON $dt"
  fi
}
function tl1 { s6t $p66 || return;rm -f $p50 $p63.*;local n=$(date +%s);sex "$s02 $s44";sex "umount $p66";sex "fsck -fy $p66";sex "mount $p66";dmr;tfa FS $(($(date +%s)-n));rm -f $p50 $p63.*; }
function urs {
  s2t $p41 && return;uv0;uq0;touch $p41.a$(stg);ssw $3 $p41;s1t $p41 && return
  local t=$(sng);local f=$p41.i$(stg);touch $f;local n=0;paf;while fft $f;do ((n+=$(sfn $t)));ssf $(sfn $t) $p41 $t
  if ipt $t;then rm $f;snp $s11 $2 $n34 $n25 $en
    if [[ $1 = RB ]];then ero $1 $n $p11;rm -f $p50 $p41.*;sex reboot;else sex "$s03 $s11";ssf $n26 $p41;uq0;ero $1 $n $p11;fi
  fi;done;rm -f $p50 $p41.*
}
function udi { if g0t $1;then l4=$(ll2 "$g12"|tail -n$1);else l4=$(ll2 "$g12");fi;e1=$(nu5 3 $(ln2 "${w0} in $w2")); }
function ucl { curl -sX POST --data "{\"jsonrpc\":\"2.0\",\"method\":\"$1\",\"params\":[],\"id\":51}" $s30 2>$p03; }                                          # exec RPC HTTP
function ui0 { nu0 $((16#$(nu0 $(echo $@|snf "$e63")))); }                                                                                                    # get el highest block
function uc0 { nu0 $((16#$(nu0 $(echo $@|snf "$e64")))); }                                                                                                    # get el current block
function up0 { nu0 $((16#$(nu0 $(echo $@|snf "$e56")))); }                                                                                                    # get el result
function uv0 { en=$(ss5 $s11 max-peers); }                                                                                                                    # set configured peers
function uq0 { er=$(up0 $(ucl net_peerCount)); }                                                                                                              # set el current peers
function unn { esn $(ln3 "$g31:" $g07) $(up0 $(ucl net_peerCount));udi $1;e2=0; }                                                                             # set cur/min/std el peers
function ub1 { if [[ $(echo $@|grep false) ]];then printf 'synced';else printf  'syncing: %6i' $(($(ui0 $@)-$(uc0 $@)));fi; }                                 # get el syncing blocks remaining
function ub2 { if [[ $(echo $@|grep false) ]];then printf ''      ;else printf ' syncing: %6i' $(($(ui0 $@)-$(uc0 $@)));fi; }                                 # get el syncing blocks remaining
function ul0 {                                                                                                                                                # el report
  dts;ok=OK
  if tsa $s11;then local e=$(ucl eth_syncing);uv0;unn $n07;eb0 $p11 $e
    m="BESU $ok $(tsy $e) $(npn $en $er) $s53 $(nu1 %4i $e0)$(ub2 $e) $(printf 'i: %3i' $e1 2>$p03)"
  else
    m="USRV NOT ON $dt"
  fi
}
# cc control commands
function bcl { curl -sX GET "$s31/$1" -H "accept: application/json" 2>$p03; }                                                                                 # exec node  RPC HTTP
function bcp { curl -sX GET "$s33/$1" -H "accept: application/json" 2>$p03; }                                                                                 # exec light RPC HTTP
function ei0 { nu2 "(0.823*$e1+0.177*$e2)"                                            ; }                                                                     # get imported/updated/rejected data
function b00 { nu2 "0.10*$b3+0.90*$nn"                                                ; }                                                                     # get change peers limit
function b01 { nu2 "(0.300*$i0+0.200*$i1+0.469*$i4+0.001*$b1+0.010*$i2+0.020*$i3)"    ; }                                                                     # get imported/execution/attestable/reorgs/http/pscore index
function b02 { nu2 "(($1*$n28+$2*$n29+$3*$n10+$4*$n11)/${5:-1}*$n30/1000000)      " 7 ; }                                                                     # get penalty
function b03 { nu2 "(($1*$n28+$2*$n29+$3*$n10+$4*$n11)/${5:-1}*$n30/1000000)+2*$nn" 7 ; }                                                                     # get penalty delete idx
function b04 { nu2 "($1*$n27+$2*$n08)*$n30/100000000"                               7 ; }                                                                     # get reward
function b05 { nu2 "0.90*$nn"                                                         ; }                                                                     # get min target peers limit
function b06 { nu2 "0.90*$en"                                                         ; }                                                                     # get min target peers limit
function b07 { nu2 "1.50*$z1"                                                         ; }                                                                     # get numerator general errors
function b08 { nu0 $((z2>500?$(b07)/z2:0))                                            ; }                                                                     # get restart idx
function bsi { nu0 $(echo $@|jq -r .data.sync_distance 2>$p03)                        ; }                                                                     # get cl syncing distance
function bpc { nu0 $(echo $@|jq -r .data.connected     2>$p03)                        ; }                                                                     # get cl peers connected
function bv0 { nn=$(ss5 $s12 target-peers); }                                                                                                                 # set configured peers
function bs0 { l0=$(ll2 "$g08.*$n31]"|tail -n1000); }                                                                                                         # set last cc log lines
function bs3 { l3=$(ll2 "$g45"); }                                                                                                                            # set attesta log lines
function bs5 { l5=$(echo "$l1"|snf "s%.+$(nu1 nod%03i $1)$g52%\1\t\2\t\3\t\4%p"); }                                                                           # set penalty errors log lines
function bb0 { bs0;bs3;bl1;bl2;[[ (1 -eq $(era $p12 $n12) && $(b08) -ge 1) || (1 -eq $(era $p12 5) && $(b08) -ge 5) ]] && ok=BK; }                            # set ok (OK/BK)
function bfl { grep "BEAC.*$1"      2>$p03; }                                                                                                                 # filter cc lines
function bff { grep "BEAC.*$1" $p12 2>$p03; }                                                                                                                 # filter cc log
function bb1 { if [[ $(echo $@|jq -r .data.is_syncing) = false ]];then printf 'synced';else printf 'syncing: %6i' $(bsi $@);fi; }                             # get cl syncing distance remaining
function bmp { printf '%4i %3s %3i %4i iearhp: %4i %4i %4i %2i %2i %2i %4i' ${a[0]} $b5 $b4 $(b03 $zk $zz $zx $zw) $i0 $i1 $i4 $b1 $i2 $i3 $(b01) 2>$p03; }
function bl0 { dts;ok=OK;if tsa $s12;then bl3;bv0;bnn;bb0;blo;else m="BSRV NOT ON $dt";fi; }                                                                  # cc report
function bl1 { z1=${1:-$(echo "$l0"|grep -cv ' INFO ')};z2=${2:-$(echo "$l0"|grep -c ' INFO ')};z3=${3:-$(bl4 success)};ok=${4:-OK}; }                        # set info lines,success activities
function bl2 { zk=${1:-$(bl4 missing)};zz=${2:-$(bl4 target)};zx=${3:-$(bl4 head)};zw=${4:-$(bl4 had)}; }                                                     # set missing/target/head/had activities
function bl3 { b0=${1:-$(ll2 "$g08.*$g53"|wc -l)};if [[ $2$3$4$5$6$7 ]];then i0=$2;i1=$3;i4=$4;b1=$5;i2=$6;i3=$7;else svi $n21;fi; }                          # set pub-blocks & imported/observed delays
function bl4 { echo "$l3"|snf "s%.*$1.*validators: *\[(.*)\].*%\1%p"|wc -w; }                                                                                 # get number of paid activities
function ml0 { dts;if tsa $s14;then smm $n32;mlo;else m="MSRV NOT ON $dt";fi; }
function vl0 { dts;if tsa $s13;then svv $n22;vlo;else m="VSRV NOT ON $dt";fi; }
#    0  1              2     3         4   5
# MEVB OK  11 2023-06-13 01:10 http_avg:  84
function mlo { m="MEVB $(printf '%6i' $(rll|wc -l) 2>$p03) $dt $(printf 'http_avg: %4i erro_rv: %3i' $m0 $m1 2>$p03)"; }
#    0      1          2     3           4  5           6  7     8  9
# VALI     69 2024-05-16 14:49 hrv-intel6: 10 hrv-intel5:  9 casp: 14
function vlo { m="VALI $(printf '%6i' $(vii|wc -l) 2>$p03) $dt $(printf '%s: %2i %s: %2i casp: %2i' $cun1 $v0 $cun2 $v1 $v2 2>$p03)"; }
#    0  1   2          3     4       5   6     7    8    9  10 11  12 13  14  15  16   17   18   19      20   21   22   23 24    25  26   27
# BEAC OK   0 2024-04-02 16:07 nod100: 107 rpab: 3023 2696 3978 0 er:  0  15  84  28    6  994   12 iearhp: 1083 4354 3218 17 66290  62 1473
function blo {
  m="BEAC $ok $(printf '%3i' $(b08) 2>$p03) $(npn $nn $nr) $(printf 'rpab: %4.0f %4.0f %4i %1i' $(b04 $z3 $b0) $(b02 $zk $zz $zx $zw) $z3 $b0 2>$p03)"
  m="$m $(printf 'er: %2i %3i %3i %3i %4i %4i %4i iearhp: %4i %4i %4i %2i %2i %2i %4i' $zk $zz $zx $zw $z1 $z2 $(b07) $i0 $i1 $i4 $b1 $i2 $i3 $(b01) 2>$p03)"
}
#  0    1   2          3     4       5  6   7     8    9   10   11   12   13   14   15  16  17   18      19   20   21   22 23    24  25   26
# BM   50  22 2024-04-02 16:10 nod100: 110 mp:  679  874 1149  792  772 1341 1638 1043 p_: -60 2896 iearhp: 1281 3938 3593 17 50734  65 1632
function bmo { m="BM $(printf '%4i %3i' $b2 $b3 2>$p03) $(npn $nn $nr) $(bma) $(bmp)"; }
#  0    1   2          3     4       5   6   7    8    9  10  11   12      13   14   15   16 17    18  19   20
# BM   50  22 2024-04-02 16:11 nod100: 101 mp: 1638 1043 p_: -60 2896 iearhp: 1275 3922 3593 18 50801  65 1627
function bms { m="BM $(printf '%4i %3i' $b2 $b3 2>$p03) $(npn $nn $nr) mp: $(nu1 %4i ${a[$nn]}) $(bmp)"; }
#    0   1          2     3    4 5 6 7 8 9 10 11   12 13 14 15 16 17 18 19   20 21 22 23 24 25 26 27   28 29 30 31 32 33 34 35   36 37 38 39 40 41 42 43
# BEAC 682 2022-03-16 11:03 cnt: 4 7 0 0 0 10 10 mis: 20 20 20 20 20 20 20 mat: 14 45 30 30 30 30 30 mah: 94 68 40 40 40 40 40 dly: 79 09 50 50 50 50 50
function bno { m="BEAC $(nu1 %6i $(llc $p12)) $dt $(bnc 'cnt:' ' ') $(bnk 'mis:' ' ') $(bnz 'mat:' ' ') $(bnx 'mah:' ' ') $(bnw 'dly:' ' ')"; }
function bmi { zk=0;zz=0;zx=0;zw=0;unset v;v[1]=0;unset k;k[0]=0;unset z;z[0]=0;unset x;x[0]=0;unset w;w[0]=0;unset c;c[0]=0;unset a;a[0]=0;bm6; }            # ini err/cnt/avg penalty arrays
function bm0 {                                                                                                                                                # cc-daily report
  fft $p12 || return;bmi;b4=0;dts;bv0;bnn;bs3;bl2;[[ -f $p14 ]] && bm4;svi                                                                                    # set vars/arrays
  l1=$(tail -n$(($(nu0 $(llc $p12))-v[1])) $p12 2>$p03|bfl);[[ $l1 ]] && bm1;bm2;e0t $b2 && boi;bo3;bm5;b5=$(bcc)                                             # add cc lines & homologous/avg position
}
function bm1 { local g=${1:-$n16};while :;do bs5 $g;if [[ $l5 ]];then bkm $g;bzm $g;bxm $g;bwm $g;bcm $g;fi;g=$((g+n18));((g>n17)) && break;done; }           # recursively sum penalty errors arrays
function bm2 { k[0]=$(($(bnk)));z[0]=$(($(bnz)));x[0]=$(($(bnx)));w[0]=$(($(bnw)));c[0]=$(($(bnc)));a[0]=$(bm3 0);bm7; }                                      # tot err/cnt/penalty arrays
function bm3 { b02 ${k[$1]} ${z[$1]} ${x[$1]} ${w[$1]} ${c[$1]}  ; }                                                                                          # get penalty from paid err arrays
function bm4 { read -a v <<< $(tail -n1 $p14);bmk;bmz;bmx;bmw;bmc; }                                                                                          # set err/cnt penalty arrays from barqivo
function bm5 { local g=${1:-$n16};local n=${a[0]};while :;do if ((a[g]<n));then b4=$((g-nn));n=${a[$g]};fi  ; g=$((g+n18));((g>n17)) && break;done; }         # set recursively peer change <- min penalties
function bm6 { local g=${1:-$n16};                while :;do k[$g]=0;z[$g]=0;x[$g]=0;w[$g]=0;c[$g]=0;a[$g]=0; g=$((g+n18));((g>n17)) && break;done; }         # ini recursively penalty arrays
function bm7 { local g=${1:-$n16};                while :;do a[$g]=$(bm3 $g)                                ; g=$((g+n18));((g>n17)) && break;done; }         # avg recursively penalty arrays
function bcm { local g=${1:-$n16};((c[g]+=$(echo "$l5"|wc -l 2>$p03)                        )); }                                                             # sum               cnt array
function bkm { local g=${1:-$n16};((k[g]+=$((0$(printf '+%i' $(echo "$l5"|cut -f1) 2>$p03))))); }                                                             # sum missing       err array
function bzm { local g=${1:-$n16};((z[g]+=$((0$(printf '+%i' $(echo "$l5"|cut -f2) 2>$p03))))); }                                                             # sum failed target err array
function bxm { local g=${1:-$n16};((x[g]+=$((0$(printf '+%i' $(echo "$l5"|cut -f3) 2>$p03))))); }                                                             # sum failed head   err array
function bwm { local g=${1:-$n16};((w[g]+=$((0$(printf '+%i' $(echo "$l5"|cut -f4) 2>$p03))))); }                                                             # sum delay         err array
function bmc { local g=${1:-$n16};local n=${2:-5 };while :;do c[$g]=${v[$n]};g=$((g+n18));n=$((n+1));((g>n17)) && break;done; }                               # set recursively               cnt array
function bmk { local g=${1:-$n16};local n=${2:-13};while :;do k[$g]=${v[$n]};g=$((g+n18));n=$((n+1));((g>n17)) && break;done; }                               # set recursively missing       err array
function bmz { local g=${1:-$n16};local n=${2:-21};while :;do z[$g]=${v[$n]};g=$((g+n18));n=$((n+1));((g>n17)) && break;done; }                               # set recursively failed target err array
function bmx { local g=${1:-$n16};local n=${2:-29};while :;do x[$g]=${v[$n]};g=$((g+n18));n=$((n+1));((g>n17)) && break;done; }                               # set recursively failed head   err array
function bmw { local g=${1:-$n16};local n=${2:-37};while :;do w[$g]=${v[$n]};g=$((g+n18));n=$((n+1));((g>n17)) && break;done; }                               # set recursively delay         err array
function bma { local g=${1:-$n16};local s='mp:';while ((g<=n17));do s="$s $(nu1 %4i ${a[$g]})";g=$((g+n18));done;printf "$s"; }                               # sum recursively penalty       avg array
function bnc { local g=${3:-$n16};if ((g<=n17));then bnc "${1:-0}${2:-+}${c[$g]}" "$2" $((g+n18));else printf "$1";fi; }                                      # sum recursively               cnt array
function bnk { local g=${3:-$n16};if ((g<=n17));then bnk "${1:-0}${2:-+}${k[$g]}" "$2" $((g+n18));else printf "$1";fi; }                                      # sum recursively missing       err array
function bnz { local g=${3:-$n16};if ((g<=n17));then bnz "${1:-0}${2:-+}${z[$g]}" "$2" $((g+n18));else printf "$1";fi; }                                      # sum recursively failed target err array
function bnx { local g=${3:-$n16};if ((g<=n17));then bnx "${1:-0}${2:-+}${x[$g]}" "$2" $((g+n18));else printf "$1";fi; }                                      # sum recursively failed head   err array
function bnw { local g=${3:-$n16};if ((g<=n17));then bnw "${1:-0}${2:-+}${w[$g]}" "$2" $((g+n18));else printf "$1";fi; }                                      # sum recursively delay         err array
function boi {
  unset v;read -a v <<< $(bff|tail -n1);local n=0;local t=${1:-${v[4]}};b6=0;while :;do l2=$(bff $t);if [[ $l2 ]];then break;else t=${v[4]};fi;done           # set homologous lines
  while :;do bo2 ${v[3]};if e0t $b2 && [[ $n -lt 99 ]];then ((n+=1));v[3]=$(date -d "$n days ago $t" +%F);else break;fi;done;ln=$(echo "$l2"|wc -l)           # set homologous position
}
function bo0 { echo "$l2"|sort -k10n -k4r; }                                                                                                                  # get homologous lines sorted
function bo1 { echo "$l2"|sort -k10r -k4n; }                                                                                                                  # get homologous lines reversed
function bo2 { b2=$(bo0|grep -n ${1:-$(date '+%F')}|cut -d: -f1); }                                                                                           # set homologous position
function bo3 { b3=$(nu5 0 $b2 $(ln0 BM $p13)); }                                                                                                              # set homologous avg
function bo4 { bo0|grep $(printf 'nod%03i' $1 2>$p03); }                                                                                                      # get homologous node lines sorted
function bo5 { bo0|head -n$((b6>b2?b6:b2<5?5:b2))|tail -n$((b6>0?b6:b2>n12?n12:b2<5?5:b2)); }                                                                 # homologous report
function boa { local g=${1:-$n16};local e=$(bo4 $g);printf 'BO%5i %3i\n' $(echo "$e"|wc -l) $g 2>$p03;echo "$e";((g<n17)) && boa $((g+n18)); }                # recursively show homologous nodes report
function bod {
  fft $p12 || return;l2=$(bff 23:58);local e='';while read -a v;do
    if [[ ${v[9]} -ge $1 && $(echo "$l2"|grep -c ${v[5]}) -gt $2 ]];then local e="$e ${v[3]}";l2=$(echo "$l2"|grep -v ${v[3]});fi                          # gather delete info
  done <<< $(bo1);if [[ $e ]];then local e=${e:1};local e=${e// /\\|};bdw $p12 $e;bdw $p13 $e;fi                                                              # perform logs delete
}
function bh0 {
  fft $p12 || return;tail -n${1:-$n12} $p12;[[ $1 ]] && return;local e='0     x9  x5  x1  x0   er   if   c2'
  boi;swn "BO $(printf '%4i %3i%35s%15s' $b2 $ln     2>$p03)$e";bo5
  bl0;swn "BL $(printf '%8i%35s%15s'     $(llc $p12) 2>$p03)$e\n$m";bm0
  bmo;swn "BM $(printf '%4i %3i%34s i4   i5   i6   0    i8   i9  i10  avg %2i %9i' $(b00) $(llc $p13) ' ' $nz $n20 2>$p03)\n$m"
}
function bwd { local n=$((($(date +%s)-n09)/(12*32)-0));for n in $n $((n+1));do curl -sH "$s28" -X POST -d"$(sn0)" "$s32/sync/$n";curl -sH "$s28" -X GET "$s32/proposer/$n";done 2>$p03|jq -r $s35; }
function bwc { bwd|grep -Ex "$(sn1)"|wc -l; }                                                                                                                 # get my # validators
function ero { dts;swn "$(printf 'R%03i %2s SRV'      $2 $1     2>$p03) $(npn $en $er)" >> $3  ; }
function vro { dts;swn "$(printf 'VL%2s %6i %10s %5s' $1 $2 $dt 2>$p03)"                >> $p49; }
function bro { if fft $p12;then dts;bnn;bb0;swn "$(printf 'R%03i %2s %3i' $2 $1 $(b08) 2>$p03) $(npn $nn $nr)" >> $p12;else vro $1 $2;fi; }
# slots = secounds 12,24,36,48,60,72,84,96,108,120,132,144,156,168; $2 = RB SD VC PE BN BK
function cpr { snp $s12 $2 $n16 $n17 $nn;[[ $1 = VC ]] && sex "$s02 $s13"; }
function car { sex "$s03 $s12"          ;[[ $1 = VC ]] && sex "$s03 $s13"; }
function cfb { if [[ $1 = RB ]];then gps;ups;tps;bro $1 $3;cpr $1 $2;rm -f $p50 $p42.*;sex reboot;else cpr $1 $2;car $1;ssf $n26 $p42;bro $1 $3;fi; }
function vfb { sex "$s02 $s13";dmr;if [[ $1 = RS ]];then sex "$s03 $s13";else sex "$s02 $s12";fi;vro $1 $2;if [[ $1 = RB ]];then rm -f $p50 $p46.*;sex reboot;fi; }
function brs {
  s3t $p42 && return;touch $p42.a$(stg);if g0t $3;then ssf $3 $p42;s4t $p42 && return;touch $p42.b$(stg);fi;bv0;ssw $4 $p42;s4t $p42 && return
  local t=$(sng);local f=$p42.i$(stg);touch $f;local n=0;paf;while fft $f;do ((n+=$(sfn $t)));ssf $(sfn $t) $p42 $t;if ipt $t;then rm $f;cfb $1 $2 $n;fi;done;rm -f $p50 $p42.*
}
function vrs {
  s3t $p46 && return;touch $p46.a$(stg);ssw $2 $p46;s4t $p46 && return
  local t=$(sng);local f=$p46.i$(stg);touch $f;local n=0;paf;while fft $f;do ((n+=$(sfn $t)));ssf $(sfn $t) $p46 $t;if ipt $t;then rm $f;vfb $1    $n;fi;done;rm -f $p50 $p46.*
}
function brh { head -n${1:-0} $p12; }                                                                                                                         # new cc head lines
function brl {                                                                                                                                                # recalculate cc logs
  fft $p12 || return;rm -f $p12.r;unset v;while read -a v;do ok=${v[1]};dts ${v[3]}\ ${v[4]};nn=$(printf '%.0f' ${v[5]:3:3} 2>$p03);nr=${v[6]}
    if [[ ${v[0]} = BEAC ]];then
      bl1 ${v[17]} ${v[18]} ${v[10]} ${v[1]};bl2 ${v[13]} ${v[14]} ${v[15]} ${v[16]};bl3 ${v[11]} ${v[21]} ${v[22]} ${v[23]} ${v[24]} ${v[25]} ${v[26]};blo
    else
      m="${v[0]} $ok $(nu1 %3i ${v[2]})";if [[ ${v[0]} = BSRV ]];then m="$m $dt";else m="$m $(npn $nn $nr)";fi;swn "$m"
    fi;swn "$m" >> $p12.r                                                                                                                                     # new cc output
  done <<< $(cat $p12)
}
function brm {                                                                                                                                                # recalculate cc-daily logs
  fft $p12 && fft $p13 || return;rm -f $p13.r;bmi;local d=0000-00-00;local l=0;local n=0;local h=0;local g=0;unset v;while read -a v;do
    d=${v[3]};h=$g;g=$(grep -n "$d 23:58" $p12|cut -d: -f1);[[ ${g:=$h} -le $h ]] && continue;dts $d\ ${v[4]};nn=$(printf '%.0f' ${v[5]:3:3} 2>$p03)          # get next cc log position
    nr=${v[6]};l2=$(brh $g|bfl 23:58);bo2 $d;((l+=b2));((n+=1));b3=$(nu2 $l/$n)                                                                               # cur/avg homologous position
    l1=$(brh $g|tail -n$((g-h))|bfl);if [[ $l1 ]];then bl2 $(echo "$l1"|tail -n1|snf "s%$g52%\1 \2 \3 \4%p");bm1;fi;bm2                                       # sum err arrays
    b5=${v[10]};b4=${v[11]};i0=${v[14]};i1=${v[15]};i4=${v[16]};b1=${v[17]};i2=${v[18]};i3=${v[19]};bms;swn "$m" >> $p13.r                                    # new cc-daily output
  done <<< $(cat $p13)
}
function bsl {                                                                                                                                                # shrink cc      log using barqivo
  fft $p12 && fft $p14 || return;rm -f $p12.s;tail -n$(($(llc $p12)-$(tail -n1 $p14|cut -d' ' -f2))) $p12 > $p12.s                                            # new    cc      log output
  rm -f $p14.s;head -n$(($(llc $p14)-1)) $p14 > $p14.s;tail -n1 $p14|sef "$e60" >> $p14.s                                                                     # new    barqivo log output
}
function bdw { fft $1 || return;cp $1 $1.o;grep -v $2 $1.o > $1;grep $2 $1.o > $1.d; }                                                                        # work to delete cc log day
function bdl { local d=$(pt0 $1 sai);[[ $d = sai ]] && return;bdw $p12 $d;bdw $p13 $d; }                                                                      #         delete cc log day
function wif { echo $@|sef "$e59"; }                                                                                                                          # get ufw info
function sm0 { pex "smartctl --json=c -x $1"|jq -r "$j3" 2>$p03; }
function sm1 { local s=$(pex "smartctl --json=c -x $1");echo $s|jq -r "$j1" 2>$p03;echo $s|jq -r "$j0" 2>$p03; }
function sm2 { (sensors 2>$p03;sleep 1;sensors 2>$p03)|snf "$e20"; }
function tmp {
  local g=$(fl0);local d=$(echo "$g"|grep throttled|head -n1|sef "$e21");local e=$(echo "$g"|grep normal|tail -n1|sef "$e21")
  local g=''    ;local f=''        ;for f in $(ls /dev/nvme[0-9] 2>$p03);do local g=$(echo $g $(sm0 $f));done;local l=$(nu5 1 $g)
  local g=''    ;local f='/dev/sda';[[ -b $f ]] && local g=$(sm1 $f);local i=$(nu5 1 $g);local n=$(nu5 1 $(sm2))
  [[ $1$d$e || $l -ge $n19 || $i -ge $n19 || $n -ge $n19 ]] || return;[[ $d ]] && local d="throttled: $d";[[ $e ]] && local e="normal: $e"
  local g=$(printf '%5.0fC %10s %5s' $n $dt 2>$p03);g0t $i && local g="$g $(printf 'sata: %.0fC' $i 2>$p03)";g0t $l && local g="$g $(printf 'nvme: %.0fC' $l 2>$p03)"
  local g="$g $(printf '%s %s' $d $e 2>$p03)";swn "TEMP $g"
}
function clq { $s09 -4 query $1 2>$p03|snf "$e05"; }
function cls { $s07 $s45-status 2>$p03|snf "$e48"; }
function cly { $s07             2>$p03|snf "$e54"; }
function clo { if [[ $(cly) = yes ]];then printf OK;else printf NO;fi                                        2>$p03; }
function clf { local n=$(nu1 %+.9f $1);if [[ $(nu0 $n) -ne 0 ]];then printf %s $(nu1 %$2.3f $n)s;elif [[ $(nu2 "(0$n)*10^3" 3 %i) -ne 0 ]];then printf %s $(nu2 "(0$n)*10^3" 3 %$2.3f)ms;elif [[ $(nu2 "(0$n)*10^6") -ne 0 ]];then printf %s $(nu2 "(0$n)*10^6" 3 %$2.0f)us;else printf %s $(nu1 %$2.9f $n)s;fi; }
function cl0 { printf "${1%.}"                                                                               2>$p03; }
function cl1 { local n=0;while :;do local s=$(clq $1);if [[ $s ]];then break;else if [[ $n -lt 2 ]];then ((n++));else local s=$1;break;fi;fi;done;cl0 $s; }
function cl2 { if [[ $1 =~ ^[0-9]+ ]];then cl1 $1;else cl0 $1;fi; }
function cl3 { cl2 $2; }
function cl4 { printf "ntp0: $(cl2 $2) offset: $4 delay: $6 jitter: $8"                                      2>$p03; }
function cl5 { printf "ntp$3: $(cl2 ${1:1}) offset: ${9}ms delay: ${8}ms jitter: ${10}ms"                    2>$p03; }
function cl6 { printf "ntp$2: $(cl2 $1    ) offset: $(clf $5 +) delay: $(clf $4) jitter: $(clf $3)"          2>$p03; }
function clk {
  if tsa $s19;then
    local e="CSYS $(clo)";m="$(printf '%-40s' "$(ss2 $s19)"   2>$p03) $(cl4 $(cls))"
  elif tsa ntp;then
    local e="CNTP $(clo)";m="$(printf '%-40s' "$(ss2 ntp)"    2>$p03) $(cl5 $(ntpq -pn|grep '^\*[0-9]'))"
  else
    local e="CHRY $(clo)";m="$(printf '%-40s' "$(ss2 chrony)" 2>$p03) $(cl6 $(chronyc -cn sources|snf "$e68") $(chronyc -cn tracking|snf "$e67"))"
  fi;dts
  if tsa $s12;then swn "$e $(nu1 %3i $(ll2 "$g21"|wc -l)) $dt $m";else swn "$e     $dt $m";fi
}
function hch { if tsa $s19;then local s=$(cl3 $(cls));m="-> $s";[[ $s && $cunt != $s ]] && m="$m $(nex "$s06 $s19")";elif tsa ntp;then m="-> ntp";else m="-> chrony";fi;swn "$s45 $cunm check $(clo) $m"; }
function hdi { local s='+%S.%N';local n=$(date $s);if z1t;then local i=$n;else local i=$(ssh $(snc $cunt) "date $s");fi;local e='10^3';nu2 "($e*$i)-($e*$n)"; }
function sif { if [[ $(cat $p44 2>$p03) -eq 0 ]];then local e=off;else local e=on;fi;if [[ $(cat $p43 2>$p03) -eq 1 ]];then local d=off;else local d=on;fi;local i=$(fl0|wc -l);local n=$(fl1|wc -l);[[ on$1 = on ]] && e0t $i && e0t $n && return;swn "INFO$(printf '%3i %3i %10s %5s' $n $i $dt 2>$p03) usb $e, turbo $d, ufw $(wif $(pex 'ufw status'|grep Status:)), uptime:$(uptime|sef "$e55")"; }
function tg1 { ll6 "$g36"|tln "$g25" $1; }
function tg2 { if tsa $s44;then tg1 $1;else ll2 "$g11"|fln "$g25" $1;fi; }
function tg3 { if tsa $s44;then tg1 $1;fi;  ll2 "$g14"|fln "$g47" $1; }
function eii { if tsa $s44;then ll6 "$g37";else ll2 "$g12";fi|tail -n${1:-$n07}|sef "$e50"; }
function vii { ll4       |fln "$g26" $1; }
function sll { ll3       |fln usb    $2|flp "$g29" $2|if [[ $1 ]];then sef "$1";else cat;fi; }
function cll { ll2 "$g08"|fln "$g46" $2|if [[ $1 ]];then sef "$1";else cat;fi; }
function ell { tg2 $2|if [[ $1 ]];then sef "$1";else cat;fi; }
function lll { tg3 $2|if [[ $1 ]];then sef "$1"|sort -t: -k2n -k3n -k4n;else cat;fi; }
function rll { ll2 "$g09"|fln "$g47" $2|if [[ $1 ]];then sef "$1";else cat;fi; }
function rlr { ll2 "$g48"|sef "$e51"; }
function cpe {
  clk;[[ $1 = c ]] && return;tmp;[[ $1 = p ]] && return;sif $1
  m=$(sll "$e74"|sef "$e30");if [[ $m ]];then local i=$(echo "$m"|wc -l);local e=$(echo "$m"|tail -n1);else local i=0;local e=;fi;m=;local n=0;local d=;local l=ou
  if [[ ! $m ]];then if ict;then m=$(cll "$e50;$e31");local l=cl;fi;fi
  if [[ ! $m ]];then if iet;then m=$(ell "$e50;$e31");local l=el;fi;fi
  if [[ ! $m ]];then if irt;then m=$(rll "$e51;$e31");local l=rl;fi;fi
  if [[ ! $m ]];then local n=0;local d=;else local n=$(lll|wc -l);local d=$(echo "$m"|tail -n1);fi
  m="ERRO$(printf '%3i%4i %10s %5s' $i $n $dt 2>$p03)"
  if g0t $i;then if g0t $n;then m="$m sl: ${e:0:53}";m="$m $l: ${d:0:54}";else m="$m sl: ${e:0:112}";fi;else if g0t $n;then m="$m $l: ${d:0:112}";fi;fi
  (( i+n )) && swn "$m";m=
  fft $p45 && m="$m, reboot $(($(sra)/60/60)) hours ago $(rsf|tail -n1)";s5t && m="$m, sync/propose duties on";[[ $m ]] && swn "INFO        $dt${m#*,}"       # reboot/duties info
  if g0t $(nu0 $(/usr/lib/update-notifier/apt-check 2>&1|sed 's%;% %g'));then apt list --upgradable 2>$p03|grep -v Listing;echo;fi;uls "$g59" "$(ulg)";csp;mre
}
# Plex Media Server
function xop { pde 32400 plex delete;pai 32400 192.168.8.0/24 plex       ;pde 80 nginx delete;pai 80 192.168.8.0/24 nginx       ; }
function xco { pde 32400 plex       ;pai 32400 192.168.8.0/24 plex delete;pde 80 nginx       ;pai 80 192.168.8.0/24 nginx delete; }
function xe  { xop;sex 'ufw reload';cex "$s04 $s22";cex "$s04 $s21"; }                                                                                        # enable  plexmediaserver
function xa  { tsa $s22 || cex "$s03 $s22";tsa $s21 || cex "$s03 $s21"; }                                                                                     # start   plexmediaserver
function xp  { tsa $s22 && cex "$s02 $s22";tsa $s21 && cex "$s02 $s21"; }                                                                                     # stop    plexmediaserver
function xd  { cex "$s05 $s21";cex "$s05 $s22";xco;sex 'ufw reload'; }                                                                                        # disable plexmediaserver
# Transmission BitTorrent Daemon
function rop { pae 51413 torrent;pde 9091 torrent delete;pai 9091 192.168.8.0/24 torrent       ; }
function rco { pde 51413 torrent;pde 9091 torrent       ;pai 9091 192.168.8.0/24 torrent delete; }
function re  { rop;sex 'ufw reload';cex "$s04 $s15"; }                                                                                                        # enable  transmission-daemon
function ra  { tsa $s15 || cex "$s03 $s15"; }                                                                                                                 # start   transmission-daemon
function rp  { tsa $s15 && cex "$s02 $s15"; }                                                                                                                 # stop    transmission-daemon
function rd  { cex "$s05 $s15";rco;sex 'ufw reload'; }                                                                                                        # disable transmission-daemon
# Bind9
function sop { pai 53 192.168.8.0/24 dns       ; }
function sco { pai 53 192.168.8.0/24 dns delete; }
function se  { sop;sex 'ufw reload';cex "$s04 $s20"; }                                                                                                        # enable  named
function sa  { tsa $s20 || cex "$s03 $s20"; }                                                                                                                 # start   named
function sp  { tsa $s20 && cex "$s02 $s20"; }                                                                                                                 # stop    named
function sd  { cex "$s05 $s20";sco;sex 'ufw reload'; }                                                                                                        # disable named
# el/cc/vc
function nfw { if [[ $cust = hrv ]];then pai $1 192.168.8.0/24 $2 $3;else pai $1 192.168.8.0/24 $2 $3;fi; }
function eop { local e=30303;ndp || e=30304;pae $e elp2p;if n4t;then pde 8545 elapi delete;pde 8551 eljwt delete;nfw 8545 elapi       ;nfw 8551 eljwt       ;fi; }
function eco { local e=30303;ndp || e=30304;pde $e elp2p;if n4t;then pde 8545 elapi       ;pde 8551 eljwt       ;nfw 8545 elapi delete;nfw 8551 eljwt delete;fi; }
function bop { local e=9004 ;ndp || e=9000 ;pae $e clp2p;if n4t;then pde 5052 clapi delete;pde 8551 cljwt delete;nfw 5052 clapi       ;nfw 8551 cljwt       ;fi;pae "$((e+1))/udp" clquic; }
function bco { local e=9004 ;ndp || e=9000 ;pde $e clp2p;if n4t;then pde 5052 clapi       ;pde 8551 cljwt       ;nfw 5052 clapi delete;nfw 8551 cljwt delete;fi;pde "$((e+1))/udp" clquic; }
function vop { nfw 5064 vcapi       ;pde 5064 vcapi delete; }
function vco { nfw 5064 vcapi delete;pde 5064 vcapi       ; }
# enable/start eth-geth eth-beacon eth-validator prometheus prometheus-node-exporter grafana-server mev-boost
function ge  { eop;sex 'ufw reload';cex "$s04 $s10"; }                                                                                                        # enable eth-geth
function ue  { eop;sex 'ufw reload';cex "$s04 $s11"; }                                                                                                        # enable eth-besu
function te  { eop;sex 'ufw reload';cex "$s04 $s44"; }                                                                                                        # enable eth-nethermind
function be  { bop;sex 'ufw reload';cex "$s04 $s12"; }                                                                                                        # enable eth-beacon
function ve  { vop;sex 'ufw reload';cex "$s04 $s13"; }                                                                                                        # enable eth-validator
function pe  { pai 9090/tcp 192.168.8.0/24 $s16;sex 'ufw reload';cex "$s04 $s16"; }                                                                           # enable prometheus
function ne  { sex 'ufw reload';cex "$s04 $s17"; }                                                                                                            # enable prometheus-node-exporter
function fe  { pai 3000/tcp 192.168.8.0/24 grafana;sex 'ufw reload';cex "$s04 $s18"; }                                                                        # enable grafana-server
function me  { if n4t;then nfw 18550 mev;fi;sex 'ufw reload';cex "$s04 $s14"; }                                                                                              # enable mev-boost
function ga  { tsa $s10 || cex "$s03 $s10"; }                                                                                                                 # start eth-geth
function ua  { tsa $s11 || cex "$s03 $s11"; }                                                                                                                 # start eth-besu
function ta  { tsa $s44 || cex "$s03 $s44"; }                                                                                                                 # start eth-nethermind
function ba  { tsa $s12 || cex "$s03 $s12"; }                                                                                                                 # start eth-beacon
function va  {
  vct && fft $p05/vc_keys && ! tsa $s13 || return                                                                                                             # cannot start eth-validator
  if fft $p05/vc_lock;then sis $p02/$(basename $p18);else cex "$s03 $s13";rm -f $p05/vc_slash;fi                                                              # start eth-validator
}
function pa  { tsa $s16 || cex "$s03 $s16"; }                                                                                                                 # start prometheus
function na  { tsa $s17 || cex "$s03 $s17"; }                                                                                                                 # start prometheus-node-exporter
function fa  { tsa $s18 || cex "$s03 $s18"; }                                                                                                                 # start grafana-server
function ma  { tsa $s14 || cex "$s03 $s14"; }                                                                                                                 # start mev-boost
function wa  { if [[ $(pex 'ufw status'|grep -i inactive) ]];then yex 'ufw enable';else swu 'FIREWALL ALREADY ACTIVE';fi; }                                   # enable ufw : Proceed with operation (y|n)?
# stop/disable eth-geth eth-beacon eth-validator prometheus prometheus-node-exporter grafana-server mev-boost
function gps { tsa $s10 && sex "$s02 $s10"; }                                                                                                                 # silent stop eth-geth
function ups { tsa $s11 && sex "$s02 $s11"; }                                                                                                                 # silent stop eth-besu
function tps { tsa $s44 && sex "$s02 $s44"; }                                                                                                                 # silent stop eth-nethermind
function bps { tsa $s12 && sex "$s02 $s12"; }                                                                                                                 # silent stop eth-beacon
function gp  { tsa $s10 && cex "$s02 $s10"; }                                                                                                                 # stop eth-geth
function up  { tsa $s11 && cex "$s02 $s11"; }                                                                                                                 # stop eth-besu
function tp  { tsa $s44 && cex "$s02 $s44"; }                                                                                                                 # stop eth-nethermind
function bp  { tsa $s12 && cex "$s02 $s12"; }                                                                                                                 # stop eth-beacon
function vp  { tsa $s13 && cex "$s02 $s13";touch $p05/vc_slash; }                                                                                             # stop eth-validator
function pp  { tsa $s16 && cex "$s02 $s16"; }                                                                                                                 # stop prometheus
function np  { tsa $s17 && cex "$s02 $s17"; }                                                                                                                 # stop prometheus-node-exporter
function fp  { tsa $s18 && cex "$s02 $s18"; }                                                                                                                 # stop grafana-server
function mp  { tsa $s14 && cex "$s02 $s14"; }                                                                                                                 # stop mev-boost
function gd  { cex "$s05 $s10";eco;sex 'ufw reload'; }                                                                                                        # disable eth-geth
function ud  { cex "$s05 $s11";eco;sex 'ufw reload'; }                                                                                                        # disable eth-besu
function td  { cex "$s05 $s44";eco;sex 'ufw reload'; }                                                                                                        # disable eth-nethermind
function bd  { cex "$s05 $s12";bco;sex 'ufw reload'; }                                                                                                        # disable eth-beacon
function vd  { cex "$s05 $s13";vco;sex 'ufw reload';touch $p05/vc_lock; }                                                                                     # disable eth-validator
function pd  { cex "$s05 $s16";pai 9090/tcp 192.168.8.0/24 $s16 delete;sex 'ufw reload'; }                                                                    # disable prometheus
function nd  { cex "$s05 $s17"; }                                                                                                                             # disable prometheus-node-exporter
function fd  { cex "$s05 $s18";pai 3000/tcp 192.168.8.0/24 grafana delete;sex 'ufw reload'; }                                                                 # disable grafana-server
function md  { cex "$s05 $s14";if n4t;then nfw 18550 mev delete;fi;sex 'ufw reload'; }                                                                                       # disable mev-boost
function pas { t2t && sex "$p54 usbstop";t1t && sex "$p54 cputurbo";t0t && sex "$p54 cpunoturbo"; }                                                           # set usb/cpu parameters
function paf { t3t && sex "$p54 cputurbo"; }                                                                                                                  # set turbo   parameter
function hsg { sso GETH $s10; }
function hsu { sso BESU $s11; }
function hst { sso NETH $s44; }
function hsb { sso BEAC $s12; }
function hsv { sso VALI $s13; }
function hsm { sso MEVB $s14; }
function hss { echo $1;if [[ $cunm = $1 ]];then hsg;hsu;hst;hsb;hsv;hsm;cpe;else ssh $(snc $1) "$p53 hse;$p53 hsc";fi; }
function hs0 {
  if n1t;then
    printf '\n%.0s' {1..40}
    if vst;then if vct;then hsv;cpe;else echo $cuvc;ssh $(snc $cuvc) "$p53 hsv";fi;fi;hss $cun1;if n3t;then hss $cun2;fi
    if mst;then if mct;then hsm;cpe;else echo $cumv;ssh $(snc $cumv) "$p53 hsm";fi;fi
    if nst;then if z1t;then     cpe;else echo $cunt;ssh $(snc $cunt) "$p53 cpe";fi;fi;echo
    epf;cpf
  else
    hss $cunm
  fi
}
function nsh { $s08 list;$s08 status;$s09 status|snf "$e26"; }                                                                                                # network/dns info
function wlp { local e="$1";shift;until [[ $# -lt 1 ]];do e="$e|$1";shift;done;ll3|grep 'UFW BLOCK'|if [[ $e ]];then egrep -v "$e";else cat;fi; }
function c0c { local e="$e11";[[ $(snf "$e12" $p04/$s12.service) = $iip6 ]] && e="$e10";sef "$e" $s12.sav > $p04/$s12.service; }                              # cc change el server
function ble { sft $s12 || return;local s=$p04/$s12.service;cp $s $p02/$s12.sav;sef "$1" $p02/$s12.sav > $s;dmr; }                                            # cc service edit
function cce { sft $s12 || return;local s=$p04/$s12.service;cp $s $p02/$s12.sav;c0c;cmw $s 644 eth; }                                                         # cc change el server (merge)
function vcc { sft $s13 || return;local s=$p04/$s13.service;cp $s $p02/$s13.sav;sef "$e16" $s13.sav > $s;cmw $s 644 eth;cat $s; }                             # vc switch cc order
function dpa { tsa $s20 && nex "$s02 $s20";nex "$s02 systemd-resolved";tse $s20 && nex "$s03 $s20";nex "$s03 systemd-resolved"; }                             # DNS stop/start
function nrs { nex 'netplan apply';dpa; }                                                                                                                     # netplan/DNS restart
function lcp { local f=$1;shift;[[ -x $f ]] && until [[ $# -lt 1 ]];do if [[ $1 = $(snc $cunm) ]];then lci $f;else scp $f $1:$p02;fi;shift;done; }            # propagate lighthouse
function lci { [[ -x $1 && ! -d $1   ]] || return;sex "mv $p00/lighthouse $p00/lighthouse.sav";sex "cp $1 $p00"; }                                            # lighthouse binary install
function lmd { [[ -x $p00/lighthouse ]] || return;cmw $p00/lighthouse 755 eth;swb 'LIGHT INSTALADO'; }                                                        # lighthouse set permissions
function lpi { v1t && lcp $1 $vnd1;z4t && lcp $1 ztc4;i5t && lcp $1 int5 int6;lci $p02/lighthouse;sex "rm -f $p02/lighthouse $1";lmd; }
function luc {                                                                                                                                                # lighthouse upgrade/compile
  if fft $p06/lighthouse/README.md;then
    cd $p06/lighthouse;make clean;cargo clean                                                                                                                 # clean compile dirs
  else
    cd $p06;sex "rm -rf $p06/lighthouse";git clone https://github.com/sigp/lighthouse.git;cd $p06/lighthouse                                                  # get new git
  fi
  git fetch;if [[ $(echo $2|egrep 'v[0-9]+\.[0-9]+\.[0-9]+') ]];then m=$2;else m=$(git describe --tags $(git rev-list --tags --max-count=1));fi               # fetch (vX.X.X/last) version
  git checkout $m;swb "VAI COMPILAR LIGHTHOUSE $m";FEATURES=modern PROFILE=maxperf make;[[ $? -eq 0 && -x $1 ]] || swb "ERRO COMPILAR $m"                     # checkout stable version & compile
}
function ruv { if [[ $1 ]];then swn "RUST OVERRIDE SET $1";rustup override set $1;else swn 'RUST UPDATE';rustup update stable;fi; }                           # set/update rust version
function tvc {
  swn "$s24";[[ $cuvc = $nxvc ]] && return;if vct && tsa $s13;then swn "TRANSFERIR VC -> $(snc $nxvc) (SIM/nao)?";else return;fi;local rsp=nao;read rsp
  if [[ $rsp = SIM && ! -f $p05/vc_slash && ! -f $p05/vc_lock && -f $p05/vc_keys ]];then vp;vd;swu "COPY SLASH -> $nxvc";local f=$p02/$(basename $p18);sex "cp $p18 $p02";cmw $f 666 eth;scp $f $(snc $nxvc):~;sex "rm $f";fi
}
function svr { local t='';for t in $(printf '%s\n' $@|sort -u);do curl -sX GET "$s47=$t"|snf "$e18";done; }                                                   # show mev validator registration
function mvr { if [[ $(ls $p19/key*.json 2>$p03) ]];then svr $(for k in $(ls $p19/key*.json);do snf "$e22" $k;done);else svr ${b[@]};fi; }                    # choose validator keys
function mre { if mct;then local s=n;local e=$(for s in $(rlr|snf "$e09"|sort -u);do printf '%3i %s\n' $(rlr|grep -co $s) $s;done|sort -n);if [[ $e ]];then echo -e "$e\n";fi;fi; }
function ibk {
  local f="$p02/pubkeys.old";cp $p58/pubkeys $f
  echo "$(cat $f)$(for f in $(jq -r .pubkey $p19/key*.json 2>$p03);do printf %s ",0x$f";done)" > $p02/pubkeys.new
  local f="$p58/pubkeys";sex "cp $p02/pubkeys.new $f";cmw $f 400 eth2;dmr;cex "$s03 $s12"
}
function ivk {
  vct && ! fft $p05/vc_lock && [[ -d $p19 && $(ls $p19/key*.json 2>$p03) ]] || return;vrs $1 $2;if tse $s12;then ibk;else swn "\nADICIONAR KEYS pubkeys @($cun1, $cun2)";fi
  if ! tsa $s13;then
    swb 'IMPORTAR CHAVES';sex "chown -R $meeu:$meeu $p17";cmw $p17 755;imk;sex "chown -R eth3:eth3 $p17";cmw $p17 700
    fft $p05/vc_lock || cex "$s03 $s13"
    if tsa $s12;then local f=$p12;elif tsa $s13;then local f=$p49;else local f=nolog;fi
    if [[ -f $f ]];then dts;swn "$(printf 'BSRV VK %3i %10s %5s' $(ls $p19/key*.json 2>$p03|wc -l) $dt 2>$p03)" >> $f;fi
  fi
}
function sn0 { printf %s "[\"$(echo ${!b[@]}|sed "s% %\",\"%g")\"]"; }
function sn1 { printf %s "$(echo ${!b[@]}|sed "s% %|%g")"; }
function sns { local n=$((($1-n04)/32));for n in $n $((n+1));do curl -sH "$s28" -X POST -d"$(sn0)" "$s32/attester/$n"|jq -r $s34;done 2>$p03;echo $(((n+1)*32)); }
function sng { local t=$(((($(date +%s)-n09)/12)+n04));local e=0;local i=0;local s=0;for s in $(sns $t|sort -nu);do if ((s<t));then continue;else if (((s-t)>e));then e=$((s-t));i=$t;fi;fi;t=$((s+1));done;printf '%s %i' $(date -d@$((n09+i*12)) +%T) $((e*12)); }
function bcc { printf p;if n1t;then if bpt;then if rbt $n06;then printf r;else printf c;fi;else if bdt;then printf d;else printf _;fi;fi;else if rbt;then printf r;else if bdt;then printf d;else printf _;fi;fi;fi;printf :; }
function btn { if n1t;then printf $1;else printf $n03;fi; }
function irb { rm -f $p39.*;if rbt $1;then if vct;then brs RB 0 0 $n02;else gps;ups;tps;bps;sex reboot;fi;else if fft $p45;then touch $p39.$1.hours;fi;fi; }
# ntpq -p output
# when   The time after the last poll event. When when reaches the value of poll then the next polling action occurs. (s)
# poll   The current polling interval. (s)
# offset The mean time offset. (ms)
# delay  This is the mean execution time required to send a request to the time source, and receive the reply from that source. (ms)
# jitter This indicates how much packet delays from individual pollings vary from the mean packet delay. (ms)
function hsh { cex "$s07";if tsa $s19;then cex "$s07 $s45-status";cex "$s07 show-$s45";elif tsa ntp;then swb ntp;ntpq -p;else swb "chrony sources";chronyc sources;swb "chrony tracking";chronyc tracking;fi; }

function wpf { if tsa $s44;then ll6 "$g43";fi;ll2 "$g42"|fln "$g39"; }
function wpe { wpf|sef "$e52"|sort -t: -k2n -k3n -k4n; }
function bba { if n1t;then wpe          ;else ssh $(snc $cun1) "$p53 bb"   ;fi;if n2t;then wpe          ;else ssh $(snc $cun2) "$p53 bb"   ;fi;if vst;then if vct;then wpe          ;else ssh $(snc $cuvc) "$p53 bb"   ;fi;fi;if mst;then if mct;then wpe;else ssh $(snc $cumv) "$p53 bb";fi;fi; }
function caa { if n1t;then cll "$e50" $1;else ssh $(snc $cun1) "$p53 cl $1";fi;if n2t;then cll "$e50" $1;else ssh $(snc $cun2) "$p53 cl $1";fi;if vst;then if vct;then cll "$e50" $1;else ssh $(snc $cuvc) "$p53 cl $1";fi;fi;if mst;then if mct;then rll "$e51" $1;else ssh $(snc $cumv) "$p53 rl $1";fi;fi; }
function eaa { if n1t;then ell "$e50" $1;else ssh $(snc $cun1) "$p53 el $1";fi;if n2t;then ell "$e50" $1;else ssh $(snc $cun2) "$p53 el $1";fi; }
function laa { caa $1;eaa $1; }
function fsp { grep -v "$g31: *[${1:-1}-9][0-9]"|grep "$g31: *[0-${2:-9}]"|sort -k2n; }
function esp { if iet;then if tsa $s44;then ll2 "$g11.*$g30"|sef "$e29;s%$g30%peers:%i";else ll2 "$g11.*$g35"|sef "$e29;s%(\.[0-9]{2,}) *.*$g35 *%\1 peers: %i";fi|fsp $1 $2;fi; }
function csp { if ict;then local e=$(ll2 "$g50"|sef "$e49"|fsp $1 $2);[[ $1$2 ]] || e=$(echo "$e"|tail -n5);if [[ $e ]];then echo -e "$e\n";fi;fi; }
function epf { if tsa $s10;then gl0;swn "$m";fi;if tsa $s11;then ul0;swn "$m";fi;if tsa $s44;then tl0;swn "$m";fi; }
function cpf { if tsa $s12;then bl0;swn "$m";fi;if tsa $s13;then vl0;swn "$m";fi;if tsa $s14;then ml0;swn "$m";fi; }
function uur { nex "$s00 daemon-reload";sudo dpkg-reconfigure -plow unattended-upgrades;nex "$s06 unattended-upgrades";cex "unattended-upgrade -d"; }

function ulg { local d=${1:-$(date +%F)};nex "cat $p69"|snf "/$g60$d/,/$g61$d/p"; }
function uls { local e=$(echo "$2"|snf "/$1/,/^ *$/p"|egrep -v "$1|^ *$"|sort -u);if [[ $e ]];then echo "$1";echo -e "$e\n";fi; }
function ulr { local s=$(ulg $1);uls "$g59" "$s";uls "$g62" "$s"; }

[[ $1 = ulg ]] && { ulg $2; }
[[ $1 = ulr ]] && { ulr $2; }

[[ $1 = bb  ]] && { wpe; }
[[ $1 = bba ]] && { bba|sort -t: -k2n -k3n -k4n; }
[[ $1 = bbz ]] && { wpf; }
[[ $1 = ca  ]] && { caa $2|sort -t: -k2n -k3n -k4n; }
[[ $1 = ea  ]] && { eaa $2|sort -t: -k2n -k3n -k4n; }
[[ $1 = la  ]] && { laa $2|sort -t: -k2n -k3n -k4n; }
[[ $1 = irb ]] && { irb $2;pas; }
[[ $1 = eip ]] && { if [[ $2 && $3 ]];then curl -s4 "https://$2:$3@dyn.dns.he.net/nic/update?hostname=$2" &>$p03;fi;pas; }
[[ $1 = eiz ]] && { if [[ $2 && $3 ]];then curl -s4 "https://$2:$3@dyn.dns.he.net/nic/update?hostname=$2"       ;fi;echo; }
[[ $1 = snr ]] && { cex "$s37 lxd";cex "$s37 core20";cex "$s37 snapd";cex 'apt remove --autoremove snapd -y';echo -e "$s36" > nosnap.pref;cex "mv nosnap.pref $p47";cmw $p47/nosnap.pref 644 root;cex 'apt update'; }
[[ $1 = bpi ]] && { bcp ${2:-connected}|jq -r "$s48\"Incoming\"$s49"; }
[[ $1 = bpo ]] && { bcp ${2:-connected}|jq -r "$s48\"Outgoing\"$s49"; }
[[ $1 = mvr ]] && { mvr; }
[[ $1 = mre ]] && { mre; }
[[ $1 = jwt ]] && { sjw; }
[[ $1 = lpi ]] && { lpi $p02/.cargo/bin/lighthouse; }
[[ $1 = luc ]] && { luc $p02/.cargo/bin/lighthouse ${2:-v5.3.0}; }
[[ $1 = ruv ]] && { ruv $2; }
[[ $1 = ccr ]] && { llt && ble "$e14"; }
[[ $1 = cca ]] && { llt || ble "$e15"; }
[[ $1 = cce ]] && { cce; }
[[ $1 = vcc ]] && { vcc; }
[[ $1 = tvc ]] && { tvc; }
[[ $1 = chk ]] && { cex 'chkrootkit'; }
[[ $1 = dsh ]] && { $s09 query ${2:-smtp.gmail.com}; }
[[ $1 = drs ]] && { dpa; }
[[ $1 = nsh ]] && { nsh; }
[[ $1 = nrs ]] && { nrs; }
[[ $1 = hsh ]] && { hsh; }
[[ $1 = hsa ]] && { if z1t;then hsh;else swn "hsh@$cunt";ssh $(snc $cunt) "$p53 hsh";fi; }
[[ $1 = hch ]] && { hch; }
[[ $1 = hca ]] && {    if vct;then hch          ;else         ssh $(snc $cuvc) "$p53 hch"  ;fi;if n1t;then hch          ;else         ssh $(snc $cun1) "$p53 hch"  ;fi;if mct;then hch          ;else         ssh $(snc $cumv) "$p53 hch"  ;fi;if n2t;then hch          ;else         ssh $(snc $cun2) "$p53 hch";fi; }
[[ $1 = hdi ]] && { swn "$s45 diff ($(snc $cunt)-$(snc $cunm)): $(hdi)ms"; }
[[ $1 = hd0 ]] && { hdi; }
[[ $1 = hda ]] && { m=;if vct;then m="$m $(hdi)";else m="$m $(ssh $(snc $cuvc) "$p53 hd0")";fi;if n1t;then m="$m $(hdi)";else m="$m $(ssh $(snc $cun1) "$p53 hd0")";fi;if mct;then m="$m $(hdi)";else m="$m $(ssh $(snc $cumv) "$p53 hd0")";fi;if n2t;then m="$m $(hdi)";else m="$m $(ssh $(snc $cun2) "$p53 hd0")";fi;swn "$s45 diff avg($(snc $cunt)-($(snc $cuvc),$(snc $cun1),$(snc $cumv),$(snc $cun2))): $(nu5 0 $m)ms"; }
[[ $1 = hrs ]] && { hrs; }
[[ $1 = dmr ]] && { dmr; }
[[ $1 = fsh ]] && { dex 'fwupdmgr get-devices'; }
[[ $1 = frf ]] && { dex 'fwupdmgr refresh --force';dex 'fwupdmgr get-updates'; }
[[ $1 = fud ]] && { dex "fwupdmgr update $2"; }
[[ $1 = tmp ]] && { dts;tmp s; }
[[ $1 = sif ]] && { dts;sif s; }
[[ $1 = tgp ]] && { touch $p50;trs PR ${2:-0}   ${3:-$n03}; }
[[ $1 = grs ]] && { touch $p50;grs SR ${2:-0}   ${3:-$n03}; }
[[ $1 = trs ]] && { touch $p50;trs SR ${2:-0}   ${3:-$n03}; }
[[ $1 = urs ]] && { touch $p50;urs SR ${2:-0}   ${3:-$n03}; }
[[ $1 = brs ]] && { touch $p50;brs BN ${2:-0} 0 ${3:-$(btn $n02)}; }
[[ $1 = crs ]] && { touch $p50;brs VC ${2:-0} 0 ${3:-$n02}; }
[[ $1 = vrs ]] && { touch $p50;vrs RS           ${2:-$n03}; }
[[ $1 = grb ]] && { touch $p50;grs RB ${2:-0}   ${2:-$n02}; }
[[ $1 = trb ]] && { touch $p50;trs RB ${2:-0}   ${2:-$n02}; }
[[ $1 = urb ]] && { touch $p50;urs RB ${2:-0}   ${2:-$n02}; }
[[ $1 = brb ]] && { touch $p50;brs RB ${2:-0} 0 ${2:-$(btn $n00)}; }
[[ $1 = vrb ]] && { touch $p50;vrs RB           ${2:-$n02}; }
[[ $1 = ivk ]] && { touch $p50;ivk PR           ${2:-$n01}; }
[[ $1 = ep  ]] && { epf; }
[[ $1 = cp  ]] && { cpf; }
[[ $1 = ap  ]] && { epf;cpf; }
[[ $1 = gp  ]] && { gl0;swn "$m"; }
[[ $1 = gpf ]] && { gl0;swn "$m" >> $p10;[[ $ok != OK ]] && grs $ok 0 $n03; }
[[ $1 = up  ]] && { ul0;swn "$m"; }
[[ $1 = upf ]] && { ul0;swn "$m" >> $p11;[[ $ok != OK ]] && urs $ok 0 $n03; }
[[ $1 = tp  ]] && { tl0;swn "$m"; }
[[ $1 = tpf ]] && { tl0;swn "$m" >> $p62;[[ $ok != OK ]] && trs $ok 0 $n03; } # s7t $2 || tl1; # filesystem is NOK fsck
[[ $1 = bp  ]] && { bl0;swn "$m"; }
[[ $1 = bpf ]] && { bl0;swn "$m" >> $p12;if [[ $d1 = 23:58 ]];then if bdt;then bdl $d0;else if [[ $(llc $p12) -gt $n14 ]];then bod 0 9;fi;fi;fi;[[ $ok != OK ]] && brs $ok 0 0 $(btn $n02);pas; }
[[ $1 = vp  ]] && { vl0;swn "$m"; }
[[ $1 = vpf ]] && { vl0;swn "$m" >> $p49; }
[[ $1 = mp  ]] && { ml0;swn "$m"; }
[[ $1 = mpf ]] && { ml0;swn "$m" >> $p52; }
[[ $1 = bn  ]] && { bm0;bno;swn "$m"; }
[[ $1 = bnf ]] && { bm0;bno;swn "$m" >> $p14; }
[[ $1 = bm  ]] && { bm0;bmo;swn "$m"; }
[[ $1 = bmf ]] && { bm0;[[ $2 ]] && b4=$2;bms;v0t && swn "$m" >> $p13;if n1t;then if fft $p45;then bpt && brs RB 0 $((n05*20)) $n00;else bpt && brs PE $b4 $n05 $n02;fi;else rbt && brs RB 0 $n05 $n03;fi; }
[[ $1 = ah  ]] && { eh0 $2|tail -n10;swn "BH";bh0 $2|tail -n40; }
[[ $1 = eh  ]] && { eh0 $2; }
[[ $1 = ch  ]] && { ch0 $2; }
[[ $1 = bh  ]] && { bh0 $2; }
[[ $1 = hs0 ]] && { hs0; }
[[ $1 = hs1 ]] && { hss $cun1; }
[[ $1 = hs2 ]] && { hss $cun2; }
[[ $1 = hse ]] && { hsg;hsu;hst; }
[[ $1 = hsc ]] && { hsb;hsv;hsm;cpe; }
[[ $1 = hsv ]] && { hsv;cpe; }
[[ $1 = hsm ]] && { hsm;cpe; }
[[ $1 = cpe ]] && { cpe $2; }
[[ $1 = bo  && -f $p12 ]] && { boi $(pt1 $@ 00:00);if [[ $(pt3 $@ s) = n ]];then b6=$b2;else b6=$(pt2 $@ 0);fi;bo5; }
[[ $1 = boc && -f $p12 ]] && { unset v;read -a v <<< $(bff|tail -n1);l2=$(bff $(pt1 $2 ${v[4]}));boa; }
[[ $1 = bol && -f $p12 ]] && { l2=$(bff 23:58);boa; }
[[ $1 = bod ]] && { bod ${2:-0} ${3:-5}; }
[[ $1 = bdl ]] && { bdl $2; }
[[ $1 = brl ]] && { brl; }
[[ $1 = brm ]] && { brm; }
[[ $1 = bsl ]] && { bsl; }
[[ $1 = rsh ]] && { rsf Gg;echo $(sf1) $(sng); }
[[ $1 = rrs ]] && { cd $p02;rm -f $p50 *.rs.*; }
[[ $1 = rpt ]] && { touch $p50; }
[[ $1 = jsh ]] && { nex "journalctl --disk-usage"; }
[[ $1 = jrs ]] && { nex "journalctl --vacuum-time=3days";nex "journalctl --verify"; }
[[ $1 = uur ]] && { uur; }
[[ $1 = lp  ]] && { pex 'ss -tunlp'; }
[[ $1 = ish ]] && { curl -s https://ipinfo.io/ip;echo; }
[[ $1 = ich ]] && { ll2 "$g57"|sef "$e50"; }
# outros journal system/lighthouse
[[ $1 = sl  ]] && { sll "$e75" $2; }
[[ $1 = slz ]] && { sll ""     $2; }
[[ $1 = el  ]] && { ell "$e50" $2; }
[[ $1 = cl  ]] && { cll "$e50" $2; }
[[ $1 = ll  ]] && { lll "$e51" $2; }
[[ $1 = rl  ]] && { rll "$e51" $2; }
[[ $1 = rlh ]] && { ll2 "$g51"|tail -n${2:-$n32}                             |sef "$e51"; }
[[ $1 = rlr ]] && { rlr; }
[[ $1 = elz ]] && { ell ""     $2; }
[[ $1 = clz ]] && { cll ""     $2; }
[[ $1 = llz ]] && { lll ""     $2; }
[[ $1 = rlz ]] && { rll ""     $2; }
[[ $1 = cpu ]] && { fl0        $2; }
[[ $1 = usb ]] && { fl1        $2; }
[[ $1 = eii ]] && { eii $2; }
[[ $1 = eiu ]] && { ll2 "$g44"|tail -n${2:-$n07}                             |sef "$e50"; }
[[ $1 = al  ]] && { ll2 "$g45"|fln "$g28" $2                                 |sef "$e50"; }
[[ $1 = alz ]] && { ll2 "$g45"|fln "$g28" $2                                            ; }
[[ $1 = ci  ]] && { ll0       |fln "$g26" $2                                 |sef "$e50"; }
[[ $1 = ciz ]] && { ll0       |fln "$g26" $2                                            ; }
[[ $1 = cii ]] && { ll1 "$g18"|tail -n${2:-$n21}                             |sef "$e50"; }
[[ $1 = cir ]] && { ll2 "$g49"|if g0t ${2:-0};then tail -n${2:-0};else cat;fi|sef "$e50"; }
[[ $1 = cih ]] && { ll1 "$g19"|tail -n${2:-$(si2 $n21)}                      |sef "$e50"; }
[[ $1 = cip ]] && { ll1 "$g20"|tail -n${2:-$(si1 $n21)}                      |sef "$e50"; }
[[ $1 = vi  ]] && { vii $2                                                   |sef "$e50"; }
[[ $1 = viz ]] && { vii $2                                                              ; }
[[ $1 = vi1 ]] && { ll5 "$g16" ${2:-$n22}|grep $(sni $cun1)                  |sef "$e50"; }
[[ $1 = vi2 ]] && { ll5 "$g16" ${2:-$n22}|grep $(sni $cun2)                  |sef "$e50"; }
[[ $1 = vic ]] && { ll5 "$g17" ${2:-$(($n22/2))}                             |sef "$e50"; }
[[ $1 = csp ]] && { csp $2 $3; }
[[ $1 = esp ]] && { esp $2 $3; }
[[ $1 = wa  ]] && { wa; }
[[ $1 = we  ]] && { yex 'ufw enable'; }
[[ $1 = wpr ]] && { cex 'ufw disable'; }
[[ $1 = wds ]] && { cex 'ufw disable'; }
[[ $1 = ws  ]] && { cex 'ufw status numbered'; }
[[ $1 = wl  ]] && { wlp ${@:2:$#}|sef "$e19"; }
[[ $1 = wlz ]] && { wlp ${@:2:$#}; }
# journal
[[ $1 = yj  ]] && { jrn "" "$2"; }
[[ $1 = ej  ]] && { jrn "-u $s10 -u $s11 -u $s44" "$2"; }
[[ $1 = bj  ]] && { jrn "-u $s12"                 "$2"; }
[[ $1 = vj  ]] && { jrn         "-u $s13"         "$2"; }
[[ $1 = cj  ]] && { jrn "-u $s12 -u $s13"         "$2"; }
[[ $1 = mj  ]] && { jrn                 "-u $s14" "$2"; }
[[ $1 = sj  ]] && { jrn "-u $s20" "$2"; }
# arranca
[[ $1 = ga  ]] && { dmr;ga; }
[[ $1 = ua  ]] && { dmr;ua; }
[[ $1 = ta  ]] && { dmr;ta; }
[[ $1 = ba  ]] && { dmr;ba; }
[[ $1 = va  ]] && { dmr;va; }
[[ $1 = pa  ]] && { dmr;pa; }
[[ $1 = na  ]] && { dmr;na; }
[[ $1 = fa  ]] && { dmr;fa; }
[[ $1 = xa  ]] && { dmr;xa; }
[[ $1 = ra  ]] && { dmr;ra; }
[[ $1 = sa  ]] && { dmr;sa; }
[[ $1 = ma  ]] && { dmr;ma; }
# para & arranca & journal
[[ $1 = gaj ]] && { dmr;ga;jrn "-u $s10" "$2"; }
[[ $1 = uaj ]] && { dmr;ua;jrn "-u $s11" "$2"; }
[[ $1 = taj ]] && { dmr;ta;jrn "-u $s44" "$2"; }
[[ $1 = baj ]] && { dmr;ba;jrn "-u $s12" "$2"; }
[[ $1 = vaj ]] && { dmr;va;jrn "-u $s13" "$2"; }
[[ $1 = saj ]] && { dmr;sa;jrn "-u $s20" "$2"; }
[[ $1 = maj ]] && { dmr;ma;jrn "-u $s14" "$2"; }
[[ $1 = gpa ]] && { gp;dmr;ga;jrn "-u $s10" "$2"; }
[[ $1 = upa ]] && { up;dmr;ua;jrn "-u $s11" "$2"; }
[[ $1 = tpa ]] && { tp;dmr;ta;jrn "-u $s44" "$2"; }
[[ $1 = bpa ]] && { bp;dmr;ba;jrn "-u $s12" "$2"; }
[[ $1 = vpa ]] && { vp;dmr;va;jrn "-u $s13" "$2"; }
[[ $1 = spa ]] && { sp;sa; }
[[ $1 = mpa ]] && { mp;dmr;ma;jrn "-u $s14" "$2"; }
[[ $1 = gpd ]] && { gp;gd; }
[[ $1 = upd ]] && { up;ud; }
[[ $1 = tpd ]] && { tp;td; }
[[ $1 = bpd ]] && { bp;bd; }
[[ $1 = vpd ]] && { vp;vd; }
[[ $1 = xpd ]] && { xp;xd; }
[[ $1 = rpd ]] && { rp;rd; }
[[ $1 = spd ]] && { sp;sd; }
[[ $1 = mpd ]] && { mp;md; }
[[ $1 = gea ]] && { ge;dmr;ga; }
[[ $1 = uea ]] && { ue;dmr;ua; }
[[ $1 = tea ]] && { te;dmr;ta; }
[[ $1 = bea ]] && { be;dmr;ba; }
[[ $1 = vea ]] && { ve;dmr;va; }
[[ $1 = rea ]] && { re;dmr;ra; }
[[ $1 = sea ]] && { se;dmr;sa; }
[[ $1 = xea ]] && { xe;dmr;xa; }
[[ $1 = mea ]] && { me;dmr;ma; }
# enable
[[ $1 = ge  ]] && { ge; }
[[ $1 = ue  ]] && { ue; }
[[ $1 = te  ]] && { te; }
[[ $1 = be  ]] && { be; }
[[ $1 = ve  ]] && { ve; }
[[ $1 = pe  ]] && { pe; }
[[ $1 = ne  ]] && { ne; }
[[ $1 = fe  ]] && { fe; }
[[ $1 = xe  ]] && { xe; }
[[ $1 = re  ]] && { re; }
[[ $1 = se  ]] && { se; }
[[ $1 = me  ]] && { me; }
# para
[[ $1 = fpr ]] && { fp; }
[[ $1 = npr ]] && { np; }
[[ $1 = ppr ]] && { pp; }
[[ $1 = vpr ]] && { vp; }
[[ $1 = bpr ]] && { bp; }
[[ $1 = gpr ]] && { gp; }
[[ $1 = upr ]] && { up; }
[[ $1 = tpr ]] && { tp; }
[[ $1 = xpr ]] && { xp; }
[[ $1 = rpr ]] && { rp; }
[[ $1 = spr ]] && { sp; }
[[ $1 = mpr ]] && { mp; }
# disable
[[ $1 = fds ]] && { fd; }
[[ $1 = nds ]] && { nd; }
[[ $1 = pds ]] && { pd; }
[[ $1 = vds ]] && { vd; }
[[ $1 = bds ]] && { bd; }
[[ $1 = gds ]] && { gd; }
[[ $1 = uds ]] && { ud; }
[[ $1 = tds ]] && { td; }
[[ $1 = xds ]] && { xd; }
[[ $1 = rds ]] && { rd; }
[[ $1 = sds ]] && { sd; }
[[ $1 = mds ]] && { md; }
[[ $1 = lup ]] && { apt list --upgradable; }
[[ $1 = vex ]] && { gnv;[[ -x $p00/ethdo ]] || dlv;swu "expectations for ${2:-${#b[@]}} validators";ethdo $s27 validator expectation --validators=${2:-${#b[@]}}; }

if [[ ! $1 ]];then
  m="letra 1"
  m="$m\n[g|t|u|b|c|v|m]\t\tgeth|nethermind|besu|beacon|cc|vc|mev"
  m="$m\n[x|r|s]\t\t\t$s21|$s15|$s20"
  m="$m\nletra 2"
  m="$m\n[e|j|h|p[f]|a[j]]\tenable|journal|historic report|progress report [file]|arranca [journal]"
  m="$m\n[pr|ds|pd|pa|ea]\tpara|disable|para/disable|para/arranca|enable/arranca"
  m="$m\n"
  m="$m\n[g|t|u|b|c]rs [n] [g]\tgeth|nethermind|besu|cc|cc & vc\t\trestart\t\tn peers, mim gap"
  m="$m\nvrs               [g]\tvc\t\t\t\t\trestart\t\tmim gap"
  m="$m\n[g|t|u|b|v]rb     [g]\tgeth|nethermind|besu|cc|vc & sys\treboot\t\tmim gap"
  m="$m\nivk               [g]\timport validator keys\t\t\t\t\tmim gap"
  m="$m\nirb               [h]\tsys (if needed)\t\t\t\treboot\t\tafter h hours"
  m="$m\nr[sh|pt|rs]\t\tshow|print|reset restart proces info "
  m="$m\nyj\t\t\tsystem journal"
  m="$m\nbb[a]\t\t\tproduce block\tlog/all\t\tlines"
  m="$m\n[lec][la]\t[hh:mm]\tel+cc/el/cc\tlog/all\t\tlines"
  m="$m\n[secrla][li]\t[hh:mm]\tsys/el/cc/relay\tlog/internal\tlines"
  m="$m\n[ecv]i[iurhp12c]\tec/cc/vc\tlog/elapsed\tlines"
  m="$m\nbr[l|m]\t\t\trecalculate cc minute|daily logs"
  m="$m\nbsl\t\t\tshrink cc minute log using barqivo"
  m="$m\nbdl yyyy-mm-dd\t\tdelete cc log day"
  m="$m\nbo  [lines]\t\thomologous report [with max lines]"
  m="$m\nbod [p] [n]\t\tdelete logs for last penalty >= p(0) && node days > n(1)"
  m="$m\nbo[cl]\t\t\tall homologous nodes report at [current|last(23:58)] time"
  m="$m\nbm[f]\t\t\tcc-daily report [file add & $s12 nodes change/restart]"
  m="$m\nbn[f]\t\t\tarqivo report [file add]"
  m="$m\nbp[io]\t\t\tcc peers [incoming|outgoing]"
  m="$m\nhs[012ecgubvm]\t\thistoric summary report [0-both|1-main|2-backup|el|cc|geth|besu|beacon|vc|mev]"
  m="$m\n[ec]sp [i] [n]\t\tel|cc show peers exclude [i(1)-9][0-9]|include [0-n(9)]"
  m="$m\ncc[a|r|e]\t\tcc add/remove long-lived parms|change cc-el"
  m="$m\nvcc\t\t\tvc switch cc order"
  m="$m\ntvc\t\t\tvc transfer ($cuvc -> $nxvc)"
  m="$m\ncpe [cp]\t\tclock & cpu & errors status"
  m="$m\nm[vr|re]\t\tmev validator registration|relay erros"
  m="$m\nw[s|a|pr|l [e]]\t\tfirewall status|arranca|para|logs [exclude]"
  m="$m\nn[sh|rs]\t\tnetwork show|reset"
  m="$m\nd[sh [url]|rs]\t\tdns show [url]|reset"
  m="$m\nh[sh|sa|rs|ch|ca|di|da]\t$s45 show|show@$(snc $cunt)|restart|check|check all|diff ($(snc $cunt)-$(snc $cunm))|diff all avg"
  m="$m\nr[sh|rs|pt]\t\trestart gap show|reset|print"
  m="$m\ni[sh|ch]\t\texternal ip show|change"
  m="$m\nj[sh|rs]\t\tjournal logs show|reset"
  m="$m\nf[sh|rf|ud [d]]\t\tfirmware show|refres|hupdate [device-id]"
  m="$m\nvex [n]\t\t\texpectations n=validators(${#b[@]})"
  m="$m\ntmp\t\t\ttemperature show"
  m="$m\nsif\t\t\tsystem info show"
  m="$m\nchk\t\t\tcheck server with chkrootkit"
  m="$m\nlup\t\t\tcheck apt list --upgradable"
  m="$m\nsnr\t\t\tremove snapd"
  m="$m\nlp\t\t\tlista portas"
  m="$m\neip\t\t\tset dynamic DNS"
  m="$m\nulg [d]\t\t\tshow update logs d($(date +%F)) on $(basename $p69)"
  m="$m\nulr [d]\t\t\tshow restartings d($(date +%F)) on $(basename $p69)"
  swn "\n$m\n"
fi
