#!/bin/bash

source /home/eth/eth2/t1

# utilities for commands/journal
function nu0 { if [ ${1:-0} -eq $1 ] 2>/dev/null;then echo $1;else echo 0;fi; }                                                                               # get numeric output (must use [ ] test)
function nu1 { echo "scale=$2;$1"      |bc; }                                                                                                                 # get arbitrary precision calculations
function nu2 { echo 0$(printf '+%i' $@)|bc; }                                                                                                                 # get sum list of numbers
function nu3 { printf ${4:-%.0f} $(nu1 $1*${3:-100} ${2:-0}); }                                                                                               # format arbitrary precision calculations
function nu4 { if [[ $5 -ne 0  ]];then nu1 "($1*$pmis+$2*$pmat+$3*$pmah+$4*$pdly)/$5*$rate/$decp" 2;else echo 0;fi; }                                         # get penalty
function nu5 { if [[ $3 -gt $1 ]];then echo $(($2/$3))                                             ;else echo 0;fi; }                                         # get targeted division
function nu6 { if [[ $# -gt 0  ]];then echo $(nu3 $(nu2 $@)/$(echo $@|wc -w) 5 1)                  ;else echo 0;fi; }                                         # get average of numbers
function nu7 { if [[ $1 -ne 0  ]];then echo $1                                                     ;else echo 1;fi; }                                         # get safe denominator
function nu8 { nu2 $(echo "$l1"|cut -f$1); }                                                                                                                  # get sum specific list of numbers
function nu9 { echo $1|sed 's%node\([0-9]*\):%\1%'; }                                                                                                         # get peers from node tag
function fs0 { echo $1|egrep '^[0-9]+$'       ; }                                                                                                             # integer test
function fs1 { echo $1|egrep '^[0-9]+:[0-9]+$'; }                                                                                                             # hh:mm   test
function fs2 { echo $H|sudo -S grep -i 'geth\[\|lighthouse'   $p4 2>/dev/null; }                                                                              # get eth      syslog lines
function fs3 { echo $H|sudo -S grep -v 'geth\[\|lighthouse'   $p4 2>/dev/null; }                                                                              # get sys      syslog lines
function fs4 { echo $H|sudo -S grep    "${3:-lighthouse}.*$1" $p4 2>/dev/null|if [[ ${2:-0} -le 0 ]];then cat;else tail -n${2:-0};fi; }                       # get tail     syslog lines
function fs5 { echo $H|sudo -S grep    "$1"                   $p4 2>/dev/null; }                                                                              # get specific syslog lines
function fs6 { fs4 ${2:-peers:} $1|sed "s%.*${2:-peers:} \([0-9]*\).*%\1%"; }                                                                                 # get peers    syslog lines
function fs7 { if [[ $# -gt 0 ]];then echo $1$#${@:$#};else echo 0;fi; }                                                                                      # get first#last parms
function rd0 { $sctl status $1 2>/dev/null|grep "${2:-inactive\|failed}"                                   ; }                                                # service status word test
function rd1 { $sctl status $1 2>/dev/null|grep "${2:-Active:}"|sed "s%.*${2:-Active:} *\(${3:-.}*\).*%\1%"; }                                                # service status word with data extraction
function rd2 { nn=$2;cp $p8/$1.service $p0/$1.sav;sed "s%peers *[0-9]*%peers $2%" $p0/$1.sav > $p8/$1.service; }                                              # change service configuration file
function rd3 { resolvectl query smtp.gmail.com 2>/dev/null 1>&2;sex "$sctl stop $1";dmr                      ; }                                              # DNS force smpt stop/load service
function rd4 { local n=$(($2+$3));nn=$3;[[ $2 -ne 0 && $n -ge $4 && $n -le $5 ]] && rd2 $1 $n;rd3 $1         ; }                                              # change/stop/load service process
function rd5 { cex "$sctl stop $dnsd";sex "$sctl stop systemd-resolved";cex "$sctl start $dnsd";sex "$sctl start systemd-resolved"; }                         # DNS stop/start
function cex { echo -e "${i}${1^^}${f}";echo $H|sudo -S $1 2>/dev/null     ; }                                                                                # superuser-command (visible)
function sex {                          echo $H|sudo -S $1 2>/dev/null 1>&2; }                                                                                # superuser-command (silent)
function dmr { sex "$sctl daemon-reload"                     ; }                                                                                              # daemon-reload
function jsh { cex "journalctl --no-hostname --no-full -f $1"; }                                                                                              # my journal   format
function dts { date '+%Y-%m-%d %H:%M'; }                                                                                                                      # my logs date format
function sst { echo "$1 $(printf '%6s' $(rd1 $2 Memory:)) $(dts) status: $(rd1 $2)"; }                                                                        # GETH/BEAC/VALI status
function dnn { echo "$1 $2 $(printf 'node%02i:' $3) $(printf '%2i' $4)"            ; }                                                                        # date/nodes info
# geth control commands
function gv  { nu0 $(rd1 $ethg maxpeers [0-9])                                        ; }                                                                     # get configured peers
function gq  { nu0 $(geth attach "http://$cgth:8545" --exec net.peerCount 2>/dev/null); }                                                                     # get current    peers
function gy  {       geth attach "http://$cgth:8545" --exec eth.syncing   2>/dev/null ; }                                                                     # current syncing status
function gi  { echo $@|sed 's%.*highestBlock: *\([0-9]*\).*%\1%'; }                                                                                           # get highest geth block
function gc  { echo $@|sed 's%.*currentBlock: *\([0-9]*\).*%\1%'; }                                                                                           # get current geth block
function gb  { g0=$(fs4 'mported new' 0 geth|wc -l);ok=OK;[[ $g0 -eq $(grep sgs: $p5 2>/dev/null|tail -n1|sed 's%.* \([0-9]*\)%\1%') ]] && ok=BK; }           # imported new chain segments & OK/BK
function gl  {                                                                                                                                                # geth report
  if [[ $(rd0 $ethg running) ]];then local e=$(gy);gb;m="$(dnn $(dts) $(gv) $(gq)) sgs: $(printf '%4i' $g0)"
    if [[ $(echo $e|grep false) ]];then m=" $ok SYC $m";else m=" $ok NSY $m blocks: $(($(gi $e)-$(gc $e)))";fi                                                # OK SYC/NSY (dnn) sgs: 5 blocks: 8 (6)
  else
    m=" NOT RUNNING $(dts)"
  fi
}
function gh  { [[ ! -f $p5 ]] && return;tail -n${1:-$hors} $p5;[[ $1 ]] && return;gl;echo -e "GETH$m\n";sst GETH $ethg;cpe; }                                 # geth historic report
function grs { rd4 $ethg $1 $(gv) 10 15;sex "$sctl start $ethg";sleep 20s;echo "GETH RESTAR $(dnn $(dts) $nn $(gq))" >> $p5; }                                # change/stop/load/start/log geth restart
# beacon control commands
function bv  { nu0 $(rd1 $ethb target-peers [0-9])                                     ; }                                                                    # get configured peers
function bz  { echo $((10*(9*zk+3*zz+zx+zw)))                                          ; }                                                                    # get numerator paid errors
function bw  { echo $((10*z1))                                                         ; }                                                                    # get numerator processed blocks
function bf  { echo $((90*z3))                                                         ; }                                                                    # get numerator general errors
function bu  { echo $(($(nu5 200 $(bz) $z5)+$(nu5 100 $(bw) $z2)+$(nu5 100 $(bf) $z4))); }                                                                    # get restart idx
function bs  { tail -n$1 $p2 2>/dev/null|cut -d' ' -f1|sort -u|wc -l; }                                                                                       # get restart activity test
function bk  { cat       $p2 2>/dev/null                      |wc -l; }                                                                                       # get beacon line count
function bb  { l0=$(fs4 $bpid] 3600);bl1;local g=$(bu);[[ ($g -ge 1 && $(bs $hors) -eq 1) || ($g -ge 5 && $(bs 5) -eq 1) ]] && ok=BK; }                       # set ok (OK/BK)
function bl  { if [[ $(rd0 $ethb running) ]];then bl2;dt=$(dts);nn=$(bv);nr=$(fs6 1);bb;blo;else m=" NOT RUNNING $(dts)";fi; }                                # beacon report
function bl0 { fs4 "attestation(s).*$1"|sed 's%.*validators: *\[\(.*\)\].*%\1%'|wc -w; }                                                                      # get paid activities
function bl1 {                                                                                                                                                # set restart idx vars
  z1=${1:-$(echo "$l0"|grep 'rocessed block'|wc -l)};z2=${2:-$(echo "$l0"|grep 'block received'|wc -l)}                                                       # set processed/received blocks
  z3=${3:-$(echo "$l0"|grep -v ' INFO '     |wc -l)};z4=${4:-$(echo "$l0"|grep    ' INFO '     |wc -l)}                                                       # set error/info         lines
  z5=${5:-$(bl0 success)};zk=${6:-$(bl0 missing)};zz=${7:-$(bl0 target)};zx=${8:-$(bl0 head)};zw=${9:-$(bl0 had)};ok=${10:-OK}                                # set success/erros      activities
}
function bl2 { b0=${1:-$(fs4 'published block'|wc -l)};b1=${2:-$(nu6 $(fs4 delay_ms:|sed 's%.*delay_ms: *\([0-9]*\).*%\1%'))}; }                              # set published blocks/avg delays
function bm  {                                                                                                                                                # bmedias report
  bm0;b4=0;b5=$(fs4 reduce|wc -l);dt=$(dts);nn=$(bv);nr=$(fs6 1);nm=$(fs6 0|sort -n|head -n1);[[ -f $p7 ]] && bm5                                             # ini vars/arrays
  l3=$(tail -n$(($(bk)-o[1])) $p2 2>/dev/null|bm3);[[ $l3 ]] && bm1 20;bm2;[[ ${b2:=0} -eq 0 ]] && bo0                                                        # add beacon lines & homologous position
  b3=$(nu6 $(sed -Ee 's%BEAC +[0-9]+ +([0-9]+).+%\1%' $p3 2>/dev/null));bm6 20 ${a[$nn]};[[ $(bs $hors) -gt 1 || $b2 -lt 5 ]] && b4=0;bmo;bno                 # change configured peers & outputs
}
function bm0 { unset o;o[1]=0;unset k;k[0]=0;unset z;z[0]=0;unset x;x[0]=0;unset w;w[0]=0;unset c;c[0]=0;unset a;a[0]=0;bm7 20; }                             # ini err/cnt/avg penalty arrays
function bm1 {
  l1=$(echo "$l3"|grep "node$1:"|sed -Ee 's%.+erros: +([0-9]+) +([0-9]+) +([0-9]+) +([0-9]+).+%\1\t\2\t\3\t\4%')                                              # set paid error lines for current array
  [[ $l1       ]] && { ((k[$1]+=$(nu8 1)));((z[$1]+=$(nu8 2)));((x[$1]+=$(nu8 3)));((w[$1]+=$(nu8 4)));((c[$1]+=$(echo "$l1"|wc -l))); }                      # sum/cnt current paid err arrays
  [[ $1 -lt 50 ]] && bm1 $(($1+5))                                                                                                                            # recursively sum paid err arrays
}
function bm2 {
  k[0]=$(($(bnk 50 '0' '+')));z[0]=$(($(bnz 50 '0' '+')));x[0]=$(($(bnx 50 '0' '+')));w[0]=$(($(bnw 50 '0' '+')));c[0]=$(($(bnc 50 '0' '+')))                 # tot err/cnt arrays
  a[0]=$(bm4 0);a[20]=$(bm4 20);a[25]=$(bm4 25);a[30]=$(bm4 30);a[35]=$(bm4 35);a[40]=$(bm4 40);a[45]=$(bm4 45);a[50]=$(bm4 50)                               # avg penalty arrays
}
function bm3 { grep BEAC; }                                                                                                                                   # filter beacon lines
function bm4 { nu4 ${k[$1]} ${z[$1]} ${x[$1]} ${w[$1]} ${c[$1]}                ; }                                                                            # get penalty from paid err arrays
function bm5 { read -a o <<< $(tail -n1 $p7);bmk 20;bmz 20;bmx 20;bmw 20;bmc 20; }                                                                            # set err/cnt penalty arrays from barqivo
function bm6 { local g=$2;if [[ $(nu3 ${a[$1]}) -lt $(nu3 $g) ]];then b4=$(($1-nn));g=${a[$1]};fi;[[ $1 -lt 50 ]] && bm6 $(($1+5)) $g; }                      # com recursively avg/cur penalties
function bm7 { k[$1]=0;z[$1]=0;x[$1]=0;w[$1]=0;c[$1]=0;a[$1]=0                                   ;[[ $1 -lt 50 ]] && bm7 $(($1+5))   ; }                      # ini recursively penalty arrays
function bmk { local g=${2:-19};k[$1]=${o[$g]};[[ $1 -lt 50 ]] && bmk $(($1+5)) $((g-1))  ; }                                                                 # set recursively missing       err array
function bmz { local g=${2:-27};z[$1]=${o[$g]};[[ $1 -lt 50 ]] && bmz $(($1+5)) $((g-1))  ; }                                                                 # set recursively failed target err array
function bmx { local g=${2:-35};x[$1]=${o[$g]};[[ $1 -lt 50 ]] && bmx $(($1+5)) $((g-1))  ; }                                                                 # set recursively failed head   err array
function bmw { local g=${2:-43};w[$1]=${o[$g]};[[ $1 -lt 50 ]] && bmw $(($1+5)) $((g-1))  ; }                                                                 # set recursively delay         err array
function bmc { local g=${2:-11};c[$1]=${o[$g]};[[ $1 -lt 50 ]] && bmc $(($1+5)) $((g-1))  ; }                                                                 # set recursively               cnt array
function bnk { if [[ $1 -ge 20 ]];then bnk $(($1-5)) "$2$3${k[$1]}" "$3";else echo "$2";fi; }                                                                 # sum recursively missing       err array
function bnz { if [[ $1 -ge 20 ]];then bnz $(($1-5)) "$2$3${z[$1]}" "$3";else echo "$2";fi; }                                                                 # sum recursively failed target err array
function bnx { if [[ $1 -ge 20 ]];then bnx $(($1-5)) "$2$3${x[$1]}" "$3";else echo "$2";fi; }                                                                 # sum recursively failed head   err array
function bnw { if [[ $1 -ge 20 ]];then bnw $(($1-5)) "$2$3${w[$1]}" "$3";else echo "$2";fi; }                                                                 # sum recursively delay         err array
function bnc { if [[ $1 -ge 20 ]];then bnc $(($1-5)) "$2$3${c[$1]}" "$3";else echo "$2";fi; }                                                                 # sum recursively               cnt array
function bo0 {                                                                                                                                                # homologous lines/position
  b2=0;[[ ! -f $p2 ]] && return;local t=00:00;[[ $(fs0 $1) ]] && b2=$1;[[ $(fs0 $2) ]] && b2=$2;[[ $(fs1 $1) ]] && t=$1;[[ $(fs1 $2) ]] && t=$2               # forced position/time
  local l=$(bo2 . $p2|tail -n1|sed 's%.* \([0-9]*-[0-9]*-[0-9]*\) \([0-9]*:[0-9]*\).*%\1\t\2%')                                                               # last date/time in beacon log
  local d=$(echo "$l"|cut -f1);[[ $t = 00:00 ]] && t=$(echo "$l"|cut -f2);l2=$(bo2 $t $p2);[[ $b2 -eq 0 ]] && b2=$(bo3 $d)                                    # set homologous lines/position
  local n=0;while [[ ${b2:=0} -eq 0 && $n -lt 50 ]];do ((n+=1));d=$(date -d "$n days ago $t" '+%Y-%m-%d');b2=$(bo3 $d);done                                   # search past homologous info (max 50 days)
}
function bo1 {                                                                                                                                                # homologous report
  [[ ! -f $p2 ]] && return;local g=${b2:-0};local d=${b2:-0};if [[ $(fs0 $1) ]];then g=$1;else if [[ $g -lt 5 && $(bo4) -ge 5 ]];then d=5;g=5;fi;fi           # ajust head lines
  if [[ $(fs0 $1) ]];then d=$1;else if [[ $d -gt $hors ]];then d=$hors;fi;fi;bo6|head -n$g|tail -n$d                                                          # ajust tail lines & output
}
function bo2 { cat $2|grep "BEAC.*${1:-23:58}"; }                                                                                                             # get homologous beacon lines
function bo3 { bo6|grep -n $1|cut -d: -f1     ; }                                                                                                             # get homologous beacon lines position
function bo4 { echo "$l2"|wc -l               ; }                                                                                                             # get homologous beacon lines count
function bo6 { echo "$l2"|sort -k10.1n        ; }                                                                                                             # get homologous beacon lines sorted
function bh  {                                                                                                                                                # historic report
  [[ ! -f $p2 ]] && return;tail -n${1:-$hors} $p2;[[ $1 ]] && return;bo0;echo -e "BO$(printf '%5i' $(bo4)) $(printf '%3i' $b2)";bo1                           # beacon/homologous report
  bl;echo -e "BL$(printf '%9i' $(cat $p2 2>/dev/null|wc -l))\nBEAC$m";bm;echo -e "BM$(printf '%5i' $(cat $p3 2>/dev/null|wc -l))\nBEAC$m"                     # beacon/medias report
  sst BEAC $ethb;sst VALI $ethv;cpe                                                                                                                           # beacon/validator/system status
}
function brs {                                                                                                                                                # beacon/validator restart
  [[ -f $p9 ]] && return;touch $p9;local n=0;while [[ -f $p9 && $n -lt 300 ]];do                                                                              # search restart position
    if [[ $(fs7 $(fs4 "$bpid].*INFO " 7|sed 's%.*INFO \([^ ]*\).*%\1%'|sort -u)) = New2Synced ]];then                                                         # ideal = only 2 INFO words (New2Synced)
      ok=${2:-$ok};rd4 $ethb $1 $(bv) 20 50;[[ $2 = VC ]] && sex "$sctl stop $ethv";rm -f $p9                                                                 #         stop beacon/validator
      if [[ $2 = RB ]];then bro $n;sex reboot;else sex "$sctl start $ethb";[[ $2 = VC ]] && sex "$sctl start $ethv";sleep 20s;bro $n;fi                       # reboot/start beacon/validator
    fi;sleep 3s;((n+=1))                                                                                                                                      # search max 200 times, every 3s
  done;rm -f $p9
}
function bro { echo "RSTR $ok $(printf '%3i' $1) $(dnn $(dts) $nn $(fs6 1))" >> $p2; }                                                                        # log restart info
function brl {                                                                                                                                                # recalculate beacon/bmedias logs
  [[ -f ${p2}new ]] && rm ${p2}new;[[ -f ${p3}new ]] && rm ${p3}new
  unset v;while read -a v;do ok=${v[1]};dt=${v[3]}\ ${v[4]};nn=$(nu9 ${v[5]});nr=${v[6]}                                                                      # uncalculated vars
    if [[ ${v[0]} = BEAC ]];then
      bl1 ${v[19]} ${v[20]} ${v[22]} ${v[23]} ${v[11]} ${v[15]} ${v[16]} ${v[17]} ${v[18]} ${v[1]};bl2 ${v[13]} ${v[26]};blo                                  #  BEAC lines calculated output
    else
      m=" $ok $(printf '%3i' ${v[2]}) $(dnn $dt $nn $nr)"                                                                                                     # !BEAC lines
    fi                                                                      ;echo "${v[0]}$m" >> ${p2}new                                                     # new beacon output
  done <<< $(cat $p2)
  [[ ! -f $p3 ]] && return;bm0;local d='0000-00-00';local l=0;local n=0;local h=0;local g=0;while read -a o;do
    d=${o[3]};h=$g;g=$(grep -n "$d 23:58" ${p2}new|cut -d: -f1);dt=${o[3]}\ ${o[4]};nn=$(nu9 ${o[5]});nr=${o[6]};nm=${o[20]};b4=${o[18]};b5=${o[19]}          # beacon log position & uncalculated vars
    l2=$(head -n$g ${p2}new|bo2);b2=$(bo3 $d);((l+=b2));((n+=1));b3=$(nu3 $l/$n 5 1)                                                                          # cur/avg homologous position
    l3=$(head -n$g ${p2}new|tail -n$((g-h))|bm3);[[ $l3 ]] && bm1 20;bm2;bmo;echo "${o[0]}$m" >> ${p3}new                                                     # sum err arrays & new bmedias output
  done <<< $(cat $p3)
}
function bsl {                                                                                                                                                # shrink beacon log using barqivo
  [[ -f ${p2}new ]] && rm ${p2}new;[[ -f ${p7}new ]] && rm ${p7}new
  tail -n$(($(cat $p2|wc -l)-$(tail -n1 $p7|cut -d' ' -f2))) $p2 > ${p2}new                                                                                   # new beacon  log output
  head -n$(($(cat $p7|wc -l)-1)) $p7 > ${p7}new;tail -n1 $p7|sed 's%BEAC [0-9]*%BEAC 0%' >> ${p7}new                                                          # new barqivo log output
}
function bnl {
  [[ -f $p2 && -f ${p2}new ]] && { cp $p2 ${p2}sav;mv ${p2}new $p2; }                                                                                         # substitute new beacon  log
  [[ -f $p3 && -f ${p3}new ]] && { cp $p3 ${p3}sav;mv ${p3}new $p3; }                                                                                         # substitute new bmedias log
  [[ -f $p7 && -f ${p7}new ]] && { cp $p7 ${p7}sav;mv ${p7}new $p7; }                                                                                         # substitute new barqivo log
}
function nsh {
  echo -e "ROUTES\t\t$(ip route show|grep 'default via'|grep -v linkdown|cut -d' ' -f3)\nDNS\t\t$(resolvectl|grep 'Current DNS'|cut -d' ' -f6)"               # routes
  local v=0;for v in $(ip a|grep 'state UP'|cut -d: -f2);do echo -e "$v\t\t$(resolvectl dns|grep $v|cut -d' ' -f4-6)";done                                    # dns info
}
function cpe {                                                                                                                                                # system status
  local e='NO';[[ $(timedatectl|grep synchronized:|sed 's%.*synchronized: \([a-z]*\).*%\1%') = yes ]] && e='OK'                                               # clock info
  echo "CLCK $e $(printf '%3i' $(fs5 'check system clock'|wc -l)) $(dts) status: $(rd1 systemd-timesyncd)"
  [[ $1 = c ]] && return;local l=0;local n=0;local v=0                                                                                                        # cpu info
  local e=$(fs5 'ture/speed normal'|tail -n1|sed 's%.* \([0-9]*:[0-9]*:[0-9]*\).*%\1%')
  local d=$(fs5 'e above threshold'|head -n1|sed 's%.* \([0-9]*:[0-9]*:[0-9]*\).*%\1%')
  for v in $(sensors 2>/dev/null|grep 'Package\|Core'|sed 's%.*: *\([-+][0-9][0-9]*\.[0-9]*\).*%\1%');do n=$((n+1));l=$(nu1 $l$v 1);done
  [[ $e ]] && e="normal: $e";[[ $d ]] && d="throttled: $d";echo "TEMP $(nu3 $l/$(nu7 $n) 1 1 %5.1fC) $(dts) $d $e"
  [[ $1 = p ]] && return;local l=$(fs3|grep -i 'error' |wc -l);local n=$(fs2|grep -v ' INFO '|wc -l)                                                          # sys/eth errors info
  local e=$(fs3|grep -i 'error' |tail -n1|sed 's%.*hrv-zotac[0-9] *\(.*\)%\1%;s%:%%g;s%  *% %g'                                |cut -c1-53)
  local d=$(fs2|grep -v ' INFO '|tail -n1|sed 's%.*[0-9]*:[0-9]*:[0-9]*\.[0-9][0-9][0-9]]* *\(.*\)%\1%;s%:%%g;s%:%%g;s%  *% %g'|cut -c1-53)
  m="ERRO $(printf '%2i' $l) $(printf '%3i' $n) $(dts)";[[ $l -gt 0 ]] && m="$m sys: $e";[[ $n -gt 0 ]] && m="$m eth2: $d";echo "$m"                          # output
}
function blo {
  #    0  1   2          3     4       5  6               7   8    9                 10   11  12 13    14 15 16  17 18 19  20  21  22   23   24     25  26
  # BEAC OK   0 2022-01-03 19:58 node50: 55 reward_penalty: 257 2.23 attestation_block: 3384 1310 0 erros: 0  7  93 17  0 581   0   8 3592  720 delay: 428
  m=" $ok $(printf '%3i' $(bu)) $(dnn $dt $nn $nr) reward_penalty: $(nu3 "($z5*$ratt+$b0*$rblk)*$rate/$decp" 0 1 %3i) $(printf '%4.2f' $(nu4 $zk $zz $zx $zw 1))"
  m="$m attestation_block: $(printf '%4i' $z5) $(printf '%4i' $(bz)) $(printf '%1i' $b0) erros: $(printf '%1i' $zk) $(printf '%2i' $zz) $(printf '%3i' $zx)"
  m="$m $(printf '%2i' $zw) $(printf '%2i' $z1) $(printf '%3i' $z2) $(printf '%3i' $(bw)) $(printf '%2i' $z3) $(printf '%4i' $z4) $(printf '%4i' $(bf))"
  m="$m delay: $(printf '%3i' $b1)"
}
function bmo {
  #    0  1   2          3     4       5  6    7    8    9   10   11   12   13   14          15   16         17 18 19 20
  # BEAC  6  22 2022-01-04 07:27 node50: 54 avg: 1.06 1.08 1.34 2.24 2.65 1.95 1.97 global_avg: 1.49 crm_peers:  0  0 52
  m=" $(printf '%2i' $b3) $(printf '%3i' $b2) $(dnn $dt $nn $nr) avg: $(printf '%4.2f' ${a[50]}) $(printf '%4.2f' ${a[45]}) $(printf '%4.2f' ${a[40]})"
  m="$m $(printf '%4.2f' ${a[35]}) $(printf '%4.2f' ${a[30]}) $(printf '%4.2f' ${a[25]}) $(printf '%4.2f' ${a[20]}) global_avg: $(printf '%4.2f' ${a[0]})"
  m="$m crm_peers: $(printf '%2i' $b4) $(printf '%2i' $b5) $(printf '%2i' $nm)"
}
#    0   1          2     3    4 5 6 7 8 9 10 11   12 13 14 15 16 17 18 19   20 21 22 23 24 25 26 27   28 29 30 31 32 33 34 35   36 37 38 39 40 41 42 43
# BEAC 620 2021-12-09 09:17 cnt: 0 0 0 0 0 11 11 mis: 22 22 22 22 22 22 22 mat: 33 33 33 33 33 33 33 mah: 44 44 44 44 44 44 44 dly: 55 55 55 55 55 55 55
function bno { s=" $(bk) $dt $(bnc 50 'cnt:' ' ') $(bnk 50 'mis:' ' ') $(bnz 50 'mat:' ' ') $(bnx 50 'mah:' ' ') $(bnw 50 'dly:' ' ')"; }
# Plex Media Server
function rxw { cex "ufw$2 allow from 192.168.8.0/24 $1"; }
function xop { cex 'ufw delete deny 32400             ';rxw 'to any port 32400 comment plex'; }
function xcl { cex 'ufw        deny 32400 comment plex';rxw 'to any port 32400 '   ' delete'; }
function xe  { xop;cex 'ufw reload';cex "$sctl enable $plex"; }
function xa  { [[ $(rd0 $plex       ) ]] && { cex "$sctl start $plex"; } }
function xp  { [[ $(rd0 $plex loaded) ]] && { cex "$sctl stop  $plex"; } }
function xd  { cex "$sctl disable $plex";xcl;cex 'ufw reload'; }
# Transmission BitTorrent Daemon
function rop { cex 'ufw allow 51413 comment torrent';rxw 'to any port 9091 comment torrent'; }
function rcl { cex 'ufw deny  51413 comment torrent';rxw 'to any port 9091'       ' delete'; }
function re  { rop;cex 'ufw reload';cex "$sctl enable $trrt"; }
function ra  { [[ $(rd0 $trrt       ) ]] && { cex "$sctl start $trrt"; } }
function rp  { [[ $(rd0 $trrt loaded) ]] && { cex "$sctl stop  $trrt"; } }
function rd  { cex "$sctl disable $trrt";rcl;cex 'ufw reload'; }
# Bind9
function sop { cex 'ufw delete deny 53            ';rxw 'to any port 53 comment dns'; }
function scl { cex 'ufw        deny 53 comment dns';rxw 'to any port 53 '  ' delete'; }
function se  { sop;cex 'ufw reload';cex "$sctl enable $dnsd"; }
function sa  { [[ $(rd0 $dnsd disabled) ]] || { [[ $(rd0 $dnsd) ]] && cex "$sctl start $dnsd"; } }
function sp  { [[ $(rd0 $dnsd loaded  ) ]] && { cex "$sctl stop $dnsd"; } }
function sd  { cex "$sctl disable $dnsd";scl;cex 'ufw reload'; }
# open/close goethereum/beacon/validator/grafana
function gfw { if [[ $cust = hrv ]];then cex "ufw$2 allow from $zip2 $1";cex "ufw$2 allow from $zip3 $1";else cex "ufw$2 allow from $vip1 $1";cex "ufw$2 allow from $vip3 $1";fi; }
function gop { cex 'ufw allow 30303 comment eth1';cex 'ufw delete deny 8545              ';gfw 'to any port 8545 comment geapi'; }
function gcl { cex 'ufw deny  30303 comment eth1';cex 'ufw        deny 8545 comment geapi';gfw 'to any port 8545'     ' delete'; }
function ofw { if [[ $cust = hrv ]];then cex "ufw$2 allow from $zip2 $1";cex "ufw$2 allow from $zip3 $1";else cex "ufw$2 allow from $vip1 $1";cex "ufw$2 allow from $vip3 $1";fi; }
function oop { cex 'ufw allow 30303 comment eth1';cex 'ufw delete deny 8545              ';gfw 'to any port 8545 comment oeapi'; }
function ocl { cex 'ufw deny  30303 comment eth1';cex 'ufw        deny 8545 comment oeapi';gfw 'to any port 8545'     ' delete'; }
function bfw { if [[ $cust = hrv ]];then cex "ufw$2 allow from 192.168.8.0/24 $1";else cex "ufw$2 allow from $vip3 $1";fi; }
function bop { cex 'ufw allow 9000 comment eth2';cex 'ufw delete deny 5052              ';bfw 'to any port 5052 comment bnapi'; }
function bcl { cex 'ufw deny  9000 comment eth2';cex 'ufw        deny 5052 comment bnapi';bfw 'to any port 5052'     ' delete'; }
function vfw { if [[ $cust = hrv ]];then cex "ufw$2 allow from $zip1 $1";else cex "ufw$2 allow from $vip1 $1";fi; }
function vop { cex 'ufw delete deny 5064              ';`# vfw 'to any port 5064 comment vcmet'` ; }
function vcl { cex 'ufw        deny 5064 comment vcmet';`# vfw 'to any port 5064'     ' delete'` ; }
function fop { cex 'ufw allow 3000/tcp comment grafana'; }
function fcl { cex 'ufw deny  3000/tcp                '; }
# enable/arranca goethereum/beacon/validator/prometheus/grafana
function ge  { gop;cex 'ufw reload';cex "$sctl enable $ethg"; }
function be  { bop;cex 'ufw reload';cex "$sctl enable $ethb"; }
function ve  { [[ ! -f $dtdi/vc_lock ]] && { vop;cex 'ufw reload';cex "$sctl enable $ethv"; } }
function pe  { cex 'ufw reload';cex "$sctl enable $ethp"; }
function ne  { cex 'ufw reload';cex "$sctl enable $ethn"; }
function fe  { fop;cex 'ufw reload';cex "$sctl enable $ethf"; }
function ga  { [[ $(rd0 $ethg) ]] && [[ -d /var/lib/goethereum   ]] && { cex "$sctl start $ethg"; } }
function ba  { [[ $(rd0 $ethb) ]] && { cex "$sctl start $ethb"; } }
function va  {
  [[ $(rd0 $ethv) ]] || return                                                                                                                                # continue if inactive\|failed
  if [[ -f $dtdi/vc_lock ]];then
    if [[ -f $p0/slashing_protection.sqlite ]];then                                                                                                           # slashing_protection
      echo $H|sudo -S cp $p0/slashing_protection.sqlite $vldt 2>/dev/null
      sudo chown eth3:eth3 $vldt/slashing_protection.sqlite
      sudo chmod 600 $vldt/slashing_protection.sqlite
    fi
  else
    cex "$sctl start $ethv"
    rm $dtdi/vc_slash
  fi
}
function pa  { [[ $(rd0 $ethp) ]] && { cex "$sctl start $ethp"; } }
function na  { [[ $(rd0 $ethn) ]] && { cex "$sctl start $ethn"; } }
function fa  { [[ $(rd0 $ethf) ]] && { cex "$sctl start $ethf"; } }
function wa  {
  if [[ $(echo $H|sudo -S ufw status 2>/dev/null|grep -i inactive) ]];then
    echo -e "${i}UFW ENABLE${f}";sudo ufw enable <<< y                                                                                                        # enable asks: Proceed with operation (y|n)?
  else
    echo -e "${i}FIREWALL ALREADY ACTIVE${f}"
  fi
}
# para/disable goethereum/beacon/validator/prometheus/grafana
function gp  { [[ $(rd0 $ethg loaded) ]] && { cex "$sctl stop $ethg"; } }
function bp  { [[ $(rd0 $ethb loaded) ]] && { cex "$sctl stop $ethb"; } }
function vp  { [[ $(rd0 $ethv loaded) ]] && { cex "$sctl stop $ethv";touch $dtdi/vc_slash; } }
function pp  { [[ $(rd0 $ethp loaded) ]] && { cex "$sctl stop $ethp"; } }
function np  { [[ $(rd0 $ethn loaded) ]] && { cex "$sctl stop $ethn"; } }
function fp  { [[ $(rd0 $ethf loaded) ]] && { cex "$sctl stop $ethf"; } }
function gd  { cex "$sctl disable $ethg";gcl;cex 'ufw reload'; }
function bd  { cex "$sctl disable $ethb";bcl;cex 'ufw reload'; }
function vd  { cex "$sctl disable $ethv";vcl;cex 'ufw reload';touch $dtdi/vc_lock; }
function pd  { [[ $(rd0 $ethp loaded) ]] && { cex "$sctl disable $ethp"; } }
function nd  { [[ $(rd0 $ethn loaded) ]] && { cex "$sctl disable $ethn"; } }
function fd  { [[ $(rd0 $ethf loaded) ]] && { cex "$sctl disable $ethf";fcl;cex 'ufw reload'; } }
function ssp {
  echo -e "${i}QUER MESMO TRANSFERIR VALIDATORS?${f}";read rsp
  if [[ $rsp = sim && ! -f $dtdi/vc_slash && ! -f $dtdi/vc_lock && -f $dtdi/vc_keys ]];then
    vp;vd
    echo -e "${i}SAVE SLASHING PROTECTION DB${f}"
    echo $H|sudo -S cp $vldt/slashing_protection.sqlite $p0 2>/dev/null;sudo chown eth:eth $p0/slashing_protection.sqlite
    if [[ $cunm = $znm3 ]];then
      scp $p0/slashing_protection.sqlite vpss:~         ;echo -e "${i}SAVED SLASHING PROTECTION DB IN vpss${f}"
    else
      scp $p0/slashing_protection.sqlite ztc3.fruga.pt:~;echo -e "${i}SAVED SLASHING PROTECTION DB IN ztc3${f}"
    fi
  fi
}

[[ $1 = eip ]] && { curl -s4 "http://${3:-meo.fruga.pt}:$2@dyn.dns.he.net/nic/update?hostname=${3:-meo.fruga.pt}" 2>/dev/null 1>&2; }
[[ $1 = dsh ]] && { echo QUERY DNS;resolvectl query ${2:-smtp.gmail.com}; }
[[ $1 = drs ]] && { echo RESET DNS;rd5; }
[[ $1 = nrs ]] && { echo RESET DNS \& NETPLAN;cex 'netplan apply';rd5; }
[[ $1 = nsh ]] && { nsh; }
[[ $1 = trs ]] && { [[ $(rd0 systemd-timesyncd masked) ]] || { cex "$sctl restart systemd-timesyncd"; };cpe c; }
[[ $1 = vcp ]] && { ssp; }
[[ $1 = gl  ]] && { gl;echo -e "GETH$m"; }
[[ $1 = glf ]] && { gl;echo -e "GETH$m" >> $p5; }
[[ $1 = bl  ]] && { bl;echo -e "BEAC$m"; }
[[ $1 = bm  ]] && { bm;echo -e "BEAC$m"; }
[[ $1 = bn  ]] && { bm;echo -e "BEAC$s"; }
[[ $1 = blf ]] && { bl;echo -e "BEAC$m" >> $p2; }
[[ $1 = bmf ]] && { bm;echo -e "BEAC$m" >> $p3; }
[[ $1 = bnf ]] && { bm;echo -e "BEAC$s" >> $p7; }
[[ $1 = gh  ]] && { gh $2; }
[[ $1 = bh  ]] && { bh $2; }
[[ $1 = bo  ]] && { bo0 $2 $3;bo1 $2; }
[[ $1 = brl ]] && { [[ -f $p2           ]] && brl; }
[[ $1 = bsl ]] && { [[ -f $p2 && -f $p7 ]] && bsl; }
[[ $1 = bnl ]] && { bnl; }
[[ $1 = cpe ]] && { cpe $2; }
[[ $1 = glr ]] && { gb;[[ $ok != OK ]] && grs 0; }
[[ $1 = blr ]] && { bb;[[ $ok != OK ]] && brs 0; }
[[ $1 = bmc ]] && { bm;[[ $b4 -ne 0 ]] && brs $b4 PE; }
[[ $1 = grs ]] && { grs ${2:-0}   ; }
[[ $1 = srs ]] && { brs ${2:-0} RB; }
[[ $1 = brs ]] && { brs ${2:-0} BN; }
[[ $1 = lrs ]] && { brs ${2:-0} VC; }
# lista servicos & portas
[[ $1 = lp  ]] && { netstat -tulpn; }
# outros journal system/lighthouse
[[ $1 = el  ]] && { fs2|if [[ $2 ]];then grep -i "[a-z]* [0-9]* $2";else grep -v ' INFO ';fi; }
[[ $1 = sl  ]] && { fs3|if [[ $2 ]];then grep -i "[a-z]* [0-9]* $2";else grep -i 'error' ;fi; }
[[ $1 = ws  ]] && { cex 'ufw status numbered'; }
[[ $1 = wa  ]] && { wa; }
[[ $1 = wpr ]] && { cex 'ufw disable'; }
# journal
[[ $1 = yj  ]] && { jsh; }
[[ $1 = ej  ]] && { jsh "-u $ethg -u $ethb -u $ethv"; }
[[ $1 = gj  ]] && { jsh "-u $ethg"; }
[[ $1 = bj  ]] && { jsh "-u $ethb"; }
[[ $1 = vj  ]] && { jsh "-u $ethv"; }
[[ $1 = sj  ]] && { jsh "-u $dnsd"; }
# arranca
[[ $1 = ga  ]] && { dmr;ga; }
[[ $1 = oa  ]] && { dmr;oa; }
[[ $1 = ba  ]] && { dmr;ba; }
[[ $1 = va  ]] && { dmr;va; }
[[ $1 = pa  ]] && { dmr;pa; }
[[ $1 = na  ]] && { dmr;na; }
[[ $1 = fa  ]] && { dmr;fa; }
[[ $1 = xa  ]] && { dmr;xa; }
[[ $1 = ra  ]] && { dmr;ra; }
[[ $1 = sa  ]] && { dmr;sa; }
# para & arranca & journal
[[ $1 = gaj ]] && { dmr;ga;jsh "-u $ethg"; }
[[ $1 = baj ]] && { dmr;ba;jsh "-u $ethb"; }
[[ $1 = vaj ]] && { dmr;va;jsh "-u $ethv"; }
[[ $1 = saj ]] && { dmr;sa;jsh "-u $dnsd"; }
[[ $1 = gpa ]] && { gp;dmr;ga;jsh "-u $ethg"; }
[[ $1 = bpa ]] && { bp;dmr;ba;jsh "-u $ethb"; }
[[ $1 = vpa ]] && { vp;dmr;va;jsh "-u $ethv"; }
[[ $1 = spa ]] && { sp;sa;jsh "-u $dnsd"; }
[[ $1 = gpd ]] && { gp;gd; }
[[ $1 = opd ]] && { op;od; }
[[ $1 = bpd ]] && { bp;bd; }
[[ $1 = vpd ]] && { vp;vd; }
[[ $1 = xpd ]] && { xp;xd; }
[[ $1 = rpd ]] && { rp;rd; }
[[ $1 = spd ]] && { sp;sd; }
[[ $1 = gea ]] && { ge;dmr;ga;jsh "-u $ethg"; }
[[ $1 = bea ]] && { be;dmr;ba;jsh "-u $ethb"; }
[[ $1 = vea ]] && { ve;dmr;va;jsh "-u $ethv"; }
[[ $1 = sea ]] && { se;sa;jsh "-u $dnsd"; }
# enable
[[ $1 = ge  ]] && { ge; }
[[ $1 = oe  ]] && { oe; }
[[ $1 = be  ]] && { be; }
[[ $1 = ve  ]] && { ve; }
[[ $1 = pe  ]] && { pe; }
[[ $1 = ne  ]] && { ne; }
[[ $1 = fe  ]] && { fe; }
[[ $1 = xe  ]] && { xe; }
[[ $1 = re  ]] && { re; }
[[ $1 = se  ]] && { se; }
# para
[[ $1 = fpr ]] && { fp; }
[[ $1 = npr ]] && { np; }
[[ $1 = ppr ]] && { pp; }
[[ $1 = vpr ]] && { vp; }
[[ $1 = bpr ]] && { bp; }
[[ $1 = gpr ]] && { gp; }
[[ $1 = opr ]] && { op; }
[[ $1 = xpr ]] && { xp; }
[[ $1 = rpr ]] && { rp; }
[[ $1 = spr ]] && { sp; }
# disable
[[ $1 = fds ]] && { fd; }
[[ $1 = nds ]] && { nd; }
[[ $1 = pds ]] && { pd; }
[[ $1 = vds ]] && { vd; }
[[ $1 = bds ]] && { bd; }
[[ $1 = gds ]] && { gd; }
[[ $1 = ods ]] && { od; }
[[ $1 = xds ]] && { xd; }
[[ $1 = rds ]] && { rd; }
[[ $1 = sds ]] && { sd; }

if [[ ! $1 ]];then
  m="primeira letra"
  m="$m\ne\t\t$ethg $ethb $ethv"
  m="$m\ng\t\t$ethg"
  m="$m\nb\t\t$ethb"
  m="$m\nv\t\t$ethv"
  m="$m\np\t\t$ethp"
  m="$m\nn\t\t$ethn"
  m="$m\nf\t\t$ethf"
  m="$m\nx\t\t$plex"
  m="$m\nr\t\t$trrt"
  m="$m\ns\t\t$dnsd"
  m="$m\nsegunda letra"
  m="$m\na[j]\t\tarranca\t[& journal]"
  m="$m\ne\t\tenable"
  m="$m\nj\t\tjournal"
  m="$m\npr\t\tpara"
  m="$m\nds\t\tdisable"
  m="$m\npd\t\tpara\t& disable"
  m="$m\npa\t\tpara\t& arranca\t& journal"
  m="$m\nea\t\tenable\t& arranca\t& journal"
  m="$m\noutros"
  if [[ $cunm = $znm3 ]];then
    m="$m\nvcp\t\t$ethv copy to $vnm3 server"
  else
    m="$m\nvcp\t\t$ethv copy to $znm3 server"
  fi
  m="$m\ngl[f]\t\tgeth log report"
  m="$m\ngh\t\tgeth historic report"
  m="$m\ngrs [n]\t\t$ethg restart n=nodes to change"
  m="$m\nbrs [n]\t\t$ethb restart n=nodes to change"
  m="$m\nsrs [n]\t\tsystem restart n=nodes to change"
  m="$m\nlrs [n]\t\tlighthouse restart n=nodes to change"
  m="$m\nyj\t\tsystem journal"
  m="$m\nsl [s]\t\tlista system journal  s=TOTAL"
  m="$m\nel [s]\t\tlista geth,lighthouse s=TOTAL"
  m="$m\nbrl\t\trecalculate beacon/bmedias logs"
  m="$m\nbsl\t\tshrink beacon log using barqivo"
  m="$m\nbnl\t\treplace logs with new versions"
  m="$m\nbl[f]\t\tbeacon log report"
  m="$m\nbm[f]\t\tmedias report"
  m="$m\nbn[f]\t\tarqivo report"
  m="$m\nbh\t\thistoric report"
  m="$m\nbo\t\thomologous report"
  m="$m\nws\t\tfirewall status"
  m="$m\nwa\t\tfirewall arranca"
  m="$m\nwpr\t\tfirewall para"
  m="$m\ncpe [cp]\t\tclock & cpu & errors status"
  m="$m\nlp\t\tlista portas"
  m="$m\neip\t\tset dynamic DNS"
  m="$m\nnsh\t\tnetwork/route/DNS show "
  m="$m\ndsh [url]\tdns show"
  m="$m\nnrs\t\tdns/netplan reset"
  m="$m\ndrs\t\tdns reset"
  m="$m\ntrs\t\ttime sync restart"
  echo -e "\n$m\n"
fi
