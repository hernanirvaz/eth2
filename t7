#!/usr/bin/python3

import json
import math
import requests
from datetime import datetime, timedelta

SLOTS_PER_EPOCH = 32
SECONDS_PER_SLOT = 12

def main(vidx=[11766,11767,11770,11771,11772,11773,11774,11775,11776,11777,11778,11779,11780,11782,11783,11784,11786,11788], url="http://192.168.8.31:5052/eth/v1/"):
    def api_get(endpoint):
        return requests.get(f"{url}{endpoint}").json()
    def api_post(endpoint, data):
        return requests.post(f"{url}{endpoint}", data).json()

    head_slot = int(api_get("beacon/headers/head")["data"]["header"]["message"]["slot"])
    epoch = head_slot // SLOTS_PER_EPOCH
    ced = api_post(f"validator/duties/attester/{epoch}", json.dumps(vidx))["data"]
    ned = api_post(f"validator/duties/attester/{epoch + 1}", json.dumps(vidx))["data"]
    attestation_duties = {}
    for d in (*ced, *ned):
        attestation_duties.setdefault(int(d["slot"]), []).append(d["validator_index"])
    attestation_duties = {k: v for k, v in sorted(attestation_duties.items()) if k > head_slot}
    first_slot_epoch_p2 = (epoch + 2) * SLOTS_PER_EPOCH
    attestation_duties[first_slot_epoch_p2] = []
    prev_end_time = datetime.now()
    longest_gap = timedelta(seconds=0)
    gap_time_range = (None, None)
    for slot, validators in attestation_duties.items():
        slot_start = datetime.fromtimestamp(1606824023 + slot * SECONDS_PER_SLOT)
        slot_end = slot_start + timedelta(seconds=SECONDS_PER_SLOT)
        gap = slot_start - prev_end_time
        if validators:
            nado = 0
        else:
            assert slot % SLOTS_PER_EPOCH == 0
        if gap > longest_gap:
            longest_gap = gap
            gap_time_range = (prev_end_time, slot_start)
        prev_end_time = slot_end
    print(f"{gap_time_range[0].strftime('%H:%M:%S')}")

if __name__ == "__main__":
    main()
